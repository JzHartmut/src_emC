/**************************************************************************
 * This file is generated by Java2C
 **copyright***************************************************************
 *************************************************************************/
#include "J1c/StringFormatterJc.h"
#include <string.h>  //because using memset()
#include <Jc/ReflectionJc.h>   //Reflection concept 
#include <Fwc/fw_Exception.h>  //basic stacktrace concept
#include "J1c/StringFunctionsJc.h"  //reference-association: StringFunctionsJc_s
#include "Jc/DateJc.h"  //new object
#include "Jc/SystemJc.h"  //reference-association: SystemJc


/* J2C: Forward declaration of struct ***********************************************/


/* J2C: Method-table-references *********************************************************/
#ifndef AppendableJcMTBDEF
  #define AppendableJcMTBDEF
  typedef struct AppendableJcMTB_t { struct Mtbl_AppendableJc_t const* mtbl; struct AppendableJc_t* ref; } AppendableJcMTB;
#endif


/**This class supports a formatted output of something in a string buffer.
In completion to the capability of java.lang.String.format() (since Java-5) and the class java.util.Formatter
this class provides<ul>
<li>a presentation of some hex formats and memory content as complete line.</li>
<li>a so named picture driven formating, see {@link setIntPicture(long, String)} or {@link setFloatPicture(long, String)}</li>
<li>the possibility of set and add content</li>
</ul>
To merge java.util.Formatter and this class you should assign the same StringBuffer to both classes.
<br>
The class contains add...-methods and knows internally a current position.
The current position can be setted with {@link pos(int)}.
In the default overwrite mode the add methods do not insert in buffer with shifting the rest to right
(like StringBuffer.insert()), but they overwrite the content at the currrent position.
The wording 'add' means, the current position is increment, so the next add()-operation adds
something behind the previous add()-operation. In the insert mode the content at pos is shifted to right.
<br>
Every {@link pos(int)}-operation is successfully. If the buffer in shorter as the required position, spaces will be filled
onto the required position. So a buffer content can also be filled first right, than left.
*/


const char sign_Mtbl_StringFormatterJc[] = "StringFormatterJc"; //to mark method tables of all implementations

typedef struct MtblDef_StringFormatterJc_t { Mtbl_StringFormatterJc mtbl; MtblHeadJc end; } MtblDef_StringFormatterJc;
 extern MtblDef_StringFormatterJc const mtblStringFormatterJc;
StringJc version_StringFormatterJc = CONST_z_StringJc("2014-08-10");
const int16 k2left_StringFormatterJc = 2 + mBytesInWordBigEndian_StringFormatterJc;
const int16 k4left_StringFormatterJc = 4 + mBytesInWordBigEndian_StringFormatterJc;
const int16 k6left_StringFormatterJc = 6 + mBytesInWordBigEndian_StringFormatterJc;
const int16 k8left_StringFormatterJc = 8 + mBytesInWordBigEndian_StringFormatterJc;
StringJc spaces_StringFormatterJc = CONST_z_StringJc("                                                          ");
const int64 n10a_StringFormatterJc[9] = { 1000000000, 100000000, 10000000, 1000000, 100000, 10000, 1000, 100, 10};
StringJc sNeg_StringFormatterJc = CONST_z_StringJc("+-%");

/*Constructor */
struct StringFormatterJc_t* ctorO_StringFormatterJc(ObjectJc* othis, ThCxt* _thCxt)
{ StringFormatterJc_s* thiz = (StringFormatterJc_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_StringFormatterJc");
  checkConsistence_ObjectJc(othis, sizeof(StringFormatterJc_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &reflection_StringFormatterJc_s, sizeof(StringFormatterJc_s));  
  //j2c: Initialize all class variables:
  {ObjectJc *newObj1_1=null, *newObj1_2=null, *newObj1_3=null, *newObj1_4=null; /*J2C: temporary Objects for new operations
      */
    thiz->secondNewline = '\0';
    thiz->pos = 0;
    thiz->bInsert = false;
    set_StringJc(&(thiz->sNewline), z_StringJc("\n"));
    thiz->cDecimalSeparator = '.';
    set_StringJc(&(thiz->sDatePrefixNewer), z_StringJc(""));
    SETREFJc(thiz->dateFormatNewer, ctorO_s_SimpleDateFormatJc(/*J2C:static method call*/(newObj1_1 = alloc_ObjectJc(sizeof_SimpleDateFormatJc_s, 0, _thCxt)), s0_StringJc("?yy-MM-dd HH:mm:ss"), _thCxt), SimpleDateFormatJc_s);
    set_StringJc(&(thiz->sDatePrefixToday), z_StringJc("today"));
    SETREFJc(thiz->dateFormatToday, ctorO_s_SimpleDateFormatJc(/*J2C:static method call*/(newObj1_2 = alloc_ObjectJc(sizeof_SimpleDateFormatJc_s, 0, _thCxt)), s0_StringJc(" HH:mm:ss"), _thCxt), SimpleDateFormatJc_s);
    set_StringJc(&(thiz->sDatePrefixYear), z_StringJc(""));
    SETREFJc(thiz->dateFormatYear, ctorO_s_SimpleDateFormatJc(/*J2C:static method call*/(newObj1_3 = alloc_ObjectJc(sizeof_SimpleDateFormatJc_s, 0, _thCxt)), s0_StringJc("MMM-dd HH:mm:ss"), _thCxt), SimpleDateFormatJc_s);
    set_StringJc(&(thiz->sDatePrefixOlder), z_StringJc(""));
    SETREFJc(thiz->dateFormatOlder, ctorO_s_SimpleDateFormatJc(/*J2C:static method call*/(newObj1_4 = alloc_ObjectJc(sizeof_SimpleDateFormatJc_s, 0, _thCxt)), s0_StringJc("yy-MM-dd HH:mm:ss"), _thCxt), SimpleDateFormatJc_s);
    activateGC_ObjectJc(newObj1_1, null, _thCxt);
    activateGC_ObjectJc(newObj1_2, null, _thCxt);
    activateGC_ObjectJc(newObj1_3, null, _thCxt);
    activateGC_ObjectJc(newObj1_4, null, _thCxt);
  }
  { 
    ObjectJc *newObj2_1=null; /*J2C: temporary Objects for new operations
    */
    SETREFJc(thiz->buffer, ctorO_StringBuilderJc(/*J2C:static method call*/(newObj2_1 = alloc_ObjectJc(sizeof_StringBuilderJc, 0, _thCxt)), _thCxt), StringBuilderJc);
    CLEAR_REFJc(thiz->lineout);
    thiz->bShouldLineoutClose = false;
    activateGC_ObjectJc(newObj2_1, null, _thCxt);
  }
  STACKTRC_LEAVE;
  return thiz;
}



/*Constructor */
struct StringFormatterJc_t* ctorO_ApbSi_StringFormatterJc(ObjectJc* othis, struct AppendableJc_t* lineout, bool shouldClose, StringJc newlineString, int32 defaultBufferLength, ThCxt* _thCxt)
{ StringFormatterJc_s* thiz = (StringFormatterJc_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_StringFormatterJc");
  checkConsistence_ObjectJc(othis, sizeof(StringFormatterJc_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &reflection_StringFormatterJc_s, sizeof(StringFormatterJc_s));  
  //j2c: Initialize all class variables:
  {ObjectJc *newObj1_1=null, *newObj1_2=null, *newObj1_3=null, *newObj1_4=null; /*J2C: temporary Objects for new operations
      */
    thiz->secondNewline = '\0';
    thiz->pos = 0;
    thiz->bInsert = false;
    set_StringJc(&(thiz->sNewline), z_StringJc("\n"));
    thiz->cDecimalSeparator = '.';
    set_StringJc(&(thiz->sDatePrefixNewer), z_StringJc(""));
    SETREFJc(thiz->dateFormatNewer, ctorO_s_SimpleDateFormatJc(/*J2C:static method call*/(newObj1_1 = alloc_ObjectJc(sizeof_SimpleDateFormatJc_s, 0, _thCxt)), s0_StringJc("?yy-MM-dd HH:mm:ss"), _thCxt), SimpleDateFormatJc_s);
    set_StringJc(&(thiz->sDatePrefixToday), z_StringJc("today"));
    SETREFJc(thiz->dateFormatToday, ctorO_s_SimpleDateFormatJc(/*J2C:static method call*/(newObj1_2 = alloc_ObjectJc(sizeof_SimpleDateFormatJc_s, 0, _thCxt)), s0_StringJc(" HH:mm:ss"), _thCxt), SimpleDateFormatJc_s);
    set_StringJc(&(thiz->sDatePrefixYear), z_StringJc(""));
    SETREFJc(thiz->dateFormatYear, ctorO_s_SimpleDateFormatJc(/*J2C:static method call*/(newObj1_3 = alloc_ObjectJc(sizeof_SimpleDateFormatJc_s, 0, _thCxt)), s0_StringJc("MMM-dd HH:mm:ss"), _thCxt), SimpleDateFormatJc_s);
    set_StringJc(&(thiz->sDatePrefixOlder), z_StringJc(""));
    SETREFJc(thiz->dateFormatOlder, ctorO_s_SimpleDateFormatJc(/*J2C:static method call*/(newObj1_4 = alloc_ObjectJc(sizeof_SimpleDateFormatJc_s, 0, _thCxt)), s0_StringJc("yy-MM-dd HH:mm:ss"), _thCxt), SimpleDateFormatJc_s);
    activateGC_ObjectJc(newObj1_1, null, _thCxt);
    activateGC_ObjectJc(newObj1_2, null, _thCxt);
    activateGC_ObjectJc(newObj1_3, null, _thCxt);
    activateGC_ObjectJc(newObj1_4, null, _thCxt);
  }
  { 
    ObjectJc *newObj2_1=null; /*J2C: temporary Objects for new operations
    */
    SETREFJc(thiz->buffer, ctorO_I_StringBuilderJc(/*J2C:static method call*/(newObj2_1 = alloc_ObjectJc(sizeof_StringBuilderJc, 0, _thCxt)), defaultBufferLength, _thCxt), StringBuilderJc);
    set_StringJc(&(thiz->sNewline), newlineString);
    SETREFJc(thiz->lineout, lineout, AppendableJc_s);
    if(shouldClose) 
    { 
      
      ASSERT(/*J2C:static method call*/ instanceof_ObjectJc(((/*J2C:cast from AppendableJc_s*/ObjectJc*)(lineout)), &reflection_CloseableJc));
    }
    thiz->bShouldLineoutClose = shouldClose;
    activateGC_ObjectJc(newObj2_1, null, _thCxt);
  }
  STACKTRC_LEAVE;
  return thiz;
}



/*Constructor */
struct StringFormatterJc_t* ctorO_i_StringFormatterJc(ObjectJc* othis, int32 length, ThCxt* _thCxt)
{ StringFormatterJc_s* thiz = (StringFormatterJc_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_StringFormatterJc");
  checkConsistence_ObjectJc(othis, sizeof(StringFormatterJc_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &reflection_StringFormatterJc_s, sizeof(StringFormatterJc_s));  
  //j2c: Initialize all class variables:
  {ObjectJc *newObj1_1=null, *newObj1_2=null, *newObj1_3=null, *newObj1_4=null; /*J2C: temporary Objects for new operations
      */
    thiz->secondNewline = '\0';
    thiz->pos = 0;
    thiz->bInsert = false;
    set_StringJc(&(thiz->sNewline), z_StringJc("\n"));
    thiz->cDecimalSeparator = '.';
    set_StringJc(&(thiz->sDatePrefixNewer), z_StringJc(""));
    SETREFJc(thiz->dateFormatNewer, ctorO_s_SimpleDateFormatJc(/*J2C:static method call*/(newObj1_1 = alloc_ObjectJc(sizeof_SimpleDateFormatJc_s, 0, _thCxt)), s0_StringJc("?yy-MM-dd HH:mm:ss"), _thCxt), SimpleDateFormatJc_s);
    set_StringJc(&(thiz->sDatePrefixToday), z_StringJc("today"));
    SETREFJc(thiz->dateFormatToday, ctorO_s_SimpleDateFormatJc(/*J2C:static method call*/(newObj1_2 = alloc_ObjectJc(sizeof_SimpleDateFormatJc_s, 0, _thCxt)), s0_StringJc(" HH:mm:ss"), _thCxt), SimpleDateFormatJc_s);
    set_StringJc(&(thiz->sDatePrefixYear), z_StringJc(""));
    SETREFJc(thiz->dateFormatYear, ctorO_s_SimpleDateFormatJc(/*J2C:static method call*/(newObj1_3 = alloc_ObjectJc(sizeof_SimpleDateFormatJc_s, 0, _thCxt)), s0_StringJc("MMM-dd HH:mm:ss"), _thCxt), SimpleDateFormatJc_s);
    set_StringJc(&(thiz->sDatePrefixOlder), z_StringJc(""));
    SETREFJc(thiz->dateFormatOlder, ctorO_s_SimpleDateFormatJc(/*J2C:static method call*/(newObj1_4 = alloc_ObjectJc(sizeof_SimpleDateFormatJc_s, 0, _thCxt)), s0_StringJc("yy-MM-dd HH:mm:ss"), _thCxt), SimpleDateFormatJc_s);
    activateGC_ObjectJc(newObj1_1, null, _thCxt);
    activateGC_ObjectJc(newObj1_2, null, _thCxt);
    activateGC_ObjectJc(newObj1_3, null, _thCxt);
    activateGC_ObjectJc(newObj1_4, null, _thCxt);
  }
  { 
    ObjectJc *newObj2_1=null; /*J2C: temporary Objects for new operations
    */
    SETREFJc(thiz->buffer, ctorO_I_StringBuilderJc(/*J2C:static method call*/(newObj2_1 = alloc_ObjectJc(sizeof_StringBuilderJc, 0, _thCxt)), length, _thCxt), StringBuilderJc);
    CLEAR_REFJc(thiz->lineout);
    thiz->bShouldLineoutClose = false;
    activateGC_ObjectJc(newObj2_1, null, _thCxt);
  }
  STACKTRC_LEAVE;
  return thiz;
}



/*Constructor */
struct StringFormatterJc_t* ctorO_S_StringFormatterJc(ObjectJc* othis, StringJc str, ThCxt* _thCxt)
{ StringFormatterJc_s* thiz = (StringFormatterJc_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_StringFormatterJc");
  checkConsistence_ObjectJc(othis, sizeof(StringFormatterJc_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &reflection_StringFormatterJc_s, sizeof(StringFormatterJc_s));  
  //j2c: Initialize all class variables:
  {ObjectJc *newObj1_1=null, *newObj1_2=null, *newObj1_3=null, *newObj1_4=null; /*J2C: temporary Objects for new operations
      */
    thiz->secondNewline = '\0';
    thiz->pos = 0;
    thiz->bInsert = false;
    set_StringJc(&(thiz->sNewline), z_StringJc("\n"));
    thiz->cDecimalSeparator = '.';
    set_StringJc(&(thiz->sDatePrefixNewer), z_StringJc(""));
    SETREFJc(thiz->dateFormatNewer, ctorO_s_SimpleDateFormatJc(/*J2C:static method call*/(newObj1_1 = alloc_ObjectJc(sizeof_SimpleDateFormatJc_s, 0, _thCxt)), s0_StringJc("?yy-MM-dd HH:mm:ss"), _thCxt), SimpleDateFormatJc_s);
    set_StringJc(&(thiz->sDatePrefixToday), z_StringJc("today"));
    SETREFJc(thiz->dateFormatToday, ctorO_s_SimpleDateFormatJc(/*J2C:static method call*/(newObj1_2 = alloc_ObjectJc(sizeof_SimpleDateFormatJc_s, 0, _thCxt)), s0_StringJc(" HH:mm:ss"), _thCxt), SimpleDateFormatJc_s);
    set_StringJc(&(thiz->sDatePrefixYear), z_StringJc(""));
    SETREFJc(thiz->dateFormatYear, ctorO_s_SimpleDateFormatJc(/*J2C:static method call*/(newObj1_3 = alloc_ObjectJc(sizeof_SimpleDateFormatJc_s, 0, _thCxt)), s0_StringJc("MMM-dd HH:mm:ss"), _thCxt), SimpleDateFormatJc_s);
    set_StringJc(&(thiz->sDatePrefixOlder), z_StringJc(""));
    SETREFJc(thiz->dateFormatOlder, ctorO_s_SimpleDateFormatJc(/*J2C:static method call*/(newObj1_4 = alloc_ObjectJc(sizeof_SimpleDateFormatJc_s, 0, _thCxt)), s0_StringJc("yy-MM-dd HH:mm:ss"), _thCxt), SimpleDateFormatJc_s);
    activateGC_ObjectJc(newObj1_1, null, _thCxt);
    activateGC_ObjectJc(newObj1_2, null, _thCxt);
    activateGC_ObjectJc(newObj1_3, null, _thCxt);
    activateGC_ObjectJc(newObj1_4, null, _thCxt);
  }
  { 
    ObjectJc *newObj2_1=null; /*J2C: temporary Objects for new operations
    */
    SETREFJc(thiz->buffer, ctorO_s_StringBuilderJc(/*J2C:static method call*/(newObj2_1 = alloc_ObjectJc(sizeof_StringBuilderJc, 0, _thCxt)), str, _thCxt), StringBuilderJc);
    CLEAR_REFJc(thiz->lineout);
    thiz->bShouldLineoutClose = false;
    activateGC_ObjectJc(newObj2_1, null, _thCxt);
  }
  STACKTRC_LEAVE;
  return thiz;
}



/*Constructor */
struct StringFormatterJc_t* ctorO_Sb_StringFormatterJc(ObjectJc* othis, struct StringBuilderJc_t* buffer, ThCxt* _thCxt)
{ StringFormatterJc_s* thiz = (StringFormatterJc_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_StringFormatterJc");
  checkConsistence_ObjectJc(othis, sizeof(StringFormatterJc_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &reflection_StringFormatterJc_s, sizeof(StringFormatterJc_s));  
  //j2c: Initialize all class variables:
  {ObjectJc *newObj1_1=null, *newObj1_2=null, *newObj1_3=null, *newObj1_4=null; /*J2C: temporary Objects for new operations
      */
    thiz->secondNewline = '\0';
    thiz->pos = 0;
    thiz->bInsert = false;
    set_StringJc(&(thiz->sNewline), z_StringJc("\n"));
    thiz->cDecimalSeparator = '.';
    set_StringJc(&(thiz->sDatePrefixNewer), z_StringJc(""));
    SETREFJc(thiz->dateFormatNewer, ctorO_s_SimpleDateFormatJc(/*J2C:static method call*/(newObj1_1 = alloc_ObjectJc(sizeof_SimpleDateFormatJc_s, 0, _thCxt)), s0_StringJc("?yy-MM-dd HH:mm:ss"), _thCxt), SimpleDateFormatJc_s);
    set_StringJc(&(thiz->sDatePrefixToday), z_StringJc("today"));
    SETREFJc(thiz->dateFormatToday, ctorO_s_SimpleDateFormatJc(/*J2C:static method call*/(newObj1_2 = alloc_ObjectJc(sizeof_SimpleDateFormatJc_s, 0, _thCxt)), s0_StringJc(" HH:mm:ss"), _thCxt), SimpleDateFormatJc_s);
    set_StringJc(&(thiz->sDatePrefixYear), z_StringJc(""));
    SETREFJc(thiz->dateFormatYear, ctorO_s_SimpleDateFormatJc(/*J2C:static method call*/(newObj1_3 = alloc_ObjectJc(sizeof_SimpleDateFormatJc_s, 0, _thCxt)), s0_StringJc("MMM-dd HH:mm:ss"), _thCxt), SimpleDateFormatJc_s);
    set_StringJc(&(thiz->sDatePrefixOlder), z_StringJc(""));
    SETREFJc(thiz->dateFormatOlder, ctorO_s_SimpleDateFormatJc(/*J2C:static method call*/(newObj1_4 = alloc_ObjectJc(sizeof_SimpleDateFormatJc_s, 0, _thCxt)), s0_StringJc("yy-MM-dd HH:mm:ss"), _thCxt), SimpleDateFormatJc_s);
    activateGC_ObjectJc(newObj1_1, null, _thCxt);
    activateGC_ObjectJc(newObj1_2, null, _thCxt);
    activateGC_ObjectJc(newObj1_3, null, _thCxt);
    activateGC_ObjectJc(newObj1_4, null, _thCxt);
  }
  { 
    
    SETREFJc(thiz->buffer, buffer, StringBuilderJc);
    CLEAR_REFJc(thiz->lineout);
    thiz->bShouldLineoutClose = false;
  }
  STACKTRC_LEAVE;
  return thiz;
}



/**Same as getContent, overwrites Object.toString().*/
StringJc toString_StringFormatterJc(ObjectJc* ithis, ThCxt* _thCxt)
{ StringFormatterJc_s* thiz = (StringFormatterJc_s*)ithis;
  
  STACKTRC_TENTRY("toString_StringFormatterJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return toString_StringBuilderJc(& ((*(REFJc  (thiz->buffer))).base/*J2C_super:*/.object)/*J2cT1*/, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Gets the accumulated content.*/
StringJc getContent_StringFormatterJc(StringFormatterJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getContent_StringFormatterJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return toString_StringBuilderJc(& ((*(REFJc  (thiz->buffer))).base/*J2C_super:*/.object)/*J2cT1*/, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Gets the accumulated content.*/
CharSeqJc getBuffer_StringFormatterJc(StringFormatterJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getBuffer_StringFormatterJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return fromStringBuilderJc_CharSeqJc(REFJc (thiz->buffer));
    }
  }
  STACKTRC_LEAVE;
}


/**Sets an deviant decimal separator for floating point digigs, country-specific. */
void setDecimalSeparator_StringFormatterJc(StringFormatterJc_s* thiz, char sep, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setDecimalSeparator_StringFormatterJc");
  
  { 
    
    thiz->cDecimalSeparator = sep;
  }
  STACKTRC_LEAVE;
}


/**Resets the internal buffer*/
struct StringFormatterJc_t* reset_StringFormatterJc(StringFormatterJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("reset_StringFormatterJc");
  
  { 
    
    thiz->pos = 0;
    setLength_StringBuilderJc(REFJc (thiz->buffer), thiz->pos, _thCxt);
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the current position to the end of the string. */
struct StringFormatterJc_t* end_StringFormatterJc(StringFormatterJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("end_StringFormatterJc");
  
  { 
    
    thiz->pos = length_StringBuilderJc(REFJc (thiz->buffer));
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the current write position to the given position. */
struct StringFormatterJc_t* pos_i_StringFormatterJc(StringFormatterJc_s* thiz, int32 newPos, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("pos_i_StringFormatterJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return pos_ii_StringFormatterJc(thiz, newPos, -1, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the current write position to the given position.*/
struct StringFormatterJc_t* pos_ii_StringFormatterJc(StringFormatterJc_s* thiz, int32 newPos, int32 minChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("pos_ii_StringFormatterJc");
  
  { 
    
    if(newPos < 0) { throw_s0Jc(ident_IndexOutOfBoundsExceptionJc, "negative position not supported", 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
    if(minChars >= 0 && thiz->pos + minChars > newPos) 
    { 
      
      thiz->pos += minChars;
    }
    else 
    { 
      
      thiz->pos = newPos;
    }
    
    int32  pos1 = length_StringBuilderJc(REFJc (thiz->buffer));
    
    while(pos1 < thiz->pos)
      { 
        
        append_C_StringBuilderJc(REFJc (thiz->buffer), ' ', _thCxt);
        pos1 += 1;
      }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**returns the current length of string. */
int32 length_StringFormatterJc(StringFormatterJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("length_StringFormatterJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return length_StringBuilderJc(REFJc (thiz->buffer));
    }
  }
  STACKTRC_LEAVE;
}


/**returns the current position for add in buffer.*/
int32 getPos_StringFormatterJc(StringFormatterJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getPos_StringFormatterJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->pos;
    }
  }
  STACKTRC_LEAVE;
}


/**Adds at the current position a string.*/
struct StringFormatterJc_t* add_Cs_StringFormatterJc(StringFormatterJc_s* thiz, CharSeqJc str, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("add_Cs_StringFormatterJc");
  
  { 
    
    
    int32  nrofChars = length_CharSeqJc(str/*J1cT2*/, _thCxt);
    prepareBufferPos_StringFormatterJc(thiz, nrofChars, _thCxt);
    delete_StringBuilderJc(REFJc (thiz->buffer), thiz->pos, thiz->pos + nrofChars, _thCxt);
    insert_cYii_StringBuilderJc(REFJc (thiz->buffer), thiz->pos, str, 0, nrofChars, _thCxt);
    thiz->pos += nrofChars;
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Adds at the current position a string.*/
struct StringFormatterJc_t* add_S_StringFormatterJc(StringFormatterJc_s* thiz, StringJc str, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("add_S_StringFormatterJc");
  
  { 
    
    
    int32  nrofChars = length_StringJc(str);
    prepareBufferPos_StringFormatterJc(thiz, nrofChars, _thCxt);
    delete_StringBuilderJc(REFJc (thiz->buffer), thiz->pos, thiz->pos + nrofChars, _thCxt);
    insert_sII_StringBuilderJc(REFJc (thiz->buffer), thiz->pos, str.c, 0, nrofChars, _thCxt);/*buffer.replace(this.pos, pos + nrofChars, str);*/
    
    thiz->pos += nrofChars;
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Adds the given str at the current position but replaces line feed characters by given one.*/
struct StringFormatterJc_t* addReplaceLinefeed_StringFormatterJc(StringFormatterJc_s* thiz, CharSeqJc str, CharSeqJc replaceLinefeed, int32 maxChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addReplaceLinefeed_StringFormatterJc");
  
  { 
    
    if(maxChars > length_CharSeqJc(str/*J1cT2*/, _thCxt)) 
    { 
      
      maxChars = length_CharSeqJc(str/*J1cT2*/, _thCxt);
    }
    if(length_CharSeqJc(replaceLinefeed/*J1cT2*/, _thCxt) < 4) { throw_s0Jc(ident_IllegalArgumentExceptionJc, "The argument replaceLinefeed should have 4 characters.", 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
    prepareBufferPos_StringFormatterJc(thiz, maxChars, _thCxt);
    
    int32  postr = -1;
    
    while(--maxChars >= 0)
      { 
        
        
        char  cc = charAt_CharSeqJc(str/*J1cT2*/, ++postr, _thCxt);
        
        int32  replace1;/*no initvalue*/
        replace1 = indexOf_C_StringJc(zI_StringJc("\n\r\f",3), cc);/*NOTE: smallbug in Java2C*/
        
        if(replace1 >= 0) 
        { 
          
          cc = charAt_CharSeqJc(replaceLinefeed/*J1cT2*/, replace1, _thCxt);
        }
        if(cc <= 0x20) 
        { 
          
          cc = charAt_CharSeqJc(replaceLinefeed/*J1cT2*/, 3, _thCxt);
        }
        setCharAt_StringBuilderJc(REFJc (thiz->buffer), thiz->pos++, cc, _thCxt);
      }/*buffer.replace(this.pos, pos + nrofChars, str);*/
      /*pos += nrofChars;*/
    
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}

struct StringFormatterJc_t* add_c_StringFormatterJc(StringFormatterJc_s* thiz, char ch, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("add_c_StringFormatterJc");
  
  { 
    
    prepareBufferPos_StringFormatterJc(thiz, 1, _thCxt);
    setCharAt_StringBuilderJc(REFJc (thiz->buffer), thiz->pos++, ch, _thCxt);
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Adds at the current position a char[].*/
struct StringFormatterJc_t* add_cY_StringFormatterJc(StringFormatterJc_s* thiz, char_Y* str, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("add_cY_StringFormatterJc");
  
  { 
    
    
    int32  nrofChars = str->head.length;
    
    while(nrofChars > 1 && str->data[nrofChars - 1] == 0)
      { 
        
        nrofChars -= 1;
      }
    prepareBufferPos_StringFormatterJc(thiz, nrofChars, _thCxt);
    { int32 ii; 
      for(ii = 0; ii < nrofChars; ii++)
        { 
          
          setCharAt_StringBuilderJc(REFJc (thiz->buffer), thiz->pos, str->data[ii], _thCxt);
          thiz->pos += 1;
        }
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Inserts a String at current position with shifting the actual content to right.*/
struct StringFormatterJc_t* insert_S_StringFormatterJc(StringFormatterJc_s* thiz, StringJc str, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("insert_S_StringFormatterJc");
  
  { 
    
    insert_s_StringBuilderJc(REFJc (thiz->buffer), thiz->pos, str.c, _thCxt);
    thiz->pos += length_StringJc(str);
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**sets the overwrite mode. It is the default. In this mode add will overwrite the current content. */
struct StringFormatterJc_t* overwrite_StringFormatterJc(StringFormatterJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("overwrite_StringFormatterJc");
  
  { 
    
    thiz->bInsert = false;
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**sets the insert mode. In this mode add will shift the content at pos to right. */
struct StringFormatterJc_t* insert_StringFormatterJc(StringFormatterJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("insert_StringFormatterJc");
  
  { 
    
    thiz->bInsert = true;
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**sets the insert or overwrite mode, returns the current mode before change.*/
bool setInsertMode_StringFormatterJc(StringFormatterJc_s* thiz, bool insert, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setInsertMode_StringFormatterJc");
  
  { 
    
    
    bool  bInsertRet = thiz->bInsert;
    thiz->bInsert = insert;
    { STACKTRC_LEAVE;
      return bInsertRet;
    }
  }
  STACKTRC_LEAVE;
}


/**Adds a line of ascii representation of bytes*/
struct StringFormatterJc_t* addStringLine_StringFormatterJc(StringFormatterJc_s* thiz, int8_Y* data, int32 idx, int32 nrofBytes, StringJc charsetName, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addStringLine_StringFormatterJc");
  
  { /*:to convert bytes with a given charset, but show bytes < 0x20 with '.', copy it in a independend buffer:*/
    
    ObjectJc *newObj2_1=null; /*J2C: temporary Objects for new operations
    */
    if(nrofBytes > data->head.length) 
    { 
      
      nrofBytes = data->head.length;
    }
    
    int8_Y*  data1 = (int8_Y*)ctorO_ObjectArrayJc((newObj2_1 = alloc_ObjectJc( sizeof(ObjectArrayJc) + (nrofBytes) * sizeof(int8), mIsLargeSize_objectIdentSize_ObjectJc, _thCxt)), nrofBytes, sizeof(int8),REFLECTION_int8, 0);
    arraycopy_SystemJc(/*J2C:static method call*/& ((data)->head.object), idx, & ((data1)->head.object), 0, nrofBytes, _thCxt);
    { int32 ii; 
      for(ii = 0; ii < nrofBytes; ii++)
        { 
          
          if(data1->data[ii] < 0x20) 
          { 
            
            data1->data[ii] = (int8 /*J2C_cast*/)('.');
          }/*write insteads control chars.*/
          
        }
    }
    
    StringJc str ; str;/*no initvalue*/
    TRY
    { 
      
      str = new_BYIICharset_StringJc(/*J2C:static method call*/data1, 0, nrofBytes, charsetName, _thCxt)/*J2C:non-persistent*/;
    }_TRY
    CATCH(UnsupportedEncodingException, exc)
    
      { 
        
        str = z_StringJc("??encoding error??")/*J2C:non-persistent*/;
      }
    END_TRY/*not replace in buffer:*/
    
    
    int32  strLength = length_StringJc(str);
    prepareBufferPos_StringFormatterJc(thiz, strLength, _thCxt);
    replace_StringBuilderJc(REFJc (thiz->buffer), thiz->pos, thiz->pos + strLength, str.c, _thCxt);
    thiz->pos += strLength;
    { STACKTRC_LEAVE;
      activateGC_ObjectJc(newObj2_1, null, _thCxt);
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Adds at the current position a line of hex numbers.*/
struct StringFormatterJc_t* addHexLine_StringFormatterJc(StringFormatterJc_s* thiz, int8_Y* data, int32 idx, int32 nrofBytes, int16 mode, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addHexLine_StringFormatterJc");
  
  { 
    
    
    int32  nrofBytesInWord = mode & mNrofBytesInWord_StringFormatterJc;
    
    int32  nrofWords = nrofBytes / nrofBytesInWord;
    prepareBufferPos_StringFormatterJc(thiz, 2 * nrofBytes + nrofWords, _thCxt);
    
    int32  nrofBytes1 = nrofBytes;
    
    int32  idx1 = idx;
    
    while(nrofBytes1 > 0)
      { 
        
        if(nrofBytes1 < nrofBytesInWord) 
        { /*:the last hex word is smaller as given in mode:*/
          
          
          addHexWord__StringFormatterJc(thiz, data, idx1, (int16 /*J2C_cast*/)((mode & mBytesInWordBigEndian_StringFormatterJc) + nrofBytes1), _thCxt);
          nrofBytes1 = 0;
        }
        else 
        { /*:normal operation*/
          
          
          addHexWord__StringFormatterJc(thiz, data, idx1, mode, _thCxt);
          setCharAt_StringBuilderJc(REFJc (thiz->buffer), thiz->pos++, ' ', _thCxt);
          nrofBytes1 -= nrofBytesInWord;
          idx1 += nrofBytesInWord;
        }
      }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Adds a hexa line with left address and ascii*/
struct StringFormatterJc_t* addHexWord_StringFormatterJc(StringFormatterJc_s* thiz, int8_Y* data, int32 idx, int16 mode, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addHexWord_StringFormatterJc");
  
  { 
    
    prepareBufferPos_StringFormatterJc(thiz, 2 * (mode & mNrofBytesInWord_StringFormatterJc), _thCxt);
    { STACKTRC_LEAVE;
      return addHexWord__StringFormatterJc(thiz, data, idx, mode, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Adds a number as one word readed from data in hexa form, internal routine without prepareBufferPos*/
struct StringFormatterJc_t* addHexWord__StringFormatterJc(StringFormatterJc_s* thiz, int8_Y* data, int32 idx, int16 mode, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addHexWord__StringFormatterJc");
  
  { 
    
    
    int32  nrofBytesInWord = mode & mNrofBytesInWord_StringFormatterJc;
    
    int32  incrIdx;/*no initvalue*/
    if((mode & mBytesInWordBigEndian_StringFormatterJc) != 0) 
    { 
      
      incrIdx = 1;
    }
    else 
    { 
      
      incrIdx = -1;
      idx += nrofBytesInWord - 1;
    }
    
    while(--nrofBytesInWord >= 0 && idx < data->head.length)
      { 
        
        
        int8  value = data->data[idx];
        idx += incrIdx;/*TRICKY may be 1 or -1 dependend on BigEndian*/
        
        { int32 i; 
          for(i = 0; i < 2; i++)
            { 
              
              
              char  digit = (char /*J2C_cast*/)(((value & 0xf0) >> 4) + (int8 /*J2C_cast*/)('0'));
              if(digit > '9') 
              { 
                
                digit = (char /*J2C_cast*/)(digit + (int8 /*J2C_cast*/)('a') - (int8 /*J2C_cast*/)('9') - 1);
              }
              setCharAt_StringBuilderJc(REFJc (thiz->buffer), thiz->pos++, digit, _thCxt);
              value <<= 4;
            }
        }
      }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Adds a number containing in a long variable in hexa form*/
struct StringFormatterJc_t* addHex_StringFormatterJc(StringFormatterJc_s* thiz, int64 value, int32 nrofDigits, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addHex_StringFormatterJc");
  
  { 
    
    prepareBufferPos_StringFormatterJc(thiz, nrofDigits, _thCxt);
    
    { /*:show last significant byte at right position, like normal variable or register look*/
      
      
      
      int32  nrofShift = (nrofDigits * 4) - 4;
      { int32 ii; 
        for(ii = 0; ii < nrofDigits; ii++)
          { 
            
            
            char  digit = (char /*J2C_cast*/)(((value >> nrofShift) & 0xf) + (int8 /*J2C_cast*/)('0'));
            if(digit > '9') 
            { 
              
              digit = (char /*J2C_cast*/)(digit + (int8 /*J2C_cast*/)('a') - (int8 /*J2C_cast*/)('9') - 1);
            }
            setCharAt_StringBuilderJc(REFJc (thiz->buffer), thiz->pos++, digit, _thCxt);
            nrofShift -= 4;
          }
      }
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Adds a number containing in a long variable in hexa form*/
struct StringFormatterJc_t* addBinary_StringFormatterJc(StringFormatterJc_s* thiz, int32 value, StringJc sPicture, StringJc sBitCharLo, StringJc sBitCharHi, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addBinary_StringFormatterJc");
  
  { 
    
    
    int32  nrofDigits = 0;
    { int32 ii; 
      for(ii = 0; ii < length_StringJc(sPicture); ii++)
        { 
          
          if(charAt_StringJc(sPicture, ii) == '1') 
          { 
            
            nrofDigits += 1;
          }
        }
    }
    
    int32  mask = 1 << (nrofDigits - 1);
    prepareBufferPos_StringFormatterJc(thiz, length_StringJc(sPicture), _thCxt);
    { int32 ii; 
      for(ii = 0; ii < length_StringJc(sPicture); ii++)
        { 
          
          
          char  cBitPos = charAt_StringJc(sPicture, ii);
          if(cBitPos == '1') 
          { 
            
            
            int32  bit = value & mask;
            
            char  cc = bit != 0 ? charAt_StringJc(sBitCharHi, ii) : charAt_StringJc(sBitCharLo, ii);
            setCharAt_StringBuilderJc(REFJc (thiz->buffer), thiz->pos++, cc, _thCxt);
            mask = (mask >> 1) & 0x7fffffff;
          }
          else 
          { 
            
            setCharAt_StringBuilderJc(REFJc (thiz->buffer), thiz->pos++, cBitPos, _thCxt);
          }
        }
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**ensures, that the space in buffer started on pos is writeable with setCharAt.*/
void prepareBufferPos_StringFormatterJc(StringFormatterJc_s* thiz, int32 nrofChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("prepareBufferPos_StringFormatterJc");
  
  { /*:if(true || bInsert)*/
    
    
    if(thiz->bInsert && thiz->pos < length_StringBuilderJc(REFJc (thiz->buffer))) 
    { 
      
      
      while(nrofChars > 0)
        { 
          
          if(nrofChars >= length_StringJc(spaces_StringFormatterJc)) 
          { 
            
            insert_s_StringBuilderJc(REFJc (thiz->buffer), thiz->pos, spaces_StringFormatterJc.c, _thCxt);
            nrofChars -= length_StringJc(spaces_StringFormatterJc);
          }
          else 
          { 
            
            insert_sII_StringBuilderJc(REFJc (thiz->buffer), thiz->pos, spaces_StringFormatterJc.c, 0, nrofChars, _thCxt);
            nrofChars = 0;
          }
        }/*buffer.insert(pos, spaces, 0, nrofChars);*/
        
    }
    else 
    { 
      
      
      int32  nrofCharsToEnd = length_StringBuilderJc(REFJc (thiz->buffer)) - thiz->pos;
      ASSERT(/*J2C:static method call*/nrofCharsToEnd >= 0);
      nrofChars -= nrofCharsToEnd;/*nrofChars may be < 0 if the range of overwrite is inside the exiting string.*/
      
      
      while(nrofChars > 0)
        { /*:appends necessary space on end. the format methods overwrites this space.*/
          
          
          if(nrofChars >= length_StringJc(spaces_StringFormatterJc)) 
          { 
            
            append_c_StringBuilderJc(REFJc (thiz->buffer), spaces_StringFormatterJc.c, _thCxt);
            nrofChars -= length_StringJc(spaces_StringFormatterJc);
          }
          else 
          { 
            
            append_sII_StringBuilderJc(REFJc (thiz->buffer), spaces_StringFormatterJc.c, 0, nrofChars, _thCxt);
            nrofChars = 0;
          }
        }
    }
  }
  STACKTRC_LEAVE;
}


/**Adds a number in form 12ab'cd34, it is typical to show 4-byte-values at example addresses.*/
struct StringFormatterJc_t* addHex44_StringFormatterJc(StringFormatterJc_s* thiz, int64 value, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addHex44_StringFormatterJc");
  
  { 
    
    addHex_StringFormatterJc(thiz, (value >> 16) & 0xffff, 4, _thCxt);
    insert_C_StringBuilderJc(REFJc (thiz->buffer), thiz->pos++, '\'', _thCxt);
    addHex_StringFormatterJc(thiz, (value) & 0xffff, 4, _thCxt);
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**adds a double value in a fix point representation without exponent.*/
struct StringFormatterJc_t* addFloat_StringFormatterJc(StringFormatterJc_s* thiz, double value, int32 digitsBeforePoint, int32 digitsAfterPoint, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addFloat_StringFormatterJc");
  
  { 
    
    
    int32  nrofCharsInPicture = digitsBeforePoint + digitsAfterPoint + 2;
    prepareBufferPos_StringFormatterJc(thiz, nrofCharsInPicture, _thCxt);
    if(value < 0) 
    { 
      
      setCharAt_StringBuilderJc(REFJc (thiz->buffer), thiz->pos++, '-', _thCxt);
      value = -value;
    }
    else 
    { 
      
      setCharAt_StringBuilderJc(REFJc (thiz->buffer), thiz->pos++, ' ', _thCxt);
    }
    
    StringJc sValue ; sValue = toString_DoubleJc(/*J2C:static method call*/value, _thCxt)/*J2C:non-persistent*/;
    
    int32  posPointInValue = indexOf_C_StringJc(sValue, '.');
    if(thiz->cDecimalSeparator != '.') 
    { 
      
      sValue = replace_StringJc(sValue, '.', thiz->cDecimalSeparator, _thCxt)/*J2C:non-persistent*/;
    }/*int posPoint = pos + digitsBeforePoint;*/
    
    
    int32  nrofSpacesBefore = digitsBeforePoint - posPointInValue;
    
    int32  nrofZeroAfter = digitsAfterPoint - (length_StringJc(sValue) - posPointInValue - 1);
    if(nrofZeroAfter < 0) 
    { 
      
      nrofZeroAfter = 0;
    }
    
    int32  nrofValueChars = digitsBeforePoint - nrofSpacesBefore + 1 + digitsAfterPoint - nrofZeroAfter;
    
    while(nrofSpacesBefore > 0)
      { 
        
        setCharAt_StringBuilderJc(REFJc (thiz->buffer), thiz->pos++, ' ', _thCxt);
        nrofSpacesBefore -= 1;
      }/*int digitsAfterPointInValue =sValue.length() - posPointInValue -1;*/
      /*if(digitsAfterPointInValue > digitsAfterPoint){ digitsAfterPointInValue = digitsAfterPoint;}*/
    
    if(nrofSpacesBefore < 0) 
    { /*:the number of digits is to large,*/
      
      
      nrofValueChars = nrofValueChars - (-nrofSpacesBefore) - 2;/*crash situation: write only the beginn of the digit*/
      
      replace_StringBuilderJc(REFJc (thiz->buffer), thiz->pos, thiz->pos + 2, z_StringJc("##").c, _thCxt);
      thiz->pos += 2;
    }
    replace_StringBuilderJc(REFJc (thiz->buffer), thiz->pos, thiz->pos + nrofValueChars, substring_StringJc(sValue, 0, nrofValueChars, _thCxt).c, _thCxt);
    thiz->pos += nrofValueChars;
    
    while(--nrofZeroAfter >= 0)
      { 
        
        setCharAt_StringBuilderJc(REFJc (thiz->buffer), thiz->pos++, '0', _thCxt);
      }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Adds a line with representation of byte content in a fixed nice format.*/
StringJc addHexLn_StringFormatterJc(/*J2C:static method*/ int8_Y* data, int32 length, int32 idxStart, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addHexLn_StringFormatterJc");
  
  { 
    ObjectJc *newObj2_1=null; /*J2C: temporary Objects for new operations
    */
    
    int32  idx = idxStart;
    
    struct StringFormatterJc_t*  buffer = ctorO_StringFormatterJc(/*J2C:static method call*/(newObj2_1 = alloc_ObjectJc(sizeof_StringFormatterJc_s, 0, _thCxt)), _thCxt);
    
    StringJc strRet ; strRet = z_StringJc("")/*J2C:non-persistent*/;
    
    while(idx < (idxStart + length))
      { 
         //J2C: temporary Stringbuffer for String concatenation
        StringBuilderJc* _tempString3_1=null; 
        
        
        int32  idxLineEnd = idx + 32;
        if(idxLineEnd > length) 
        { 
          
          idxLineEnd = idxStart + length;
        }
        addHexLine_StringFormatterJc(buffer, data, idx, idxLineEnd - idx, k4right_StringFormatterJc, _thCxt);
        add_Cs_StringFormatterJc(buffer, z_StringJc(" ").c, _thCxt);
        addStringLine_StringFormatterJc(buffer, data, idx, idxLineEnd - idx, s0_StringJc("ISO-8859-1"), _thCxt);
        strRet = 
        ( _tempString3_1 = new_StringBuilderJc(-1, _thCxt)
        , setStringConcatBuffer_StringBuilderJc(_tempString3_1)
        , append_s_StringBuilderJc(_tempString3_1, strRet.c, _thCxt)
        , append_s_StringBuilderJc(_tempString3_1, getContent_StringFormatterJc(buffer, _thCxt).c, _thCxt)
        , append_z_StringBuilderJc(_tempString3_1, "\n", _thCxt)
        , toString_StringBuilderJc(&(_tempString3_1)->base.object, _thCxt)
        )/*J2C:non-persistent*/;
        reset_StringFormatterJc(buffer, _thCxt);
        idx = idxLineEnd;
        activateGC_ObjectJc(&_tempString3_1->base.object, null, _thCxt);
      }
    { STACKTRC_LEAVE;
      activateGC_ObjectJc(newObj2_1, PTR_StringJc(strRet), _thCxt);
      return strRet;
    }
  }
  STACKTRC_LEAVE;
}

struct StringFormatterJc_t* addDate_StringFormatterJc(StringFormatterJc_s* thiz, struct DateJc_t* date, struct SimpleDateFormatJc_t* format, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addDate_StringFormatterJc");
  
  { 
    StringJc _persistring2_1=NULL_StringJc; //J2C: temporary persistent Strings
    
    
    StringJc sDate ; sDate = _persistring2_1 = persist_StringJc(format_SimpleDateFormatJc(format, (date)->val, _thCxt))/*J2C:non-persistent*/;
    add_S_StringFormatterJc(thiz, sDate, _thCxt);
    { STACKTRC_LEAVE;
      activateGC_ObjectJc(PTR_StringJc(_persistring2_1), null, _thCxt);
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}

struct StringFormatterJc_t* setAt_StringFormatterJc(StringFormatterJc_s* thiz, int32 pos, char ch, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setAt_StringFormatterJc");
  
  { 
    
    setCharAt_StringBuilderJc(REFJc (thiz->buffer), pos, ch, _thCxt);
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets a integer value at current position, use the picture to determine the number of characters etc.*/
struct StringFormatterJc_t* addint_StringFormatterJc(StringFormatterJc_s* thiz, int64 nr, StringJc sPict, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addint_StringFormatterJc");
  
  { 
    
    strPicture_StringFormatterJc(thiz, nr, sPict, s0_StringJc("+-.."), '.', _thCxt);
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/***/
struct StringFormatterJc_t* addIntPicture_StringFormatterJc(StringFormatterJc_s* thiz, int64 nr, StringJc sPict, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addIntPicture_StringFormatterJc");
  
  { 
    
    strPicture_StringFormatterJc(thiz, nr, sPict, s0_StringJc("+-.."), '.', _thCxt);
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**This algorithm is taken over from C++ routines in strpict.cpp written by JcHartmut in 1993..1999.*/
bool strPicture_StringFormatterJc(StringFormatterJc_s* thiz, int64 src, StringJc pict, StringJc posNegPointExp, char cFracSep, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("strPicture_StringFormatterJc");
  
  { 
    
    
    int32  n10i;/*no initvalue*/
    
    bool  bNeg = false;
    
    int32  nrofCharForSign;/*no initvalue*/
    
    int32  nrofCharsForSignUnused = 0;
    
    bool  bLeftZeroSuppress = false;
    
    int32  posSignInPicture = indexOfAnyChar_StringFunctionsJc(/*J2C:static method call*/pict.c, 0, MAX_VALUE_IntegerJc, sNeg_StringFormatterJc.c, _thCxt);
    
    ;/*positChar(pict,pict.length(),sNeg,strlen(sNeg));*/
    
    if(posSignInPicture >= 0) 
    { 
      
      if(src < 0) 
      { 
        
        bNeg = true;
        src = -src;/*Zahl negieren*/
        
        nrofCharForSign = 1;
      }
      else 
      { 
        
        if(charAt_StringJc(pict, posSignInPicture) != '-') 
        { 
          
          nrofCharForSign = 1;/*displays the sign always.*/
          
        }
        else 
        { 
          
          nrofCharForSign = 0;/*don't display a sign.*/
          
          nrofCharsForSignUnused = 0;
        }
      }
    }
    else if(src < 0) 
    { 
      StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
      
      { throw_sJc(ident_IllegalArgumentExceptionJc, 
        ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
        , append_z_StringBuilderJc(_stringBuilderThCxt, "value should be only positive: ", _thCxt)
        , append_J_StringBuilderJc(_stringBuilderThCxt, src, _thCxt)
        , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
        ), 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
    }/*if the number is negativ but a sign is not expected, the number will be shown as positiv value.*/
    /**/
    /*----------------------------------------------------------------------*/
    
    for(n10i = ARRAYLEN_SimpleC(n10a_StringFormatterJc) - 1; n10i >= 0; n10i--)
      { /*:meistens sind es kleine Zahlen, im Mittel geht es also schneller*/
        /*:wenn von Hinten aus getestet wird ob die Zahl groesser ist,*/
        /*:damit weniger Schleifendurchlauefe:*/
        
        
        if(src < n10a_StringFormatterJc[n10i]) break;
      }/*n10[n10i] ist die Zahl, die um eine Stelle groeser ist.*/
      
    n10i += 1;/*damit ist n10[n10i] die als erste kleinere Zahl.*/
    
    
    int32  nDigits = ARRAYLEN_SimpleC(n10a_StringFormatterJc) - n10i + 1;
    
    int32  nrofChars = length_StringJc(pict);
    
    int32  ii = nrofChars;
    
    int32  n0Digit = 0;
    
    int32  n1Digit = 0;
    
    int32  n2Digit = 0;
    
    int32  n3Digit = 0;
    
    while(ii > 0)
      { 
        
        
        char  cp = charAt_StringJc(pict, --ii);
        if(cp <= '2' && cp >= '0') 
        { 
          
          n2Digit += 1;/*210 in Picture: Soll-Platz fuer Digits*/
          
          n3Digit += 1;
          if(cp == '0') 
          { 
            
            n0Digit += 1;
            n1Digit = n2Digit;
          }/*mdst. Stelle auszuschreiben*/
          
          else if(cp == '1') n1Digit = n2Digit;
        }
        else if(cp <= '9' && cp >= '3') 
        { 
          
          n3Digit += 1;
        }
      }
    
    bool  bOvf;/*no initvalue*/
    if(nDigits > n3Digit) 
    { /*:Zahl ist nicht darstellbar: stattdessen 99999 darstellen*/
      
      
      bOvf = true;/*n3Digit=0;*/
      
      n2Digit = n3Digit;
    }
    else 
    { 
      
      bOvf = false;
      if(nDigits > n2Digit) n2Digit = nDigits;/*Anzahl auszugeb. Digits oder Leerstellen*/
      
    }
    prepareBufferPos_StringFormatterJc(thiz, nrofChars - (n3Digit - n2Digit) - nrofCharsForSignUnused, _thCxt);
    
    char  cp;/*no initvalue*/
    ii = 0;
    for(ii = 0; ii < nrofChars; ii++)
      { 
        
        cp = charAt_StringJc(pict, ii);
        
        char  cc;/*no initvalue*/
        
        int32  ixPosNegPointExp;/*no initvalue*/
        if(cp >= '0' && cp <= '9') 
        { 
          
          if(--n3Digit >= n2Digit) cc = ((char)(0));/*keine Ausgabe weil nicht notwendige fuehr. Stellen*/
          
          else 
          { /*:Ausgabe aufgrund n2Digit notwendig*/
            
            
            if(n2Digit > nDigits) 
            { /*:Anzahl auszuschreib. Stellen groesser als Zahl:*/
              
              
              if(n1Digit >= n2Digit) cc = '0';/*fuerende Null*/
              
              else cc = ' ';
            }
            else 
            { /*:Ziffer bestimmen:*/
              
              
              n1Digit = 0;/*keine fuerenden 0 mehr notwendig*/
              
              if(bOvf) cc = '#';
              else if(src == 0) 
              { 
                
                if(n0Digit >= nDigits) cc = ((char)(0));/*nichts ausgeben bei weglassbaren nachfolg. 0*/
                
                else cc = '0';
              }
              else if(n10i >= ARRAYLEN_SimpleC(n10a_StringFormatterJc)) 
              { 
                
                cc = (char /*J2C_cast*/)(src + '0');/*das ist die Einerstelle*/
                
              }
              else 
              { 
                
                
                int64  src10 = n10a_StringFormatterJc[n10i];
                n10i += 1;/*Dezimalstelle gehoert dazu*/
                
                cc = '0';
                
                while(src >= src10)
                  { 
                    
                    cc += (char /*J2C_cast*/)(1);
                    src -= src10;
                  }/*in Schleife subtr. statt Divis.*/
                  
              }
              nDigits -= 1;
            }
            n2Digit -= 1;
          }
        }
        else if((ixPosNegPointExp = /*? assignment*/indexOf_C_StringJc(posNegPointExp, cp)) >= 0) 
        { 
          
          /**Any control character found: */
          switch(ixPosNegPointExp){
            case 0: /**Any control character found: */
            cc = charAt_StringJc(posNegPointExp, bNeg ? 1 : 0);/**Any control character found: */
            break;/*positiv digit*/
            
            case 1: /**Any control character found: */
            
            { 
              
              /**Any control character found: */
              if(bNeg) /**Any control character found: */
              
              { /*:number is negativ, write a '-' always.*/
                
                
                /**Any control character found: */
                cc = cp;
              }
              else /**Any control character found: */
              
              { /*:number is positive:*/
                
                
                /**Any control character found: */
                if(bLeftZeroSuppress) /**Any control character found: */
                
                { 
                  
                  /**Any control character found: */
                  cc = ((char)(0));
                }/*write nothing if number is positiv and left zeros are suppressed.*/
                
                else /**Any control character found: */
                
                { 
                  
                  /**Any control character found: */
                  cc = ' ';
                }/*write blank if a negative sign is required in picture and the number is positive.*/
                
              }
            }/**Any control character found: */
            break;
            case 2: /**Any control character found: */
            cc = cFracSep;/**Any control character found: */
            break;/*show the given fractional separator if the control-char for fract. separator is found.*/
            
            case 3: /**Any control character found: */
            cc = cFracSep == '.' ? ' ' : cFracSep;/**Any control character found: */
            break;/*don't show if 10^0*/
            
            default: /**Any control character found: */
            { throw_s0Jc(ident_RuntimeExceptionJc, "unexpected case", 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
          }/*switch*/;
        }
        else 
        { 
          
          cc = cp;/*anderes Zeichen aus Picture uebertragen*/
          
        }
        if(cc != 0) 
        { /*:cc=0 means, the char shouls not be written.*/
          
          
          setCharAt_StringBuilderJc(REFJc (thiz->buffer), thiz->pos++, cc, _thCxt);
        }
      }/*for*/
      
    { STACKTRC_LEAVE;
      return (!bOvf);
    }
  }
  STACKTRC_LEAVE;
}


/**Writes a float value in technical representation with exponent as short char a..T*/
int32 addFloatPicture_StringFormatterJc(StringFormatterJc_s* thiz, float src, StringJc pict, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addFloatPicture_StringFormatterJc");
  
  { /*:Exponent der Zahl bestimmen:*/
    
    
    
    StringJc cFrac ; cFrac = z_StringJc("afpnum.kMGT")/*J2C:non-persistent*/;
    
    int32  nExp = indexOf_C_StringJc(cFrac, '.');
    
    int32  srcHex = floatToRawIntBits_FloatJc(/*J2C:static method call*/src);
    
    int8  nExpF = (int8 /*J2C_cast*/)((srcHex >> 24) & 0x7f);
    if(nExpF > (40 + 0x40)) src = 9.999999E17F;
    else if(nExpF < (0x40 - 40)) src = 0.0F;/*the 0 itself is a 0.*/
    /*unused(nExpF + *pSrcHex);*/
    
    
    bool  bNeg = (srcHex < 0);
    
    bool  bIsNull = (srcHex & 0x7f800000) == 0;
    
    int64  srcLong;/*no initvalue*/
    if(bNeg) src = -src;
    if(!bIsNull) 
    { 
      
      
      while(src >= 1000.0F && nExp < length_StringJc(cFrac) - 1)
        { 
          
          src = src / 1000.0F;
          nExp += 1;
        }
      
      while(src < 1.0F && nExp > 0)
        { 
          
          src = src * 1000.0F;
          nExp -= 1;
        }
      if(bNeg) src = -src;
      srcLong = (int64 /*J2C_cast*/)(src);
    }
    else 
    { 
      
      srcLong = 0;
    }
    strPicture_StringFormatterJc(thiz, srcLong, pict, s0_StringJc("+-.@"), charAt_StringJc(cFrac, nExp), _thCxt);
    { STACKTRC_LEAVE;
      return (length_StringJc(pict));
    }
  }
  STACKTRC_LEAVE;
}


/**It invokes {@link #append(char)} for any char.Therewith a \n and \r is handled specially.*/
struct StringFormatterJc_t* append_Cs_StringFormatterJc(StringFormatterJc_s* thiz, CharSeqJc csq, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("append_Cs_StringFormatterJc");
  
  { 
    
    append_Csii_StringFormatterJc(thiz, csq, 0, length_CharSeqJc(csq/*J1cT2*/, _thCxt), _thCxt);
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Appends one character and flushes a line on end-line character.*/
struct StringFormatterJc_t* append_c_StringFormatterJc(StringFormatterJc_s* thiz, char c, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("append_c_StringFormatterJc");
  
  { 
    
    
    AppendableJcMTB lineoutMtbl ; SETMTBJc(lineoutMtbl, REFJc (thiz->lineout), AppendableJc);
    if(thiz->lineout.ref!= null && (c == '\n' || c == '\r')) 
    { /*:on one of the line end characters*/
      
      
      if(c != thiz->secondNewline || thiz->pos > 0) 
      { /*:if a content is given or c is the first newline character.          // != '\r' ){   //bug: 0d0a0d0a creates only one line:  || c=='\r' && lastNewline != '\n'){*/
        
        
        flushLine_StringFormatterJc(thiz, thiz->sNewline, _thCxt);
        if(thiz->sNewline.c.ref== null) 
        { 
          
          /*J2Cxxtest*/
          lineoutMtbl.mtbl->append_C(&(( (lineoutMtbl.ref))->base.object), c, _thCxt);/*append the found newline character either 0d or 0a like given.*/
          
        }
        thiz->secondNewline = c == '\r' ? '\n' : '\r';/*the other one.*/
        
      }
      else if(thiz->sNewline.c.ref== null) 
      { /*:c is the secondNewline character, pos is 0*/
        
        
        lineoutMtbl.mtbl->append_C(&(( (lineoutMtbl.ref))->base.object), c, _thCxt);/*append it if a special newline is not given.*/
        
      }
    }
    else 
    { 
      
      add_c_StringFormatterJc(thiz, c, _thCxt);/*normal character, add it.*/
      
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**It invokes {@link #append(char)} for any char.Therewith a \n and \r is handled specially.*/
struct StringFormatterJc_t* append_Csii_StringFormatterJc(StringFormatterJc_s* thiz, CharSeqJc csq, int32 start, int32 end, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("append_Csii_StringFormatterJc");
  
  { 
    
    { int32 ii; 
      for(ii = start; ii < end; ++ii)
        { 
          
          
          char  cc = charAt_CharSeqJc(csq/*J1cT2*/, ii, _thCxt);
          append_c_StringFormatterJc(thiz, cc, _thCxt);
        }
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}

void flush_StringFormatterJc(StringFormatterJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("flush_StringFormatterJc");
  
  { 
    
    if(thiz->lineout.ref!= null) 
    { 
      
      append_cs_AppendableJc(&((REFJc (thiz->lineout))->base.object), fromStringBuilderJc_CharSeqJc(REFJc (thiz->buffer)), _thCxt);
      if( instanceof_ObjectJc(((/*J2C:cast from AppendableJc_s*/ObjectJc*)(REFJc (thiz->lineout))), &reflection_FlushableJc)) 
      { 
        
        flush_FlushableJc(&(((FlushableJc* /*J2C_cast*/)REFJc (thiz->lineout))->base.object), _thCxt);
      }
    }
    reset_StringFormatterJc(thiz, _thCxt);
  }
  STACKTRC_LEAVE;
}


/**Flushes the stored content in the lineout and adds the given sNewline*/
int32 flushLine_StringFormatterJc(StringFormatterJc_s* thiz, StringJc sNewline, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("flushLine_StringFormatterJc");
  
  { 
    
    
    AppendableJcMTB lineoutMtbl ; SETMTBJc(lineoutMtbl, REFJc (thiz->lineout), AppendableJc);
    
    int32  chars = thiz->pos;
    if(thiz->pos > 0) 
    { /*:some content is given*/
      
      
      lineoutMtbl.mtbl->append_csI(&(( (lineoutMtbl.ref))->base.object), fromStringBuilderJc_CharSeqJc(REFJc (thiz->buffer)), 0, thiz->pos, _thCxt);/*it would be copy characters after pos to 0. But that's wrong here:*/
      
      setLength_StringBuilderJc(REFJc (thiz->buffer), 0, _thCxt);/*clean*/
      
      thiz->pos = 0;
    }
    if(sNewline.c.ref!= null) 
    { 
      
      lineoutMtbl.mtbl->append_cs(&(( (lineoutMtbl.ref))->base.object), sNewline.c, _thCxt);
    }
    { STACKTRC_LEAVE;
      return chars;
    }
  }
  STACKTRC_LEAVE;
}

void close_StringFormatterJc(StringFormatterJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("close_StringFormatterJc");
  
  { 
    
    if(thiz->lineout.ref!= null) 
    { 
      
      append_cs_AppendableJc(&((REFJc (thiz->lineout))->base.object), fromStringBuilderJc_CharSeqJc(REFJc (thiz->buffer)), _thCxt);
      if(thiz->bShouldLineoutClose) 
      { 
        
        close_CloseableJc(&(((CloseableJc* /*J2C_cast*/)REFJc (thiz->lineout))->base.object), _thCxt);
        CLEAR_REFJc(thiz->lineout);
      }
    }
    reset_StringFormatterJc(thiz, _thCxt);
  }
  STACKTRC_LEAVE;
}


void finalize_StringFormatterJc_F(ObjectJc* othis, ThCxt* _thCxt)
{ StringFormatterJc_s* thiz = (StringFormatterJc_s*)othis;  //upcasting to the real class.
 STACKTRC_TENTRY("finalize_StringFormatterJc_F");
  CLEAR_REFJc(thiz->buffer);
  CLEAR_REFJc(thiz->lineout);
  CLEAR_REFJc(thiz->dateFormatNewer);
  CLEAR_REFJc(thiz->dateFormatToday);
  CLEAR_REFJc(thiz->dateFormatYear);
  CLEAR_REFJc(thiz->dateFormatOlder);
  finalize_ObjectJc_F(&thiz->base.object, _thCxt); //J2C: finalizing the superclass.
  STACKTRC_LEAVE;
}




/**J2C: Reflections and Method-table *************************************************/
const MtblDef_StringFormatterJc mtblStringFormatterJc = {
{ { sign_Mtbl_StringFormatterJc //J2C: Head of methodtable of StringFormatterJc
  , (struct Size_Mtbl_t*)((0 +2) * sizeof(void*)) //J2C:size. NOTE: all elements has the size of void*.
  }
  //J2C: The superclass's methodtable: 
, { { sign_Mtbl_ObjectJc //J2C: Head of methodtable of ObjectJc
    , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //J2C:size. NOTE: all elements has the size of void*.
    }
    //J2C: Dynamic methods of the class :ObjectJc:
  , clone_ObjectJc_F //clone
  , equals_ObjectJc_F //equals
  , finalize_StringFormatterJc_F //finalize
  , hashCode_ObjectJc_F //hashCode
  , toString_StringFormatterJc //toString
  }
  //J2C: The interface's methodtable: 
  //J2C: Mtbl-interfaces of :StringFormatterJc: */
, { { sign_Mtbl_AppendableJc //J2C: Head of methodtable of AppendableJc
    , (struct Size_Mtbl_t*)((0 +2) * sizeof(void*)) //J2C:size. NOTE: all elements has the size of void*.
    }
  }
, { { sign_Mtbl_CloseableJc //J2C: Head of methodtable of CloseableJc
    , (struct Size_Mtbl_t*)((0 +2) * sizeof(void*)) //J2C:size. NOTE: all elements has the size of void*.
    }
  }
, { { sign_Mtbl_FlushableJc //J2C: Head of methodtable of FlushableJc
    , (struct Size_Mtbl_t*)((0 +2) * sizeof(void*)) //J2C:size. NOTE: all elements has the size of void*.
    }
  }
}, { signEnd_Mtbl_ObjectJc, null } }; //Mtbl


 extern_C struct ClassJc_t const reflection_ObjectJc;
 static struct superClasses_StringFormatterJc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }superclasses_StringFormatterJc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
 , { {&reflection_ObjectJc, OFFSET_Mtbl(Mtbl_StringFormatterJc, ObjectJc) }
   }
 };

 extern_C struct ClassJc_t const reflection_AppendableJc_s;
 extern_C struct ClassJc_t const reflection_CloseableJc;
 extern_C struct ClassJc_t const reflection_FlushableJc;
 static struct ifcClasses_StringFormatterJc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[3];
 }interfaces_StringFormatterJc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
, { {&reflection_AppendableJc_s, OFFSET_Mtbl(Mtbl_StringFormatterJc, AppendableJc) }
  , {&reflection_CloseableJc, OFFSET_Mtbl(Mtbl_StringFormatterJc, CloseableJc) }
  , {&reflection_FlushableJc, OFFSET_Mtbl(Mtbl_StringFormatterJc, FlushableJc) }
  }
};

extern_C struct ClassJc_t const reflection_StringFormatterJc_s;
extern_C struct ClassJc_t const reflection_AppendableJc_s;
extern_C struct ClassJc_t const reflection_SimpleDateFormatJc_s;
extern_C struct ClassJc_t const reflection_StringBuilderJc;
extern_C struct ClassJc_t const reflection_StringJc;
const struct Reflection_Fields_StringFormatterJc_s_t
{ ObjectArrayJc head; FieldJc data[24];
} reflection_Fields_StringFormatterJc_s =
{ CONST_ObjectArrayJc(FieldJc, 24, OBJTYPE_FieldJc, null, &reflection_Fields_StringFormatterJc_s)
, {
     { "buffer"
    , 0 //nrofArrayElements
    , &reflection_StringBuilderJc
    , kEnhancedReference_Modifier_reflectJc /*@*/ |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringFormatterJc_s*)(0x1000))->buffer) - (int32)(StringFormatterJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringFormatterJc_s
    }
   , { "lineout"
    , 0 //nrofArrayElements
    , &reflection_AppendableJc_s
    , kEnhancedReference_Modifier_reflectJc /*@*/ //bitModifiers
    , (int16)((int32)(&((StringFormatterJc_s*)(0x1000))->lineout) - (int32)(StringFormatterJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringFormatterJc_s
    }
   , { "bShouldLineoutClose"
    , 0 //nrofArrayElements
    , REFLECTION_bool
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringFormatterJc_s*)(0x1000))->bShouldLineoutClose) - (int32)(StringFormatterJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringFormatterJc_s
    }
   , { "secondNewline"
    , 0 //nrofArrayElements
    , REFLECTION_char
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringFormatterJc_s*)(0x1000))->secondNewline) - (int32)(StringFormatterJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringFormatterJc_s
    }
   , { "pos"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringFormatterJc_s*)(0x1000))->pos) - (int32)(StringFormatterJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringFormatterJc_s
    }
   , { "bInsert"
    , 0 //nrofArrayElements
    , REFLECTION_bool
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringFormatterJc_s*)(0x1000))->bInsert) - (int32)(StringFormatterJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringFormatterJc_s
    }
   , { "sNewline"
    , 0 //nrofArrayElements
    , &reflection_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ //bitModifiers
    , (int16)((int32)(&((StringFormatterJc_s*)(0x1000))->sNewline) - (int32)(StringFormatterJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringFormatterJc_s
    }
   , { "cDecimalSeparator"
    , 0 //nrofArrayElements
    , REFLECTION_char
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringFormatterJc_s*)(0x1000))->cDecimalSeparator) - (int32)(StringFormatterJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringFormatterJc_s
    }
   , { "sDatePrefixNewer"
    , 0 //nrofArrayElements
    , &reflection_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ //bitModifiers
    , (int16)((int32)(&((StringFormatterJc_s*)(0x1000))->sDatePrefixNewer) - (int32)(StringFormatterJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringFormatterJc_s
    }
   , { "dateFormatNewer"
    , 0 //nrofArrayElements
    , &reflection_SimpleDateFormatJc_s
    , kEnhancedReference_Modifier_reflectJc /*@*/ |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringFormatterJc_s*)(0x1000))->dateFormatNewer) - (int32)(StringFormatterJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringFormatterJc_s
    }
   , { "sDatePrefixToday"
    , 0 //nrofArrayElements
    , &reflection_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ //bitModifiers
    , (int16)((int32)(&((StringFormatterJc_s*)(0x1000))->sDatePrefixToday) - (int32)(StringFormatterJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringFormatterJc_s
    }
   , { "dateFormatToday"
    , 0 //nrofArrayElements
    , &reflection_SimpleDateFormatJc_s
    , kEnhancedReference_Modifier_reflectJc /*@*/ |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringFormatterJc_s*)(0x1000))->dateFormatToday) - (int32)(StringFormatterJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringFormatterJc_s
    }
   , { "sDatePrefixYear"
    , 0 //nrofArrayElements
    , &reflection_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ //bitModifiers
    , (int16)((int32)(&((StringFormatterJc_s*)(0x1000))->sDatePrefixYear) - (int32)(StringFormatterJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringFormatterJc_s
    }
   , { "dateFormatYear"
    , 0 //nrofArrayElements
    , &reflection_SimpleDateFormatJc_s
    , kEnhancedReference_Modifier_reflectJc /*@*/ |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringFormatterJc_s*)(0x1000))->dateFormatYear) - (int32)(StringFormatterJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringFormatterJc_s
    }
   , { "sDatePrefixOlder"
    , 0 //nrofArrayElements
    , &reflection_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ //bitModifiers
    , (int16)((int32)(&((StringFormatterJc_s*)(0x1000))->sDatePrefixOlder) - (int32)(StringFormatterJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringFormatterJc_s
    }
   , { "dateFormatOlder"
    , 0 //nrofArrayElements
    , &reflection_SimpleDateFormatJc_s
    , kEnhancedReference_Modifier_reflectJc /*@*/ |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringFormatterJc_s*)(0x1000))->dateFormatOlder) - (int32)(StringFormatterJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringFormatterJc_s
    }
   , { "version"
    , 0 //nrofArrayElements
    , &reflection_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&version_StringFormatterJc) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&version_StringFormatterJc)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &reflection_StringFormatterJc_s
    }
   , { "k2left"
    , 0 //nrofArrayElements
    , REFLECTION_int16
    , 2 << kBitPrimitiv_Modifier_reflectJc |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&k2left_StringFormatterJc) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&k2left_StringFormatterJc)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &reflection_StringFormatterJc_s
    }
   , { "k4left"
    , 0 //nrofArrayElements
    , REFLECTION_int16
    , 2 << kBitPrimitiv_Modifier_reflectJc |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&k4left_StringFormatterJc) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&k4left_StringFormatterJc)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &reflection_StringFormatterJc_s
    }
   , { "k6left"
    , 0 //nrofArrayElements
    , REFLECTION_int16
    , 2 << kBitPrimitiv_Modifier_reflectJc |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&k6left_StringFormatterJc) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&k6left_StringFormatterJc)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &reflection_StringFormatterJc_s
    }
   , { "k8left"
    , 0 //nrofArrayElements
    , REFLECTION_int16
    , 2 << kBitPrimitiv_Modifier_reflectJc |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&k8left_StringFormatterJc) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&k8left_StringFormatterJc)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &reflection_StringFormatterJc_s
    }
   , { "spaces"
    , 0 //nrofArrayElements
    , &reflection_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&spaces_StringFormatterJc) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&spaces_StringFormatterJc)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &reflection_StringFormatterJc_s
    }
   , { "n10a"
    , 9 //nrofArrayElements
    , REFLECTION_int64
    , 8 << kBitPrimitiv_Modifier_reflectJc |kStaticArray_Modifier_reflectJc |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&n10a_StringFormatterJc) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&n10a_StringFormatterJc)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &reflection_StringFormatterJc_s
    }
   , { "sNeg"
    , 0 //nrofArrayElements
    , &reflection_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&sNeg_StringFormatterJc) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&sNeg_StringFormatterJc)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &reflection_StringFormatterJc_s
    }
} };
const ClassJc reflection_StringFormatterJc_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &reflection_ObjectJc, &reflection_ClassJc) 
, "StringFormatterJc_s"
, (int16)((int32)(&((StringFormatterJc_s*)(0x1000))->base.object) - (int32)(StringFormatterJc_s*)0x1000)
, sizeof(StringFormatterJc_s)
, (FieldJcArray const*)&reflection_Fields_StringFormatterJc_s
, null //method
, (ClassOffset_idxMtblJcARRAY*)&superclasses_StringFormatterJc_s //superclass
, (ClassOffset_idxMtblJcARRAY*)&interfaces_StringFormatterJc_s //interfaces
, mObjectJc_Modifier_reflectJc
, &mtblStringFormatterJc.mtbl.head
};
