/**************************************************************************
 * This file is generated by Java2C
 **copyright***************************************************************
 *************************************************************************/
#ifndef __J1c_StringPartJc_h__
#define __J1c_StringPartJc_h__

#include "emC/Base/MemC_emC.h"        //basic concept

#include "emC/Jc/ObjectJc.h"        //basic concept

#include "emC/Jc/StringJc.h"        //used often

   //basic concept

#ifdef DEF_ObjectJc_SIMPLE
#error "cannot compile with DEF_ObjectJc_SIMPLE, needs virtual operations for CharSeqJc in Part_StringPartJc"
#endif

/* J2C: Forward declaration of struct ***********************************************/
struct Part_StringPartJc_t;
struct StringBuilderJc_t;
struct StringPartJc_t;


/* J2C: includes *********************************************************/
#include "emC/Jc/ObjectJc.h"  //interface
#include "emC/Jc/StringJc.h"  //interface


/*@CLASS_C Part_StringPartJc @@@@@@@@@@@@@@@@@@@@@@@@*/

typedef struct Part_StringPartJc_t
{ 
  union { ObjectJc object; CharSeqObjJc CharSeqObjJc;} base; 
  struct StringPartJc_t* outer;  //J2C: Reference to outer class, implicit in Java
  int32 b1;   /*Absolute positions of part of chars*/
  int32 e1;   /*Absolute positions of part of chars*/
  int32 absPos0;
} Part_StringPartJc_s;
  

#define sizeof_Part_StringPartJc_s sizeof(Part_StringPartJc_s)


/**J2c: Definitions of the enhanced reference. It's conditinally because it may be defined in a included header before. */
#ifndef Part_StringPartJcREFDEF
  //J2C: definition of enhanced reference where it was need firstly: 
  #define Part_StringPartJcREFDEF
  struct Part_StringPartJc_t;
  typedef TYPE_EnhancedRefJc(Part_StringPartJc);
#endif

/**J2c: Definitions of the array forms. NOTE: The number of elements are a helper for debug, the really used number depends on the memory size! */
typedef struct Part_StringPartJc_X_t { ObjectArrayJc head; Part_StringPartJcREF data[50]; } Part_StringPartJc_X;
typedef struct Part_StringPartJc_Y_t { ObjectArrayJc head; Part_StringPartJc_s data[50]; } Part_StringPartJc_Y;

 extern_C struct ClassJc_t const refl_Part_StringPartJc_s;
  


/**CONST_Type useable as initializer for embedded/stack-instances*/
#define CONST_Part_StringPartJc(OBJP) { CONST_ObjectJc(sizeof(Part_StringPartJc_s), OBJP, &refl_Part_StringPartJc_s), 0 }

/**J2C: finalize declaration. It is called by Garbage collector and inside other finalized methods.
 * It should be called by the user if the instance is removed. */
void finalize_Part_StringPartJc_F(ObjectJc* othis, ThCxt* _thCxt);




/**A subsequence
*/
METHOD_C struct Part_StringPartJc_t* ctorO_Part_StringPartJc(struct StringPartJc_t* outer, ObjectJc* othis, int32 from, int32 to, ThCxt* _thCxt);


METHOD_C void setPart_Part_StringPartJc(struct Part_StringPartJc_t* thiz, int32 from, int32 to, ThCxt* _thCxt);


METHOD_C char charAt_i_Part_StringPartJc(CharSeqObjJc const* ithis, int32 index, ThCxt* _thCxt);

METHOD_C int32 length_Part_StringPartJc(Part_StringPartJc_s const* thiz, ThCxt* _thCxt);

METHOD_C CharSeqJc subSequence_ii_Part_StringPartJc(CharSeqObjJc const* ithis, int32 from, int32 end, ThCxt* _thCxt);

METHOD_C StringJc toString_Part_StringPartJc(ObjectJc* ithis, ThCxt* _thCxt);


/**Copy to any other buffer to build persistent data. 
 * @param dst should be allocated with enough space, use this.{@link #length()} to detect how much is necessary.
 * @param from usual 0
 * @return the length, same as {@link #length()}
 */
METHOD_C int copyToBuffer_Part_StringPartJc(struct Part_StringPartJc_t* thiz, char* dst, int from, int to, ThCxt* _thCxt);



/**Builds a new Part without leading and trailing white spaces.
Without " \r\n\t"
*/
METHOD_C struct Part_StringPartJc_t* trim_Part_StringPartJc(Part_StringPartJc_s* thiz, ThCxt* _thCxt);


/* J2C: Method table contains all dynamic linked (virtual) methods
 * of the class and all super classes and interfaces. */
 extern const char sign_Vtbl_Part_StringPartJc[]; //marker for methodTable check
typedef struct Vtbl_Part_StringPartJc_t
{ VtblHeadJc head;
  Vtbl_ObjectJc ObjectJc;
  //Method table of interfaces:
  Vtbl_CharSeqJc CharSeqJc;
} Vtbl_Part_StringPartJc;



#if defined(__CPLUSPLUSJcpp) && defined(__cplusplus)
/* J2C: The C++-class-definition. */
class Part_StringPartJc : private Part_StringPartJc_s
{ public:

  char charAt(int32 index){  return charAt_i_Part_StringPartJc(&this->base.object.base.object, index,  null/*_thCxt*/); }

  int32 length(){  return length_Part_StringPartJc(&this->base.object.base.object,  null/*_thCxt*/); }

  CharSeqJc subSequence(int32 from, int32 end){  return subSequence_ii_Part_StringPartJc(&this->base.object.base.object, from, end,  null/*_thCxt*/); }

  StringJc toString(){  return toString_Part_StringPartJc(&this->base.object,  null/*_thCxt*/); }

  struct Part_StringPartJc_t* trim(){  return trim_Part_StringPartJc(this,  null/*_thCxt*/); }
};

#endif /*__CPLUSPLUSJcpp*/



/*@CLASS_C StringPartJc @@@@@@@@@@@@@@@@@@@@@@@@*/

typedef struct StringPartJc_t
{ 
  union { ObjectJc object; CharSeqObjJc CharSeqObjJc; ComparableJc ComparableJc;} base; 
  int32 begin;   /*The actual start position of the valid part.*/
  int32 end;   /*The actual exclusive end position of the valid part.*/
  int32 begiMin;   /*The most left possible start position. We speak about the 'maximal Part':*/
  int32 endMax;   /*The most right possible exclusive end position. See explanation on startMin.*/
  /**The absolute position of character in the input file of content[0] It is used for {@link StringPartFromFileLines} or adequate reader.*/
  int32 absPos0;

  CharSeqJc content;   /*The referenced string. It is a CharSequence for enhanced using.    */
  bool bCurrentOk;   /*false if current scanning is not match*/
  bool bStartScan;   /*If true, than all idxLastScanned... are set to 0, */
  int32 beginLast;   /*Borders of the last part before calling of scan__(), seek__(), lento__(). If there are different to the current part,*/
  int32 endLast;   /*Borders of the last part before calling of scan__(), seek__(), lento__(). If there are different to the current part,*/
  bool bFound;   /*True if the last operation of lento__(), seek etc. has found anything. See {@link #found()}. */
  int32 bitMode;   /*Some mode bits. See all static final int xxx_mode. */
  StringJc sFile;   /*Bit in mode. Only if this bit is set, the method {@link #getCurrentColumn()} calculates the column.*/
  StringJc sCommentStart;   /*The string defined the start of comment inside a text.*/
  StringJc sCommentEnd;   /*The string defined the end of comment inside a text.*/
  StringJc sCommentToEol;   /*The string defined the start of comment to end of line*/
} StringPartJc_s;
  

#define sizeof_StringPartJc_s sizeof(StringPartJc_s)


/**J2c: Definitions of the enhanced reference. It's conditinally because it may be defined in a included header before. */
#ifndef StringPartJcREFDEF
  //J2C: definition of enhanced reference where it was need firstly: 
  #define StringPartJcREFDEF
  struct StringPartJc_t;
  typedef TYPE_EnhancedRefJc(StringPartJc);
#endif

/**J2c: Definitions of the array forms. NOTE: The number of elements are a helper for debug, the really used number depends on the memory size! */
typedef struct StringPartJc_X_t { ObjectArrayJc head; StringPartJcREF data[50]; } StringPartJc_X;
typedef struct StringPartJc_Y_t { ObjectArrayJc head; StringPartJc_s data[50]; } StringPartJc_Y;

 extern_C struct ClassJc_t const refl_StringPartJc_s;
  


/**CONST_Type useable as initializer for embedded/stack-instances*/
#define CONST_StringPartJc(OBJP) { CONST_ObjectJc(sizeof(StringPartJc_s), OBJP, &refl_StringPartJc_s), 0 }

/**J2C: finalize declaration. It is called by Garbage collector and inside other finalized methods.
 * It should be called by the user if the instance is removed. */
void finalize_StringPartJc_F(ObjectJc* othis, ThCxt* _thCxt);


 extern StringJc sVersion_StringPartJc;   /*Version, history and license.*/
#define seekEnd_StringPartJc 1  /*Flag to force setting the start position after the seeking string. See description on seek(CharSequence, int).*/
#define mSeekBackward__StringPartJc 0x10  /*Flag bit to force seeking backward. This value is contens impilicit in the mSeekBackFromStart or ~End,*/
#define mSeekToLeft__StringPartJc 0x40  /*Flag bit to force seeking left from start (Backward). This value is contens impilicit in the seekBackFromStart*/
 extern const int32 seekToLeft_StringPartJc;   /*Flag to force seeking backward from the start position. See description on seek(CharSequence).*/
 extern const int32 seekBack_StringPartJc;   /*Flag to force seeking backward from the end position. See description on seek(CharSequence).*/
#define seekNormal_StringPartJc 0  /*Flag to force seeking forward. See description on seek(CharSequence).*/
#define mSkipOverWhitespace_mode_StringPartJc 0x1  /*Bit in mode. If this bit ist set, all whitespace are overreaded*/
#define mSkipOverCommentInsideText_mode_StringPartJc 0x2  /*Bit in mode. If this bit ist set, all comments are overreaded*/
#define mSkipOverCommentToEol_mode_StringPartJc 0x4  /*Bit in mode. If this bit ist set, all comments are overreaded*/

//!!usage: static init code, invoke that one time in start of main.
void initStatic_StringPartJc();




/**Creates a new empty StringPart without an associated String. See method set() to assign a String.*/
METHOD_C struct StringPartJc_t* ctorO_StringPartJc(ObjectJc* othis, ThCxt* _thCxt);

/**Creates a new StringPart, with the given content from a String. Initialy the whole string is valid
and determines the maximal part.
Constructs with a given CharSequence, especially with a given String.
*/
METHOD_C struct StringPartJc_t* ctorO_Cs_StringPartJc(ObjectJc* othis, CharSeqJc src, ThCxt* _thCxt);

/**Builds a StringPart which uses the designated part of the given src.
Creates a new StringPart with the same String as the given StringPart. The maximal part of the new StringPart
are determined from the actual valid part of the src. The actual valid part is equal to the maximal one.
<hr/><u>example:</u><pre>
abcdefghijklmnopqrstuvwxyz  The associated String
----------------        The valid part of src
================        The maximal part and initial the valid part of this
+++++   ++++            Possible valid parts of this after some operations
++++      +++        Possible also
+++++           ++++ +++  Never valid parts of this after operations because they exceeds the borders of maximal part.
</pre>
*/
METHOD_C struct StringPartJc_t* ctorO_Csii_StringPartJc(ObjectJc* othis, CharSeqJc src, int32 start, int32 end, ThCxt* _thCxt);

/**Sets the input file for information {@link #getInputfile()}
*/
METHOD_C void setInputfile_StringPartJc(StringPartJc_s* thiz, StringJc file, ThCxt* _thCxt);

/**Sets the content to the given string, forgets the old content. Initialy the whole string is valid.
*/
METHOD_C struct StringPartJc_t* assign_Cs_StringPartJc(StringPartJc_s* thiz, CharSeqJc ref, ThCxt* _thCxt);

/**Sets the content to the given string, forgets the old content. 
All Place-holder for System environment variable are replaced firstly.
A place holder for a environment variable is written like "$(name)" or "$name" like in a unix shell.
The replacement is done in the content. 
Initially the whole string is valid.
TODO designate input as persistent.
*/
METHOD_C struct StringPartJc_t* assignReplaceEnv_StringPartJc(StringPartJc_s* thiz, struct StringBuilderJc_t* input, ThCxt* _thCxt);

/**Sets the StringPart with the same String object as the given StringPart, forgets the old content.
The borders of the new StringPart (the maximal part)
are determined from the actual valid part of the src. The actual valid part is equal to this limits.
If the src is the same instance as this (calling with 'this'), than the effect is the same.
The maximal Part is determined from the unchanged actual part.
<hr/><u>example:</u><pre>
abcdefghijklmnopqrstuvwxyz  The associated String
----------------        The valid part of src
================        The maximal part and initial the valid part of this
+++++   ++++            Possible valid parts of this after some operations
++++      +++        Possible also
+++++           ++++ +++  Never valid parts of this after operations because they exceeds the borders of maximal part.
</pre>
*/
METHOD_C struct StringPartJc_t* assign_XX_StringPartJc(StringPartJc_s* thiz, struct StringPartJc_t* src, ThCxt* _thCxt);

/**Sets the content of the StringPart , forgets the old content. The same string like in src is associated.
Initialy the part from the end of the src-part to the maximal end of src is valid. The valid part and
the maximal part is set in this same way.
<hr/><u>example:</u><pre>
abcdefghijklmnopqrstuvwxyz  The associated String
=====================     The maximal part of src
------                  The valid part of src
=============     The maximal and initialy the valid part of this
</pre>
*/
METHOD_C struct StringPartJc_t* assignFromEnd_StringPartJc(StringPartJc_s* thiz, struct StringPartJc_t* src, ThCxt* _thCxt);

/**Set the mode of ignoring comments.
If it is set, comments are always ignored on every scan operation. 
On scan, the current position is set first after a comment if the current position began with a comment.
This mode may or should be combinded with setIgnoreWhitespace.<br/> 
The string introduces and finishes a comment is setted by calling 
setIgnoreComment(String sStart, String sEnd). The default value is "/ *" and "* /" like in java-programming. 
*/
METHOD_C bool setIgnoreComment_b_StringPartJc(StringPartJc_s* thiz, bool bSet, ThCxt* _thCxt);

/**Set the character string of inline commentmode of ignoring comments.
After this call, comments are always ignored on every scan operation. 
On scan, the current position is set first after a comment if the current position began with a comment.
This mode may or should be combinded with setIgnoreWhitespace.<br/> 
*/
METHOD_C bool setIgnoreComment_SS_StringPartJc(StringPartJc_s* thiz, StringJc sStart, StringJc sEnd, ThCxt* _thCxt);

/**Set the mode of ignoring comments to end of line.
If it is set, end-line-comments are always ignored on every scan operation. 
On scan, the current position is set first after a comment if the current position began with a comment.
This mode may or should be combinded with setIgnoreWhitespace.<br/> 
The string introduces a endofline-comment is setted by calling 
setEndlineCommentString(). The default value is "//" like in java-programming. 
*/
METHOD_C bool setIgnoreEndlineComment_b_StringPartJc(StringPartJc_s* thiz, bool bSet, ThCxt* _thCxt);

/**Set the character string introducing the comments to end of line.
After this call, endline-comments are always ignored on every scan operation. 
On scan, the current position is set first after a comment if the current position began with a comment.
This mode may or should be combinded with setIgnoreWhitespace.<br/> 
*/
METHOD_C bool setIgnoreEndlineComment_S_StringPartJc(StringPartJc_s* thiz, StringJc sStart, ThCxt* _thCxt);

/**Set the mode of ignoring whitespaces.
If it is set, whitespaces are always ignored on every scan operation. 
On scan, the current position is set first after a comment if the current position began with a comment.
This mode may or should be combinded with setIgnoreWhitespace.<br/> 
The chars accepted as whitespace are setted by calling 
setWhiteSpaceCharacters(). The default value is " \t\r\n\f" like in java-programming.
*/
METHOD_C bool setIgnoreWhitespaces_StringPartJc(StringPartJc_s* thiz, bool bSet, ThCxt* _thCxt);

/**Sets the start of the maximal part to the actual start of the valid part.
See also seekBegin(), that is the opposite operation.
<hr/><u>example:</u><pre>
abcdefghijklmnopqrstuvwxyz  The associated String
================        The maximal part before operation
------             The actual part
===========        The maximal part after operation
</pre>
*/
METHOD_C struct StringPartJc_t* setBeginMaxPart_StringPartJc(StringPartJc_s* thiz);

/**Sets the full range of available text.
begin is set to 0, end is set to the length() of the content.
*/
METHOD_C struct StringPartJc_t* setParttoMax_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt);

/**Sets the start of the part to the exclusively end, set the end to the end of the content.
<hr/><u>example:</u><pre>
abcdefghijklmnopqrstuvwxyz  The associated String
=================         The maximal part
-----              The valid part before
+++++         The valid part after.
</pre>
*/
METHOD_C struct StringPartJc_t* fromEnd_StringPartJc(StringPartJc_s* thiz);

/**This method returns the characters of the current part.
@see java.lang.CharSequence#charAt(int)
*/
METHOD_C char charAt_i_StringPartJc(CharSeqObjJc const* ithis, int32 index, ThCxt* _thCxt);

METHOD_C bool checkCharAt_StringPartJc(StringPartJc_s* thiz, int32 pos, StringJc chars, ThCxt* _thCxt);

/**Returns a volatile CharSequence from the range inside the current part.
If it is not possible an IllegalArgumentException is thrown.
The difference to {@link #subString(int, int)} is: It is not persistent.
This method should only used if the CharSequence is processed in the thread immediately
for example by adding to another StringBuilder etc. The returned instance should not be saved
for later usage.

For C usage: The returned instance is located in the Thread Context. It should be freed with <code>releaseUserBuffer_ThreadContext_emC(...)<(code>.
The Java2C-translator does that automatically.

@see java.lang.CharSequence#subSequence(int, int)
*/
METHOD_C CharSeqJc subSequence_ii_StringPartJc(CharSeqObjJc const* ithis, int32 from, int32 to, ThCxt* _thCxt);

METHOD_C void throwSubSeqFaulty_StringPartJc(StringPartJc_s* thiz, int32 from, int32 to, ThCxt* _thCxt);

METHOD_C int32 length_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt);


/**Returns the lenght of the maximal part from current position. Returns also 0 if no string is valid.
*/
METHOD_C int32 lengthMaxPart_StringPartJc(StringPartJc_s* thiz);

/**Sets the endposition of the part of string to the given chars after start.
 */
#define lento_i_StringPartJc(THIZ, len) \
(lentoPos_StringPartJc((THIZ), len, _thCxt))

/**Sets the endposition of the part of string to the given chars after start.
*/
METHOD_C struct StringPartJc_t* lentoPos_StringPartJc(StringPartJc_s* thiz, int32 len, ThCxt* _thCxt);

/**Sets the end position of the part of string to exclusively the char cc.
If the char cc is not found, the end position is set to start position, so the part of string is empty.
It is possible to call set0end() to set the end of the part to the maximal end if the char is not found.
That is useful by selecting a part to a separating char such ',' but the separator is not also the terminating char
of the last part.
<hr/><u>example:</u><pre>
abcdefghijklmnopqrstuvwxyz  The associated String
=================         The maximal part of src
-----              The valid part of src before calling the method
+                  after calling lento('w') the end is set to start
position, the length() is 0, because the 'w' is outside.
++++++++++         calling set0end() is possible and produce this result.
</pre>
*/
METHOD_C struct StringPartJc_t* lento_c_StringPartJc(StringPartJc_s* thiz, char cc, ThCxt* _thCxt);

/**Sets the endposition of the part of string to exclusively the given string.
If the string is not found, the end position is set to start position, so the part of string is emtpy.
It is possible to call set0end() to set the end of the part to the maximal end if the char is not found.
That is useful by selecting a part to a separating char such ',' but the separator is not also the terminating char
of the last part, example see lento(char cc)
*/
METHOD_C struct StringPartJc_t* lento_Cs_StringPartJc(StringPartJc_s* thiz, CharSeqJc ss, ThCxt* _thCxt);

/**Sets the endposition of the part of string to exclusively the given string.
If the string is not found, the end position is set to start position, so the part of string is emtpy.
It is possible to call set0end() to set the end of the part to the maximal end if the char is not found.
That is useful by selecting a part to a separating char such ',' but the separator is not also the terminating char
of the last part, example see lento(char cc)
*/
METHOD_C struct StringPartJc_t* lento_Csi_StringPartJc(StringPartJc_s* thiz, CharSeqJc ss, int32 mode, ThCxt* _thCxt);

/**Sets the endposition of the part of string to the end of the identifier which is beginning on start.
If the part starts not with a identifier char, the end is set to the start position.
<hr/><u>example:</u><pre>
abcd  this is a part uvwxyz The associated String
=====================     The border of valid parts of src
-------              The valid part of the src before calling the method
+++                  after calling lentoIdentifier(). The start position
is not effected. That's why the identifier-part is only "his".
</pre>
*/
METHOD_C struct StringPartJc_t* lentoIdentifier_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt);

/**Sets the endposition of the part of string to the end of the identifier which is beginning on start.
If the part starts not with a identifier char, the end is set to the start position.
@see lentoIdentifier().
*/
METHOD_C struct StringPartJc_t* lentoIdentifier_CsCs_StringPartJc(StringPartJc_s* thiz, CharSeqJc additionalStartChars, CharSeqJc additionalChars, ThCxt* _thCxt);

/**Sets the len to the first position of any given char, but not if the char is escaped.
'Escaped' means, a \ is disposed before the char.
Example: lentoAnyNonEscapedChar("\"") ends not at a \", but at ".
it detects the string "this is a \"quotion\"!".
<br>
This method doesn't any things, if the last scanning call isn't match. Invoking of 
{@link scanOk()} before guarantees that the method works.
*/
METHOD_C struct StringPartJc_t* lentoAnyNonEscapedChar_StringPartJc(StringPartJc_s* thiz, CharSeqJc sCharsEnd, int32 maxToTest, ThCxt* _thCxt);

/**Sets the length of the valid part to the first position of the given String, 
but not if the String is escaped.
'Escaped' means, a \ is disposed before the char.
Example: lentoNonEscapedString("<?") does not accept "\\<?".
<br><br>
This method doesn't any things, if the last scanning call isn't match. Invoking of 
{@link scanOk()} before guarantees that the method works.
*/
METHOD_C struct StringPartJc_t* lentoNonEscapedString_StringPartJc(StringPartJc_s* thiz, CharSeqJc sEnd, int32 maxToTest, ThCxt* _thCxt);

/**Sets the current Part from the current position to exactly one line.
The start position of the current part will be set backward to the start of the line or to the start of the maximal part.
The end position of the current part will be set to the end of the one line or the end of the maximal part
independent from the end of the current part before.
The functionality of #found() is not influenced. It may be the return value from a seek before.   
*/
METHOD_C struct StringPartJc_t* line_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt);

/**Sets the current and the maximal part from position 0 to the first end line character.
If a line end character was not found - the last line without line end - the end is set to the last end.
The line end character is either \r or \n.
Because the maximal part is set to the line, anything inside the line can be selected as current part.
The {@link #nextlineMaxpart()} works properly nevertheless. 
*/
METHOD_C struct StringPartJc_t* firstlineMaxpart_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt);

/**Sets the current and the maximal part from the current end to the next line end character.
<ul>
<li>If the current end before refers a line end character itself, it is seek after it firstly. That is the standard behavior to read lines.
<li>If the current end before does not refer a line end character, the next line end character is searched firstly.
That behavior is important if the current part of the last line was set anywhere inside the line.
</ul>
If a line end character was not found - the last line without line end - the end is set to the last end.
The line end character is either \r or \n or a sequence of \r\n or \n\r 
*/
METHOD_C struct StringPartJc_t* nextlineMaxpart_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt);

/**Displaces the start of the part for some chars to left or to right.
If the seek operation would exceeds the maximal part borders, a StringIndexOutOfBoundsException is thrown.

<hr/><u>example:</u><pre>
abcdefghijklmnopqrstuvwxyz  The associated String
=================         The maximal part
-----              The valid part before
+++++++              The valid part after calling seek(-2).
+++              The valid part after calling seek(2).
+              The valid part after calling seek(5).
The start is set to end, the lenght() is 0.
++++++++++++              The valid part after calling seek(-5).
</pre>
*/
METHOD_C struct StringPartJc_t* seek_i_StringPartJc(StringPartJc_s* thiz, int32 nr, ThCxt* _thCxt);

/**Sets the begin of the current part relative to the given number of character. 
If the range is outside, this routine sets {@link #found()} to false and does not change the position.
If the range is valid, {@link #found()} returns true.
<br>Example: seek(3):<pre>
abcdefghijklmnopqrstuvwxyz  The associated String
----------            The valid part before
+++++++             The valid part after
</pre>
<br>Example: seek(-3):<pre>
abcdefghijklmnopqrstuvwxyz  The associated String
----------            The valid part before
+++++++++++++            The valid part after
</pre>
*/
METHOD_C struct StringPartJc_t* seekPos_StringPartJc(StringPartJc_s* thiz, int32 nr, ThCxt* _thCxt);

/**Sets the begin of the current part backward from end. 
If the range is outside, this routine sets {@link #found()} to false and does not change the position.
If the range is valid, {@link #found()} returns true.
<br>Example: seekBack(5):<pre>
abcdefghijklmnopqrstuvwxyz  The associated String
----------               The valid part before
+++++               The valid part after
</pre>
*/
METHOD_C struct StringPartJc_t* seekPosBack_StringPartJc(StringPartJc_s* thiz, int32 nr, ThCxt* _thCxt);

/**Displaces the start of the part to the first char it is no whitespace.
If the current char at seek position is not a whitespace, the method has no effect.
If only whitespaces are founded to the end of actual part, the position is set to this end.

<hr/><u>example:</u><pre>
abcdefghijklmnopqrstuvwxyz  The associated String
=================         The maximal part
----------              The valid part before
+++++++              The valid part after, if 'defg' are whitespaces
++++++++++              The valid part after is the same as before, if no whitespace at current position
.              The valid part after is emtpy, if only whitespaces re found.
</pre>
*/
METHOD_C struct StringPartJc_t* seekNoWhitespace_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt);

/**skip over comment and whitespaces
*/
METHOD_C struct StringPartJc_t* skipWhitespaceAndComment_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt);

/**Displaces the begin of the part to the first char it is no whitespace or comment.
If the current char at seek position is not a whitespace or not the beginning of a comment, the method has no effect.
If only whitespaces and comments are found to the end of actual part, the position is set to its end.

<hr/><u>example:</u><pre>
abcdefghijklmnopqrstuvwxyz  The associated String
=================         The maximal part
----------              The valid part before
+++++++              The valid part after, if 'defg' are whitespaces
++++++++++              The valid part after is the same as before, if no whitespace at current position
.              The valid part after is emtpy, if only whitespaces re found.
</pre>
*/
METHOD_C struct StringPartJc_t* seekNoWhitespaceOrComments_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt);

/**Returns true, if the last called seek__(), lento__() or skipWhitespaceAndComment()
operation founds the requested condition. This methods posits the current Part in a appropriate manner
if the seek or lento-conditions were not prosperous. In this kinds this method returns false.
*/
METHOD_C bool found_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt);

/**Displaces the begin of the part to the leftest possible begin.
<br>example:<pre>
abcdefghijklmnopqrstuvwxyz  The associated String
=================         The maximal part
-----              The valid part before
++++++++++++              The valid part after calling seekBegin().
</pre>
*/
METHOD_C struct StringPartJc_t* seekBegin_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt);

/**Searchs the given String inside the valid part, posits the begin of the part to the begin of the searched string.
The end of the part is not affected.
If the string is not found, the begin is posit on the actual end. The length()-method supplies 0.
Methods such fromEnd() are not interacted from the result of the searching.
The rule is: seek()-methods only shifts the begin position.

<hr/><u>example:</u><pre>
that is a liststring and his part The associated String
=============================   The maximal part
----------------------      The valid part before
+++++++++++++++++      The valid part after seek("is",StringPartBase.seekNormal).
+++++++++++++++      The valid part after seek("is",StringPartBase.seekEnd).
++      The valid part after seek("is",StringPartBase.back).
.      The valid part after seek("is",StringPartBase.back + StringPartBase.seekEnd).
+++++++++++++++++++++++      The valid part after seek("is",StringPartBase.seekToLeft).
+++++++++++++++++++++      The valid part after seek("is",StringPartBase.seekToLeft + StringPartBase.seekEnd).
++++++++++++++++++++++++++      The valid part after seek("xx",StringPartBase.seekToLeft).
.      The valid part after seek("xx",StringPartBase.seekNormal)
or seek("xx",StringPartBase.back).

</pre>
*/
METHOD_C struct StringPartJc_t* seek_Csi_StringPartJc(StringPartJc_s* thiz, CharSeqJc sSeek, int32 mode, ThCxt* _thCxt);

/**Seeks back form the current end to the end of the given String starting from the end of the current part.
If the String was found, the start of the current part is changed to the end of the found String.
Sets {@link #found()} to false if the String is not contained in the current part.
Then the current part is not changed.
*/
METHOD_C struct StringPartJc_t* seekBackward_StringPartJc(StringPartJc_s* thiz, CharSeqJc sSeek, ThCxt* _thCxt);

/**Seeks to one of the characters contained in chars, starting from the begin of the current part.
If a character was found, the start of the current part is changed to that character.
Sets {@link #found()} to false if a character of chars is not contained in the current part.
Then the current part is not changed.
*/
METHOD_C struct StringPartJc_t* seekAnyChar_StringPartJc(StringPartJc_s* thiz, CharSeqJc chars, ThCxt* _thCxt);

/**Seeks back from the current end to one of the characters contained in chars, starting from the end of the current part.
If a character was found, the start of the current part is changed to that character.
Sets {@link #found()} to false if a character of chars is not contained in the current part.
Then the current part is not changed.
*/
METHOD_C struct StringPartJc_t* seekBackToAnyChar_StringPartJc(StringPartJc_s* thiz, CharSeqJc chars, ThCxt* _thCxt);

/**Seeks to the given CharSequence, result is left side of the string.
 */
#define seek_Cs_StringPartJc(THIZ, sSeek) \
(seek_Csi_StringPartJc((THIZ), sSeek, seekNormal_StringPartJc, _thCxt))

/**Searchs the given CharSequence inside the valid part, posits the begin of the part to the begin of the searched string.
The end of the part is not affected.<br>
If the string is not found, the begin is posit to the actual end. The length()-method supplies 0.
Methods such fromEnd() are not interacted from the result of the searching.
The rule is: seek()-methods only shifts the begin position.<br>
see {@link seek(CharSequence sSeek, int mode)}
*/
METHOD_C struct StringPartJc_t* seekAnyString_StringPartJc(StringPartJc_s* thiz, CharSeqJc_Y* strings, int32* nrofFoundString, ThCxt* _thCxt);

/**Searchs the given character inside the valid part, posits the begin of the part to the begin of the searched char.
The end of the part is not affected.
If the string is not found, the begin is posit on the actual end
or, if mode contents seekBack, the begin of the maximal part. 
In this cases isFound() returns false and a call of restoreLastPart() restores the old parts.
The length()-method supplies 0.
Methods such fromEnd() are not interacted from the result of the searching.
The rule is: seek()-methods only shifts the begin position.<br/>
The examples are adequate to seek(CharSequence, int mode);

*/
METHOD_C struct StringPartJc_t* seek_ci_StringPartJc(StringPartJc_s* thiz, char cSeek, int32 mode, ThCxt* _thCxt);

/**Posits the start of the part after all of the chars given in the parameter string.
The end of the part is not affected.
<pre>sample: seekNoChar("123") result is:
12312312312abcd12312efghij123123
before:       ==========================
after:               ===================
</pre>
*/
METHOD_C struct StringPartJc_t* seekNoChar_StringPartJc(StringPartJc_s* thiz, CharSeqJc sChars, ThCxt* _thCxt);

/**Seeks to the next non-empty line.
*/
METHOD_C struct StringPartJc_t* seekNextLine_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt);

/**Searches any char contained in sChars in the current part
Example: The given string in the current part is
<pre>abc end:zxy</pre>
The calling is
<pre>indexOfAnyChar("xyz", 0, 20);</pre>
The result is 8 because the character 'z' is found first as the end char.

*/
METHOD_C int32 indexOfAnyChar_Csii_StringPartJc(StringPartJc_s* thiz, CharSeqJc sChars, int32 fromWhere, int32 maxToTest, ThCxt* _thCxt);

/**Returns the position of one of the chars in sChars within the part, started inside the part with fromIndex,
returns -1 if the char is not found in the part started from 'fromIndex'.
It may regard transcription characters and it regard quotation. 
A transcription character is a pair of characters 
with the transcriptionChar, usual '\' followed by any special char. This pair of characters
are not regarded while search the end of the text part, and the transcription
will be resolved in the result (dst) String.
<br>
The end of the string is determined by any of the given chars.
But a char directly after the transcription char is not detected as an end char.
Example: <pre>scanTranscriptionToAnyChar(dst, ">?", '\\', '\"', '\"')</pre> 
does not end at a char > after an \ and does not end inside the quotation.
If the following string is given: 
<pre>a text -\>arrow, "quotation>" till > ...following</pre> 
then the last '>' is detected as the end character. The first one is a transcription,
the second one is inside a quotation.
<br><br>
The meaning of the transcription characters is defined in the routine
{@link StringFunctions#convertTranscription(CharSequence, char)}: 
Every char after the transcriptChar is accepted. But the known transcription chars
\n, \r, \t, \f, \b are converted to their control-char- equivalence.
The \s and \e mean begin and end of text, coded with ASCII-STX and ETX = 0x2 and 0x3.</br></br>
The actual part is tested for this, after this operation the actual part begins
after the gotten chars!

*/
METHOD_C int32 indexOfAnyChar_Csiiccc_StringPartJc(StringPartJc_s* thiz, CharSeqJc sChars, int32 fromWhere, int32 maxToTest, char transcriptChar, char quotationStartChar, char quotationEndChar, ThCxt* _thCxt);

/**Returns the last position of one of the chars in sChars 
within the part of actual part from (fromIndex) to (fromIndex+maxToTest) 
or returs -1 if the char is not found in this part.
*/
METHOD_C int32 lastIndexOfAnyChar_StringPartJc(StringPartJc_s* thiz, CharSeqJc sChars, int32 fromWhere, int32 maxToTest, ThCxt* _thCxt);

/**Returns the position of one of the chars in sChars within the part, started inside the part with fromIndex,
returns -1 if the char is not found in the part started from 'fromIndex'.
*/
METHOD_C int32 indexOfAnyString_StringPartJc(StringPartJc_s* thiz, CharSeqJc_Y* listStrings, int32 fromWhere, int32 maxToTest, int32* nrofFoundString, StringJc* foundString, ThCxt* _thCxt);

/**Searches any char contained in sChars in the current part
but skip over quotations while testing. Example: The given string in the current part is
<pre>abc "yxz" end:zxy</pre>
The calling is
<pre>lentoAnyCharOutsideQuotion("xyz", 20);</pre>
The result is 14 because the character 'z' is found first as the end char, but outside the quoted string "xyz".

*/
METHOD_C int32 indexOfAnyCharOutsideQuotion_StringPartJc(StringPartJc_s* thiz, CharSeqJc sChars, int32 fromWhere, int32 maxToTest, ThCxt* _thCxt);

/**Searches the end of a quoted string. In Generally, a backslash skips over the next char
and does not test it as end of the quotion.  
*/
METHOD_C int32 indexEndOfQuotion_StringPartJc(StringPartJc_s* thiz, char cEndQuotion, int32 fromWhere, int32 maxToTest, ThCxt* _thCxt);

/**Searches the end of a quoted string. In Generally, a backslash skips over the next char
and does not test it as end of the quotion.  
*/
METHOD_C int32 indexEndOfQuotation_StringPartJc(StringPartJc_s* thiz, char cEndQuotion, char transcriptChar, int32 fromWhere, int32 maxToTest, ThCxt* _thCxt);

/**Returns the position of one of the chars in sChars within the part,
returns -1 if the char is not found in the actual part.
*/
METHOD_C int32 indexOfAnyChar_Cs_StringPartJc(StringPartJc_s* thiz, CharSeqJc sChars, ThCxt* _thCxt);

/**Returns the position of the first char other than the chars in sChars within the part, started inside the part with fromIndex,
returns -1 if all chars inside the parts  started from 'fromIndex' are chars given by sChars.
*/
METHOD_C int32 indexOfNoChar_Csi_StringPartJc(StringPartJc_s* thiz, CharSeqJc sChars, int32 fromWhere, ThCxt* _thCxt);

/**Returns the position of the first char other than the chars in sChars within the part,
returns -1 if all chars inside the parts are chars given by sChars.
*/
METHOD_C int32 indexOfNoChar_Cs_StringPartJc(StringPartJc_s* thiz, CharSeqJc sChars, ThCxt* _thCxt);

/**Sets the length of the current part to any char content in sChars (terminate chars). 
If a terminate char is not found, the length of the current part is set to 0.
The same result occurs, if a terminate char is found at begin of the current part.
If the difference of this behavior is important, use instead indexOfAnyChar() and test the
return value, if it is &lt; 0. 
*/
METHOD_C struct StringPartJc_t* lentoAnyChar_Csi_StringPartJc(StringPartJc_s* thiz, CharSeqJc sChars, int32 maxToTest, ThCxt* _thCxt);

/**Sets the length of the current part to any char content in sChars (terminate chars). 
If a terminate char is not found, the length of the current part is set to 0.
The same result occurs, if a terminate char is found at begin of the current part.
If the difference of this behavior is important, use instead indexOfAnyChar() and test the
return value, if it is &lt; 0. 
*/
METHOD_C struct StringPartJc_t* lentoAnyChar_Csii_StringPartJc(StringPartJc_s* thiz, CharSeqJc sChars, int32 maxToTest, int32 mode, ThCxt* _thCxt);

/**Sets the length of the current part to any terminate string given in sString. 
If a terminate string is not found, the length of the current part is set to 0.
The same result occurs, if a terminate string is found at begin of the current part.
If the difference of this behavior is important, use instead indexOfAnyChar() and test the
return value, if it is &lt; 0. 
*/
METHOD_C struct StringPartJc_t* lentoAnyString_CsYi_StringPartJc(StringPartJc_s* thiz, CharSeqJc_Y* strings, int32 maxToTest, ThCxt* _thCxt);

/**Sets the length of the current part to any terminate string given in sString. 
If a terminate string is not found, the length of the current part is set to 0.
The same result occurs, if a terminate string is found at begin of the current part.
If the difference of this behavior is important, use instead indexOfAnyChar() and test the
return value, if it is &lt; 0. 
*/
METHOD_C struct StringPartJc_t* lentoAnyString_CsYii_StringPartJc(StringPartJc_s* thiz, CharSeqJc_Y* strings, int32 maxToTest, int32 mode, ThCxt* _thCxt);

/**Sets the length of the current part to any terminate string given in sString. 
If a terminate string is not found, the length of the current part is set to 0.
The same result occurs, if a terminate string is found at begin of the current part.
If the difference of this behavior is important, use instead indexOfAnyChar() and test the
return value, if it is &lt; 0.
<br>
This method consideres the indent of the first line. In followed lines all chars are skipped 
if there are inclose in sIndentChars until the column position of the first line. 
If another char not inclosed in sIndentChars is found, than it is the beginning of this line.
If the last char in sIndentChars is a space " ", additional all spaces and tabs '\t' will be
skipped. This method is helpfull to convert indented text into a string without the indents, at example:
<pre>
. / ** This is a comment
.   * continued in a next line with indent.
.  but it is able that the user doesn't respect the indentation
.        also with to large indentation,
.   * *The second asterix should not be skipped.
</pre>
From this text passage the result is:
<pre>
.This is a comment
.continued in a next line with indent.
.but it is able that the user doesn't respect the indentation
.also with to large indentation,
.*The second asterix should not be skipped.
</pre>
Using the result it is possible to detect paragraph formatting in wikipedia style 
(see vishia.xml.ConvertWikistyleTextToXml.java) 

*/
METHOD_C void lentoAnyStringWithIndent_StringPartJc(StringPartJc_s* thiz, CharSeqJc_Y* strings, CharSeqJc sIndentChars, int32 maxToTest, struct StringBuilderJc_t* buffer, ThCxt* _thCxt);

/**Sets the length of the current part to any char content in sChars (terminate chars),
but skip over quotions while testing. Example: The given string is<pre>
abc "yxz" ende:zxy</pre>
The calling is<pre>
lentoAnyCharOutsideQuotion("xyz", 20);</pre>
The result current part is<pre>
abc "yxz" ende:</pre>
because the char 'z' is found first as the end char, but outside the quoted string "xyz".<br/>
If a terminate char is not found, the length of the current part is set to 0.
The same result occurs, if a terminate char is found at begin of the current part.
If the difference of this behavior is important, use instead indexOfAnyChar() and test the
return value, if it is &lt; 0. 
*/
METHOD_C struct StringPartJc_t* lentoAnyCharOutsideQuotion_StringPartJc(StringPartJc_s* thiz, CharSeqJc sChars, int32 maxToTest, ThCxt* _thCxt);

/**Sets the length of the current part to the end of the quotion. It is not tested here,
whether or not the actual part starts with a left quotion mark.
In Generally, a backslash skips over the next char and does not test it as end of the quotion.  
*/
METHOD_C struct StringPartJc_t* lentoQuotionEnd_StringPartJc(StringPartJc_s* thiz, char sEndQuotion, int32 maxToTest, ThCxt* _thCxt);

/**Sets the length of the current part to the end of the current line.
Note The current part is empty if the position is on end of a line yet.
*/
METHOD_C struct StringPartJc_t* lentoLineEnd_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt);

/**Increments the begin of the current part over maybe found whitespaces
and decrements the end of the current part over maybe found whitespaces.
The {@link #found()} returns false if the current part has no content.
The {@link #getCurrentPart()} returns an empty String if the current part has no content
The method invokes {@link #seekNoWhitespace()} and {@link #lenBacktoNoChar(CharSequence)} with " \t\r\n\f".
*/
METHOD_C struct StringPartJc_t* trimWhiteSpaces_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt);

/**Sets the length of the current part to any char content in sChars (terminate chars). 
If a terminate char is not found, the length of the current part is set to 0.
The same result occurs, if a terminate char is found at begin of the current part.
If the difference of this behavior is important, use instead indexOfAnyChar() and test the
return value, if it is &lt; 0. 
*/
METHOD_C struct StringPartJc_t* lentoAnyChar_Cs_StringPartJc(StringPartJc_s* thiz, CharSeqJc sChars, ThCxt* _thCxt);

/**Sets the length to the end of the maximal part if the length is 0. This method could be called at example
if a end char is not detected and for that reason the part is valid to the end.
*/
METHOD_C struct StringPartJc_t* len0end_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt);

/**Sets the length to the end of the maximal part.
*/
METHOD_C struct StringPartJc_t* setLengthMax_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt);

/**Posits the end of the part before all of the chars given in the parameter string.
The start of the part is not affected.
<pre>sample: lentoBacktoNoChar("123") result is:
1231231231abcd12312efghij123123123klmnopq
before:       ==========================
after:        =====================
</pre>
*/
METHOD_C struct StringPartJc_t* lenBacktoNoChar_StringPartJc(StringPartJc_s* thiz, CharSeqJc sChars, ThCxt* _thCxt);

/**Trims all leading and trailing whitespaces within the part.
A Comment begins with "//".
*/
METHOD_C struct StringPartJc_t* trim_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt);

/**Trims a java- or C-style line-comment from end of part and all leading and trailing whitespaces.
A Comment begins with "//".
*/
METHOD_C struct StringPartJc_t* trimComment_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt);

METHOD_C int32 compareTo_StringPartJc(StringPartJc_s* thiz, CharSeqJc str2, ThCxt* _thCxt);

/**Returns the position of the char within the part,
returns -1 if the char is not found in the part.
The methode is likely String.indexOf().
*/
METHOD_C int32 indexOf_c_StringPartJc(StringPartJc_s* thiz, char ch, ThCxt* _thCxt);

/**Returns the position of the char within the part, started inside the part with fromIndex,
returns -1 if the char is not found in the part started from 'fromIndex'.
The method is likely String.indexOf().
*/
METHOD_C int32 indexOf_ci_StringPartJc(StringPartJc_s* thiz, char ch, int32 fromIndex, ThCxt* _thCxt);

/**Returns the position of the string within the part. Returns -1 if the string is not found in the part.
Example: indexOf("abc") returns 6, indexOf("fgh") returns -1 <pre>
abcdefgabcdefghijk
part:   =============  </pre>
*/
METHOD_C int32 indexOf_Cs_StringPartJc(StringPartJc_s* thiz, CharSeqJc sCmp, ThCxt* _thCxt);

/**Returns the position of the string within the part. Returns -1 if the string is not found in the part.
Example: indexOf("abc") returns 6, indexOf("fgh") returns -1 <pre>
abcdefgabcdefghijk
part:   =============  </pre>
*/
METHOD_C int32 XXXindexOf_StringPartJc(StringPartJc_s* thiz, CharSeqJc sCmp, ThCxt* _thCxt);

/**Returns the position of the string within the part. Returns -1 if the string is not found in the part.
Example: indexOf("abc") returns 6, indexOf("fgh") returns -1 <pre>
abcdefgabcdefghijk
part:   =============  </pre>
*/
METHOD_C int32 indexOf_Csii_StringPartJc(StringPartJc_s* thiz, CharSeqJc sCmp, int32 fromIndex, int32 maxToTest, ThCxt* _thCxt);

/**Compares the Part of string with the given string
*/
METHOD_C bool equals_Cs_StringPartJc(StringPartJc_s* thiz, CharSeqJc sCmp, ThCxt* _thCxt);

/**compares the Part of string with the given string.
new since 2008-09: if sCmp contains a cEndOfText char (coded with \e), the end of text is tested.
*/
METHOD_C bool startsWith_StringPartJc(StringPartJc_s* thiz, CharSeqJc sCmp, ThCxt* _thCxt);

/**Gets the current position, useable for rewind. This method is overwritten
if derived classes uses partial content.
*/
METHOD_C int64 getCurrentPosition_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt);

/**Sets the current position at a fix position inside the maxPart.
TODO what is with rewind etc? see old StringScan.
Idea: the max Part is never enlargeable to left, only made smaller to rihht.
Thats why the left border of maxPart is useable for shift left the content
by reading the next content from file, if the buffer is limited, larger than necessarry for a
whole file's content. But all pos values should be relativ. getCurrentPos must return
a relativ value, if shiftness is used. this method shuld use a relativ value.
old:, useable for rewind. This method may be overwritten
if derived classes uses partial content.

*/
METHOD_C void setCurrentPosition_StringPartJc(StringPartJc_s* thiz, int64 pos, ThCxt* _thCxt);

/**Gets a substring inside the maximal part
pos position of start relative to maxPart
posend exclusive position of end. If 0 or negativ, it counts from end backward.
*/
METHOD_C struct Part_StringPartJc_t* substring_StringPartJc(StringPartJc_s* thiz, int32 pos, int32 posendP, ThCxt* _thCxt);

/**Gets the next chars from current Position.
This method don't consider the spread of the actutal and maximal part.
*/
METHOD_C CharSeqJc getCurrent_StringPartJc(StringPartJc_s* thiz, int32 nChars, ThCxt* _thCxt);

/**Gets the next char at current Position.
*/
METHOD_C char getCurrentChar_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt);

/**Get the Line number and the column of the begin position. 
Note: it returns null in this class, may be overridden.
*/
typedef int32 MT_getLineAndColumn_StringPartJc(StringPartJc_s* thiz, int32_Y* column, ThCxt* _thCxt);
/* J2C:Implementation of the method, used for an immediate non-dynamic call: */
METHOD_C int32 getLineAndColumn_StringPartJc_F(StringPartJc_s* thiz, int32_Y* column, ThCxt* _thCxt);
/* J2C:Call of the method at this class level, executes a dynamic call of the override-able method: */
METHOD_C int32 getLineAndColumn_StringPartJc(StringPartJc_s* thiz, int32_Y* column, ThCxt* _thCxt);

/**Gets the current position in line (column of the text).
It is the number of chars from the last '\n' or from beginning to the actual char.
*/
METHOD_C int32 getCurrentColumn_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt);

/**This method may be overridden to return the file which is used to build this Stringpart.
*/
METHOD_C StringJc getInputfile_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt);

/**Returns the actual part of the string.

*/
METHOD_C struct Part_StringPartJc_t* getCurrentPart_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt);


/**Sets the actual part of the string.
* 
*/
void setCurrentPart_StringPartJc  ( StringPartJc_s* thiz, struct Part_StringPartJc_t* dst, ThCxt* _thCxt);


/**Returns the last part of the string before any seek or scan operation.

*/
METHOD_C CharSeqJc getLastPart_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt);

/**Returns the actual part of the string.
*/
METHOD_C CharSeqJc getCurrentPart_i_StringPartJc(StringPartJc_s* thiz, int32 maxLength, ThCxt* _thCxt);

/**Retrurn the part from start to end independent of the current positions. 
This method is proper to get an older part for example to log a text afterwards the text is processed.
Store the {@link #getCurrentPosition()} and {@link #getLen()} and apply it here!
Note that it is possible that an older part of string is not available furthermore if a less buffer is used
and the string in the buffer was shifted out. Then this method may be overridden and returns an error hint.
*/
METHOD_C struct Part_StringPartJc_t* getPart_StringPartJc(StringPartJc_s* thiz, int32 fromPos, int32 nrofChars, ThCxt* _thCxt);

METHOD_C char absCharAt_StringPartJc(StringPartJc_s const* thiz, int32 index, ThCxt* _thCxt);

/**Returns a String from absolute range.
*/
METHOD_C StringJc absSubString_StringPartJc(StringPartJc_s* thiz, int32 from, int32 to, ThCxt* _thCxt);

/* J2C:Implementation of the method, used for an immediate non-dynamic call: */
METHOD_C StringJc toString_StringPartJc_F(ObjectJc* ithis, ThCxt* _thCxt);
/* J2C:Call of the method at this class level, executes a dynamic call of the override-able method: */
METHOD_C StringJc toString_StringPartJc(ObjectJc* ithis, ThCxt* _thCxt);

/**Returns a debug information of the content of the StringPart. This information is structured in the followed way:
<pre>"CONTENT_FROM_BEGIN<<<34,45>>>CONTENT_PART<<<"</pre>
whereat
<ul>
<li>CONTENT_FROM_BEGIN are the first 20 chars of the whole content</li>
<li>34 in this sample is the start position</li>
<li>45 in this sample is the exclusively end position</li>
<li>CONTENT_PART are the first 20 chars from start position</li>
<ul>
*/
METHOD_C StringJc debugString_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt);

/**Central mehtod to invoke excpetion, usefull to set a breakpoint in debug
or to add some standard informations.
*/
METHOD_C void throwIndexOutOfBoundsException_StringPartJc(StringPartJc_s* thiz, StringJc sMsg, ThCxt* _thCxt);

METHOD_C void throwIllegalArgumentException_StringPartJc(/*J2C:static method*/ StringJc msg, int32 value, ThCxt* _thCxt);

/**Closes the work. This routine should be called if the StringPart is never used, 
but it may be kept because it is part of class data or part of a statement block which runs.
The associated String is released. It can be recycled by garbage collector.
If this method is overridden, it should used to close a associated file which is opened 
for this String processing. The overridden method should call super->close() too.
<br>
Note: if only this class is instantiated and the instance will be garbaged, close is not necessary.
A warning or error "Resource leak" can be switched off. Therefore the interface {@link java.io.Closeable} is not used here.
*/
typedef void MT_close_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt);
/* J2C:Implementation of the method, used for an immediate non-dynamic call: */
METHOD_C void close_StringPartJc_F(StringPartJc_s* thiz, ThCxt* _thCxt);
/* J2C:Call of the method at this class level, executes a dynamic call of the override-able method: */
METHOD_C void close_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt);

/**Replaces up to 20 placeholder with a given content.
The method creates a StringBuilder with buffer and a StringPart locally. 
*/
METHOD_C CharSeqJc replace_StringPartJc(/*J2C:static method*/ CharSeqJc src, CharSeqJc_Y* placeholder, CharSeqJc_Y* value, struct StringBuilderJc_t* dst, ThCxt* _thCxt);


/* J2C: Method table contains all dynamic linked (virtual) methods
 * of the class and all super classes and interfaces. */
 extern const char sign_Vtbl_StringPartJc[]; //marker for methodTable check
typedef struct Vtbl_StringPartJc_t
{ VtblHeadJc head;
  MT_getLineAndColumn_StringPartJc* getLineAndColumn;
  MT_close_StringPartJc* close;
  Vtbl_ObjectJc ObjectJc;
  //Method table of interfaces:
  Vtbl_CharSeqJc CharSeqJc;
  Vtbl_ComparableJc ComparableJc;
} Vtbl_StringPartJc;



#if defined(__CPLUSPLUSJcpp) && defined(__cplusplus)
/* J2C: The C++-class-definition. */
class StringPartJc : public StringPartJc_s
{ public:

  int32 XXXindexOf(CharSeqJc sCmp){  return XXXindexOf_StringPartJc(this, sCmp,  null/*_thCxt*/); }

  char absCharAt(int32 index){  return absCharAt_StringPartJc(static_cast<StringPartJc_s*>(this), index,  null/*_thCxt*/); }

  StringJc absSubString(int32 from, int32 to){  return absSubString_StringPartJc(this, from, to,  null/*_thCxt*/); }

  StringPartJc& assignFromEnd(struct StringPartJc_t* src){ assignFromEnd_StringPartJc(this, src,  null/*_thCxt*/);  return *this; }

  StringPartJc& assignReplaceEnv(struct StringBuilderJc_t* input){ assignReplaceEnv_StringPartJc(this, input,  null/*_thCxt*/);  return *this; }

  StringPartJc& assign(CharSeqJc ref){ assign_Cs_StringPartJc(this, ref,  null/*_thCxt*/);  return *this; }

  StringPartJc& assign(struct StringPartJc_t* src){ assign_XX_StringPartJc(this, src,  null/*_thCxt*/);  return *this; }

  char charAt(int32 index){  return charAt_i_StringPartJc(&this->base.object.base.object, index,  null/*_thCxt*/); }

  bool checkCharAt(int32 pos, StringJcpp chars){  return checkCharAt_StringPartJc(this, pos, chars,  null/*_thCxt*/); }

  virtual void close(){ close_StringPartJc_F(this,  null/*_thCxt*/); }

  int32 compareTo(CharSeqJc str2){  return compareTo_StringPartJc(this, str2,  null/*_thCxt*/); }

  StringPartJc(CharSeqJc src){ init_ObjectJc(&this->base.object, sizeof(StringPartJc_s), 0); setReflection_ObjectJc(&this->base.object, &refl_StringPartJc_s, 0); ctorO_Cs_StringPartJc(&this->base.object, src,  null/*_thCxt*/); }

  StringPartJc(CharSeqJc src, int32 start, int32 end){ init_ObjectJc(&this->base.object, sizeof(StringPartJc_s), 0); setReflection_ObjectJc(&this->base.object, &refl_StringPartJc_s, 0); ctorO_Csii_StringPartJc(&this->base.object, src, start, end,  null/*_thCxt*/); }

  StringPartJc(){ init_ObjectJc(&this->base.object, sizeof(StringPartJc_s), 0); setReflection_ObjectJc(&this->base.object, &refl_StringPartJc_s, 0); ctorO_StringPartJc(&this->base.object,  null/*_thCxt*/); }

  StringJc debugString(){  return debugString_StringPartJc(this,  null/*_thCxt*/); }

  bool equals(CharSeqJc sCmp){  return equals_Cs_StringPartJc(this, sCmp,  null/*_thCxt*/); }

  StringPartJc& firstlineMaxpart(){ firstlineMaxpart_StringPartJc(this,  null/*_thCxt*/);  return *this; }

  bool found(){  return found_StringPartJc(this,  null/*_thCxt*/); }

  StringPartJc& fromEnd(){ fromEnd_StringPartJc(this);  return *this; }

  char getCurrentChar(){  return getCurrentChar_StringPartJc(this,  null/*_thCxt*/); }

  int32 getCurrentColumn(){  return getCurrentColumn_StringPartJc(this,  null/*_thCxt*/); }

  struct Part_StringPartJc_t* getCurrentPart(){  return getCurrentPart_StringPartJc(this,  null/*_thCxt*/); }

  CharSeqJc getCurrentPart(int32 maxLength){  return getCurrentPart_i_StringPartJc(this, maxLength,  null/*_thCxt*/); }

  int64 getCurrentPosition(){  return getCurrentPosition_StringPartJc(this,  null/*_thCxt*/); }

  CharSeqJc getCurrent(int32 nChars){  return getCurrent_StringPartJc(this, nChars,  null/*_thCxt*/); }

  StringJc getInputfile(){  return getInputfile_StringPartJc(this,  null/*_thCxt*/); }

  CharSeqJc getLastPart(){  return getLastPart_StringPartJc(this,  null/*_thCxt*/); }

  virtual int32 getLineAndColumn(int32_Y* column){  return getLineAndColumn_StringPartJc_F(this, column,  null/*_thCxt*/); }

  struct Part_StringPartJc_t* getPart(int32 fromPos, int32 nrofChars){  return getPart_StringPartJc(this, fromPos, nrofChars,  null/*_thCxt*/); }

  int32 indexEndOfQuotation(char cEndQuotion, char transcriptChar, int32 fromWhere, int32 maxToTest){  return indexEndOfQuotation_StringPartJc(this, cEndQuotion, transcriptChar, fromWhere, maxToTest,  null/*_thCxt*/); }

  int32 indexEndOfQuotion(char cEndQuotion, int32 fromWhere, int32 maxToTest){  return indexEndOfQuotion_StringPartJc(this, cEndQuotion, fromWhere, maxToTest,  null/*_thCxt*/); }

  int32 indexOfAnyCharOutsideQuotion(CharSeqJc sChars, int32 fromWhere, int32 maxToTest){  return indexOfAnyCharOutsideQuotion_StringPartJc(this, sChars, fromWhere, maxToTest,  null/*_thCxt*/); }

  int32 indexOfAnyChar(CharSeqJc sChars){  return indexOfAnyChar_Cs_StringPartJc(this, sChars,  null/*_thCxt*/); }

  int32 indexOfAnyChar(CharSeqJc sChars, int32 fromWhere, int32 maxToTest){  return indexOfAnyChar_Csii_StringPartJc(this, sChars, fromWhere, maxToTest,  null/*_thCxt*/); }

  int32 indexOfAnyChar(CharSeqJc sChars, int32 fromWhere, int32 maxToTest, char transcriptChar, char quotationStartChar, char quotationEndChar){  return indexOfAnyChar_Csiiccc_StringPartJc(this, sChars, fromWhere, maxToTest, transcriptChar, quotationStartChar, quotationEndChar,  null/*_thCxt*/); }

  int32 indexOfAnyString(CharSeqJc_Y* listStrings, int32 fromWhere, int32 maxToTest, int32* nrofFoundString, StringJc* foundString){  return indexOfAnyString_StringPartJc(this, listStrings, fromWhere, maxToTest, nrofFoundString, foundString,  null/*_thCxt*/); }

  int32 indexOfNoChar(CharSeqJc sChars){  return indexOfNoChar_Cs_StringPartJc(this, sChars,  null/*_thCxt*/); }

  int32 indexOfNoChar(CharSeqJc sChars, int32 fromWhere){  return indexOfNoChar_Csi_StringPartJc(this, sChars, fromWhere,  null/*_thCxt*/); }

  int32 indexOf(CharSeqJc sCmp){  return indexOf_Cs_StringPartJc(this, sCmp,  null/*_thCxt*/); }

  int32 indexOf(CharSeqJc sCmp, int32 fromIndex, int32 maxToTest){  return indexOf_Csii_StringPartJc(this, sCmp, fromIndex, maxToTest,  null/*_thCxt*/); }

  int32 indexOf(char ch){  return indexOf_c_StringPartJc(this, ch,  null/*_thCxt*/); }

  int32 indexOf(char ch, int32 fromIndex){  return indexOf_ci_StringPartJc(this, ch, fromIndex,  null/*_thCxt*/); }

  int32 lastIndexOfAnyChar(CharSeqJc sChars, int32 fromWhere, int32 maxToTest){  return lastIndexOfAnyChar_StringPartJc(this, sChars, fromWhere, maxToTest,  null/*_thCxt*/); }

  StringPartJc& len0end(){ len0end_StringPartJc(this,  null/*_thCxt*/);  return *this; }

  StringPartJc& lenBacktoNoChar(CharSeqJc sChars){ lenBacktoNoChar_StringPartJc(this, sChars,  null/*_thCxt*/);  return *this; }

  int32 lengthMaxPart(){  return lengthMaxPart_StringPartJc(this); }

  int32 length(){  return length_StringPartJc(&this->base.object.base.object,  null/*_thCxt*/); }

  StringPartJc& lentoAnyCharOutsideQuotion(CharSeqJc sChars, int32 maxToTest){ lentoAnyCharOutsideQuotion_StringPartJc(this, sChars, maxToTest,  null/*_thCxt*/);  return *this; }

  StringPartJc& lentoAnyChar(CharSeqJc sChars){ lentoAnyChar_Cs_StringPartJc(this, sChars,  null/*_thCxt*/);  return *this; }

  StringPartJc& lentoAnyChar(CharSeqJc sChars, int32 maxToTest){ lentoAnyChar_Csi_StringPartJc(this, sChars, maxToTest,  null/*_thCxt*/);  return *this; }

  StringPartJc& lentoAnyChar(CharSeqJc sChars, int32 maxToTest, int32 mode){ lentoAnyChar_Csii_StringPartJc(this, sChars, maxToTest, mode,  null/*_thCxt*/);  return *this; }

  StringPartJc& lentoAnyNonEscapedChar(CharSeqJc sCharsEnd, int32 maxToTest){ lentoAnyNonEscapedChar_StringPartJc(this, sCharsEnd, maxToTest,  null/*_thCxt*/);  return *this; }

  void lentoAnyStringWithIndent(CharSeqJc_Y* strings, CharSeqJc sIndentChars, int32 maxToTest, struct StringBuilderJc_t* buffer){ lentoAnyStringWithIndent_StringPartJc(this, strings, sIndentChars, maxToTest, buffer,  null/*_thCxt*/); }

  StringPartJc& lentoAnyString(CharSeqJc_Y* strings, int32 maxToTest){ lentoAnyString_CsYi_StringPartJc(this, strings, maxToTest,  null/*_thCxt*/);  return *this; }

  StringPartJc& lentoAnyString(CharSeqJc_Y* strings, int32 maxToTest, int32 mode){ lentoAnyString_CsYii_StringPartJc(this, strings, maxToTest, mode,  null/*_thCxt*/);  return *this; }

  StringPartJc& lentoIdentifier(CharSeqJc additionalStartChars, CharSeqJc additionalChars){ lentoIdentifier_CsCs_StringPartJc(this, additionalStartChars, additionalChars,  null/*_thCxt*/);  return *this; }

  StringPartJc& lentoIdentifier(){ lentoIdentifier_StringPartJc(this,  null/*_thCxt*/);  return *this; }

  StringPartJc& lentoLineEnd(){ lentoLineEnd_StringPartJc(this,  null/*_thCxt*/);  return *this; }

  StringPartJc& lentoNonEscapedString(CharSeqJc sEnd, int32 maxToTest){ lentoNonEscapedString_StringPartJc(this, sEnd, maxToTest,  null/*_thCxt*/);  return *this; }

  StringPartJc& lentoPos(int32 len){ lentoPos_StringPartJc(this, len,  null/*_thCxt*/);  return *this; }

  StringPartJc& lentoQuotionEnd(char sEndQuotion, int32 maxToTest){ lentoQuotionEnd_StringPartJc(this, sEndQuotion, maxToTest,  null/*_thCxt*/);  return *this; }

  StringPartJc& lento(CharSeqJc ss){ lento_Cs_StringPartJc(this, ss,  null/*_thCxt*/);  return *this; }

  StringPartJc& lento(CharSeqJc ss, int32 mode){ lento_Csi_StringPartJc(this, ss, mode,  null/*_thCxt*/);  return *this; }

  StringPartJc& lento(char cc){ lento_c_StringPartJc(this, cc,  null/*_thCxt*/);  return *this; }

  StringPartJc& lento(int32 len){ lento_i_StringPartJc(this, len);  return *this; }

  struct StringPartJc_t* line(){  return line_StringPartJc(this,  null/*_thCxt*/); }

  StringPartJc& nextlineMaxpart(){ nextlineMaxpart_StringPartJc(this,  null/*_thCxt*/);  return *this; }

  CharSeqJc replace(CharSeqJc src, CharSeqJc_Y* placeholder, CharSeqJc_Y* value, struct StringBuilderJc_t* dst){  return replace_StringPartJc(src, placeholder, value, dst,  null/*_thCxt*/); }

  struct StringPartJc_t* seekAnyChar(CharSeqJc chars){  return seekAnyChar_StringPartJc(this, chars,  null/*_thCxt*/); }

  StringPartJc& seekAnyString(CharSeqJc_Y* strings, int32* nrofFoundString){ seekAnyString_StringPartJc(this, strings, nrofFoundString,  null/*_thCxt*/);  return *this; }

  struct StringPartJc_t* seekBackToAnyChar(CharSeqJc chars){  return seekBackToAnyChar_StringPartJc(this, chars,  null/*_thCxt*/); }

  StringPartJc& seekBackward(CharSeqJc sSeek){ seekBackward_StringPartJc(this, sSeek,  null/*_thCxt*/);  return *this; }

  StringPartJc& seekBegin(){ seekBegin_StringPartJc(this,  null/*_thCxt*/);  return *this; }

  struct StringPartJc_t* seekNextLine(){  return seekNextLine_StringPartJc(this,  null/*_thCxt*/); }

  StringPartJc& seekNoChar(CharSeqJc sChars){ seekNoChar_StringPartJc(this, sChars,  null/*_thCxt*/);  return *this; }

  StringPartJc& seekNoWhitespaceOrComments(){ seekNoWhitespaceOrComments_StringPartJc(this,  null/*_thCxt*/);  return *this; }

  StringPartJc& seekNoWhitespace(){ seekNoWhitespace_StringPartJc(this,  null/*_thCxt*/);  return *this; }

  struct StringPartJc_t* seekPosBack(int32 nr){  return seekPosBack_StringPartJc(this, nr,  null/*_thCxt*/); }

  struct StringPartJc_t* seekPos(int32 nr){  return seekPos_StringPartJc(this, nr,  null/*_thCxt*/); }

  struct StringPartJc_t* seek(CharSeqJc sSeek){  return seek_Cs_StringPartJc(this, sSeek); }

  StringPartJc& seek(CharSeqJc sSeek, int32 mode){ seek_Csi_StringPartJc(this, sSeek, mode,  null/*_thCxt*/);  return *this; }

  StringPartJc& seek(char cSeek, int32 mode){ seek_ci_StringPartJc(this, cSeek, mode,  null/*_thCxt*/);  return *this; }

  StringPartJc& seek(int32 nr){ seek_i_StringPartJc(this, nr,  null/*_thCxt*/);  return *this; }

  StringPartJc& setBeginMaxPart(){ setBeginMaxPart_StringPartJc(this);  return *this; }

  void setCurrentPosition(int64 pos){ setCurrentPosition_StringPartJc(this, pos,  null/*_thCxt*/); }

  bool setIgnoreComment(StringJcpp sStart, StringJcpp sEnd){  return setIgnoreComment_SS_StringPartJc(this, sStart, sEnd,  null/*_thCxt*/); }

  bool setIgnoreComment(bool bSet){  return setIgnoreComment_b_StringPartJc(this, bSet,  null/*_thCxt*/); }

  bool setIgnoreEndlineComment(StringJcpp sStart){  return setIgnoreEndlineComment_S_StringPartJc(this, sStart,  null/*_thCxt*/); }

  bool setIgnoreEndlineComment(bool bSet){  return setIgnoreEndlineComment_b_StringPartJc(this, bSet,  null/*_thCxt*/); }

  bool setIgnoreWhitespaces(bool bSet){  return setIgnoreWhitespaces_StringPartJc(this, bSet,  null/*_thCxt*/); }

  void setInputfile(StringJcpp file){ setInputfile_StringPartJc(this, file,  null/*_thCxt*/); }

  StringPartJc& setLengthMax(){ setLengthMax_StringPartJc(this,  null/*_thCxt*/);  return *this; }

  StringPartJc& setParttoMax(){ setParttoMax_StringPartJc(this,  null/*_thCxt*/);  return *this; }

  struct StringPartJc_t* skipWhitespaceAndComment(){  return skipWhitespaceAndComment_StringPartJc(this,  null/*_thCxt*/); }

  bool startsWith(CharSeqJc sCmp){  return startsWith_StringPartJc(this, sCmp,  null/*_thCxt*/); }

  CharSeqJc subSequence(int32 from, int32 to){  return subSequence_ii_StringPartJc(&this->base.object.base.object, from, to,  null/*_thCxt*/); }

  struct Part_StringPartJc_t* substring(int32 pos, int32 posendP){  return substring_StringPartJc(this, pos, posendP,  null/*_thCxt*/); }

  void throwIllegalArgumentException(StringJcpp msg, int32 value){ throwIllegalArgumentException_StringPartJc(msg, value,  null/*_thCxt*/); }

  void throwIndexOutOfBoundsException(StringJcpp sMsg){ throwIndexOutOfBoundsException_StringPartJc(this, sMsg,  null/*_thCxt*/); }

  void throwSubSeqFaulty(int32 from, int32 to){ throwSubSeqFaulty_StringPartJc(this, from, to,  null/*_thCxt*/); }

  virtual StringJc toString(){  return toString_StringPartJc_F(&this->base.object,  null/*_thCxt*/); }

  StringPartJc& trimComment(){ trimComment_StringPartJc(this,  null/*_thCxt*/);  return *this; }

  StringPartJc& trimWhiteSpaces(){ trimWhiteSpaces_StringPartJc(this,  null/*_thCxt*/);  return *this; }

  StringPartJc& trim(){ trim_StringPartJc(this,  null/*_thCxt*/);  return *this; }
};

#endif /*__CPLUSPLUSJcpp*/

#endif //__J1c_StringPartJc_h__
