/**************************************************************************
 * This file is generated by Java2C
 **copyright***************************************************************
 *************************************************************************/
#include <applstdef_emC.h>
#if defined(DEF_ObjectJcpp_REFLECTION) && ! defined(DEF_NO_StringUSAGE)  //only possible with reflection because Vtable is need


#include "emC/J1c/StringFunctionsJc.h"
#include <string.h>  //because using memset()
#include <emC/Jc/ReflectionJc.h>   //Reflection concept 
  //basic stacktrace concept
//#include "Jc/MathJc.h"  //reference-association: MathJc_s
#include "emC/Jc/ObjectJc.h"  //reference-association: IntegerJc
#include "emC/Jc/StringJc.h"  //embedded type in class data


/* J2C: Forward declaration of struct ***********************************************/

/**This class contains static String functions without any other dependency. 
In C the functions are contained in the emC/String.c.
@author Hartmut Schorrig

*/


const char sign_Vtbl_StringFunctionsJc[] = "StringFunctionsJc"; //to mark method tables of all implementations

#ifdef DEF_ClassJc_Vtbl
typedef struct VtblDef_StringFunctionsJc_t { Vtbl_StringFunctionsJc mtbl; VtblHeadJc end; } VtblDef_StringFunctionsJc;
 extern VtblDef_StringFunctionsJc const mtblStringFunctionsJc;
#endif //#ifdef DEF_ClassJc_Vtbl


StringJc version_StringFunctionsJc = CONST_z_StringJc("2016-12-02"); //J2C:static StringJc
const char cEndOfText_StringFunctionsJc = (char /*J2C_cast*/)(0x3);
const char cStartOfText_StringFunctionsJc = (char /*J2C_cast*/)(0x2);
const char cNoCidentifier_StringFunctionsJc = (char /*J2C_cast*/)(0x4);
StringJc indentString_StringFunctionsJc = CONST_z_StringJc("\n                                                                                                    "); //J2C:static StringJc

/*Constructor *//**J2C: autogenerated as default constructor. */
struct StringFunctionsJc_t* ctorO_StringFunctionsJc(ObjectJc* othis, ThCxt* _thCxt)
{ StringFunctionsJc_s* thiz = (StringFunctionsJc_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_StringFunctionsJc");
  checkConsistence_ObjectJc(othis, sizeof(StringFunctionsJc_s), null, _thCxt);  
  //TODO setReflection_ObjectJc(othis, &refl_StringFunctionsJc_s, sizeof(StringFunctionsJc_s));
  //j2c: Initialize all class variables:
  {
  }/*J2C:No body for constructor*/

  STACKTRC_LEAVE;
  return thiz;
}


int32 indexWhitespace_StringFunctionsJc(/*J2C:static method*/ CharSeqJc src, int32 start, int32 endMax, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexWhitespace_StringFunctionsJc");
  
  { 
    
    
    int32  pos = start;
    
    int32  end = length_CharSeqJc(src/*J1cT2*/, _thCxt);
    if(endMax > 0 && endMax < end) 
    { 
      
      end = endMax;
    }
    
    char  cc;/*no initvalue*/
    
    while(pos < end && (cc = /*? assignment*/charAt_CharSeqJc(src/*J1cT2*/, pos, _thCxt)) != ' ' && cc != '\r' && cc != '\n' && cc != '\t' && cc != '\f')
      { 
        
        pos += 1;
      }
    { STACKTRC_LEAVE;
      return pos;
    }
  }
  STACKTRC_LEAVE;
}

int32 indexNoWhitespace_StringFunctionsJc(/*J2C:static method*/ CharSeqJc src, int32 start, int32 endMax, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexNoWhitespace_StringFunctionsJc");
  
  { 
    
    
    int32  pos = start;
    
    int32  end = length_CharSeqJc(src/*J1cT2*/, _thCxt);
    if(endMax > 0 && endMax < end) 
    { 
      
      end = endMax;
    }
    
    char  cc;/*no initvalue*/
    
    while(pos < end && ((cc = /*? assignment*/charAt_CharSeqJc(src/*J1cT2*/, pos, _thCxt)) == ' ' || cc == '\r' || cc == '\n' || cc == '\t' || cc == '\f'))
      { 
        
        pos += 1;
      }
    { STACKTRC_LEAVE;
      return pos;
    }
  }
  STACKTRC_LEAVE;
}


/**Searches the position of the first identifier character starting from the given position.*/
int32 indexIdentifier_StringFunctionsJc(/*J2C:static method*/ CharSeqJc src, int32 start, int32 endMax, StringJc additionalStartChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexIdentifier_StringFunctionsJc");
  
  { 
    
    
    int32  pos = start;
    
    int32  end = length_CharSeqJc(src/*J1cT2*/, _thCxt);
    if(endMax > 0 && endMax < end) 
    { 
      
      end = endMax;
    }
    
    char  cc;/*no initvalue*/
    
    while(pos < end && (cc = /*? assignment*/charAt_CharSeqJc(src/*J1cT2*/, pos, _thCxt)) != '_' && (cc < 'A' || cc > 'Z') && (cc < 'a' || cc > 'z') && (additionalStartChars.addr.str== null || indexOf_C_StringJc(additionalStartChars, cc) < 0))
      { 
        
        pos += 1;
      }
    { STACKTRC_LEAVE;
      return pos < end ? pos : -1;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the position after the end of an identifier.*/
int32 indexAfterIdentifier_StringFunctionsJc(/*J2C:static method*/ CharSeqJc src, int32 start, int32 endMax, StringJc additionalChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexAfterIdentifier_StringFunctionsJc");
  
  { 
    
    
    int32  pos = start;
    
    int32  end = length_CharSeqJc(src/*J1cT2*/, _thCxt);
    if(endMax > 0 && endMax < end) 
    { 
      
      end = endMax;
    }
    
    char  cc;/*no initvalue*/
    
    while(pos < end && ((cc = /*? assignment*/charAt_CharSeqJc(src/*J1cT2*/, pos, _thCxt)) == '_' || (cc >= '0' && cc <= '9') || (cc >= 'A' && cc <= 'Z') || (cc >= 'a' && cc <= 'z') || (additionalChars.addr.str!= null && indexOf_C_StringJc(additionalChars, cc) >= 0)))
      { 
        
        pos += 1;
      }
    { STACKTRC_LEAVE;
      return pos;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the position of the end of an identifier.*/
int32 posAfterIdentifier_CsiiSS_StringFunctionsJc(/*J2C:static method*/ CharSeqJc src, int32 start, int32 endMax, StringJc additionalStartChars, StringJc additionalChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("posAfterIdentifier_CsiiSS_StringFunctionsJc");
  
  { 
    
    
    int32  pos = start;
    
    char  cc = charAt_CharSeqJc(src/*J1cT2*/, pos, _thCxt);
    if(cc == '_' || (cc >= 'A' && cc <= 'Z') || (cc >= 'a' && cc <= 'z') || (additionalStartChars.addr.str!= null && indexOf_C_StringJc(additionalStartChars, cc) >= 0)) 
    { 
      
      pos += 1;
      
      while(pos < endMax && ((cc = /*? assignment*/charAt_CharSeqJc(src/*J1cT2*/, pos, _thCxt)) == '_' || (cc >= '0' && cc <= '9') || (cc >= 'A' && cc <= 'Z') || (cc >= 'a' && cc <= 'z') || (additionalChars.addr.str!= null && indexOf_C_StringJc(additionalChars, cc) >= 0)))
        { 
          
          pos += 1;
        }
    }
    { STACKTRC_LEAVE;
      return pos;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the position of the end of an identifier.*/
int32 posAfterIdentifier_Csii_StringFunctionsJc(/*J2C:static method*/ CharSeqJc src, int32 start, int32 endMax, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("posAfterIdentifier_Csii_StringFunctionsJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return posAfterIdentifier_CsiiSS_StringFunctionsJc(/*J2C:static method call*/src, start, endMax, null_StringJc /*J2C: mem assignment*/, null_StringJc /*J2C: mem assignment*/, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Compares two CharSequence (Strings, StringBuilder-content etc.*/
int32 comparePos_CsCs_StringFunctionsJc(/*J2C:static method*/ CharSeqJc s1, CharSeqJc s2, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("comparePos_CsCs_StringFunctionsJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return comparePos_CsiCsii_StringFunctionsJc(/*J2C:static method call*/s1, 0, s2, 0, -1, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Compares two CharSequence (Strings, StringBuilder-content etc.)*/
int32 comparePos_CsiCsii_StringFunctionsJc(/*J2C:static method*/ CharSeqJc s1, int32 from1, CharSeqJc s2, int32 from2, int32 nrofChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("comparePos_CsiCsii_StringFunctionsJc");
  
  { 
    
    
    int32  i1 = from1;
    
    int32  i2 = from2;
    
    int32  z1 = length_CharSeqJc(s1/*J1cT2*/, _thCxt);
    
    int32  z2 = length_CharSeqJc(s2/*J1cT2*/, _thCxt);
    if(nrofChars == 0) { STACKTRC_LEAVE;
      return 0;
    }/*NOTE: following while compares at least one char*/
    
    
    int32  zChars = nrofChars >= 0 ? MIN_emC(/*J2C:static method call*/nrofChars, MIN_emC(/*J2C:static method call*/z1 - i1, z2 - i2)) : MIN_emC(/*J2C:static method call*/z1 - i1, z2 - i2);
    
    char  c1;/*no initvalue*/
    
    char  c2;/*no initvalue*/
    do 
      { 
        
        c1 = charAt_CharSeqJc(s1/*J1cT2*/, i1++, _thCxt);
        c2 = charAt_CharSeqJc(s2/*J1cT2*/, i2++, _thCxt);
      }while(c1 == c2 && --zChars > 0);
    if(zChars == 0) 
    { /*:all characters compared, maybe difference in length.*/
      
      
      if(i2 < z2) { STACKTRC_LEAVE;
        return -(i1 - from1 + 1);
      }/*s2 is longer, s1 is less.*/
      
      else if(i1 < z1) { STACKTRC_LEAVE;
        return i1 - from1 + 1;
      }/*positive value: s1 is greater because i1 < z2, is longer and c1==c2 */
      
      else { STACKTRC_LEAVE;
        return 0;
      }/*both equal, comparison to end. */
      
    }
    else 
    { /*:not all possible characters compared, difference in character*/
      
      
      if(c1 < c2) { STACKTRC_LEAVE;
        return -(i1 - from1);
      }/*c1 !=c2, then compare the last characters. <0 because s1 is lesser.*/
      
      else { STACKTRC_LEAVE;
        return (i1 - from1);
      }/*note: == i2 - from2, s2 is lesser.*/
      
    }
  }
  STACKTRC_LEAVE;
}

bool test_StringFunctionsJc_F(StringFunctionsJc_s* thiz, StringJc s, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("test_StringFunctionsJc_F");
  
  { 
    
    if(s.addr.str == null) { STACKTRC_LEAVE;
      return false;
    }
    else { STACKTRC_LEAVE;
      return true;
    }
  }
  STACKTRC_LEAVE;
}

#ifdef DEF_ClassJc_Vtbl
/*J2C: dynamic call variant of the override-able method: */
bool test_StringFunctionsJc(StringFunctionsJc_s* thiz, StringJc s, ThCxt* _thCxt)
{ Vtbl_StringFunctionsJc const* mtbl = (Vtbl_StringFunctionsJc const*)getVtbl_ObjectJc(&thiz->base.object, sign_Vtbl_StringFunctionsJc);
  return mtbl->test(thiz, s, _thCxt);
}
#endif //#ifdef DEF_ClassJc_Vtbl


/**Compares two CharSequence (Strings, StringBuilder-content etc.*/
int32 compare_CsiCsii_StringFunctionsJc(/*J2C:static method*/ CharSeqJc s1, int32 from1, CharSeqJc s2, int32 from2, int32 nrofChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("compare_CsiCsii_StringFunctionsJc");
  
  { 
    
    
    int32  i1 = from1 - 1;
    
    int32  i2 = from2 - 1;
    
    int32  z = nrofChars + from1;
    
    int32  returnEq = 0;
    if(s1.addr.str == null) 
    { 
      
      { STACKTRC_LEAVE;
        return s2.addr.str == null ? 0 : -1;
      }
    }/*equal if both are null*/
    
    else if(s2.addr.str == null) 
    { 
      
      { STACKTRC_LEAVE;
        return 1;
      }
    }/*s1 is greater.*/
    /**/
    
    if(z > length_CharSeqJc(s1/*J1cT2*/, _thCxt)) 
    { 
      
      z = length_CharSeqJc(s1/*J1cT2*/, _thCxt);
      
      int32  nrofChars1 = z - from1;
      
      int32  z2 = from2 + nrofChars1;
      if(z2 == length_CharSeqJc(s2/*J1cT2*/, _thCxt)) 
      { 
        
        returnEq = 0;
      }/*both have the same length after shorten.*/
      
      else if(z2 > length_CharSeqJc(s2/*J1cT2*/, _thCxt)) 
      { 
        
        
        int32  nrofChars2 = length_CharSeqJc(s2/*J1cT2*/, _thCxt) - from2;
        z = from1 + nrofChars2;/*reduce length because s2*/
        
        returnEq = 1;/*returns 1 if equal because s2 is shorter*/
        
      }
      else 
      { 
        
        returnEq = -1;
      }/*returns -1 if equal because s1 is shorter*/
      
    }
    else if((from2 + nrofChars) > length_CharSeqJc(s2/*J1cT2*/, _thCxt)) 
    { /*:s2 is shorter than the requested or adjusted length:*/
      
      
      z = (length_CharSeqJc(s2/*J1cT2*/, _thCxt) - from2) + from1;
      returnEq = 1;/*returns 1 if equal because s2 is shorter*/
      
    }
    
    while(++i1 < z)
      { 
        
        
        char  c1 = charAt_CharSeqJc(s1/*J1cT2*/, i1, _thCxt);
        
        char  c2 = charAt_CharSeqJc(s2/*J1cT2*/, ++i2, _thCxt);
        if(c1 != c2) 
        { 
          
          if(c1 < c2) 
          { 
            
            { STACKTRC_LEAVE;
            return -1;
          }
          }
          else if(c1 > c2) 
          { 
            
            { STACKTRC_LEAVE;
            return 1;
          }
          }
        }
      }/*all chars till z are equal.*/
      
    { STACKTRC_LEAVE;
      return returnEq;
    }
  }
  STACKTRC_LEAVE;
}


/**Compares two Strings or StringBuilder-content or any other CharSequence.*/
int32 compare_CsCs_StringFunctionsJc(/*J2C:static method*/ CharSeqJc s1, CharSeqJc s2, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("compare_CsCs_StringFunctionsJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return compare_CsiCsii_StringFunctionsJc(/*J2C:static method call*/s1, 0, s2, 0, MAX_VALUE_IntegerJc, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Compares two charsequences. It is similar String.equals(String), but works with CharSequence and accepts null-pointer.*/
bool equals_CsiiCs_StringFunctionsJc(/*J2C:static method*/ CharSeqJc s1, int32 from, int32 to, CharSeqJc s2, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("equals_CsiiCs_StringFunctionsJc");
  
  { /*:Test possibility:*/
    /*:if((s1 instanceof StringSeq) && contains(((StringSeq)s1)s, "hide"))*/
    /*:  Debugutil.stop();*/
    
    
    
    int32  z1 = length_CharSeqJc(s1/*J1cT2*/, _thCxt);
    if(s1.addr.str == null || s2.addr.str == null) 
    { 
      
      { STACKTRC_LEAVE;
        return s1.addr.str == null && s2.addr.str == null;
      }
    }/*equals is both null, else not equal*/
    
    
    int32  zz = to < 0 || to > z1 ? z1 - from : to - from;
    if(zz != length_CharSeqJc(s2/*J1cT2*/, _thCxt)) { STACKTRC_LEAVE;
      return false;
    }
    else 
    { 
      
      { int32 ii; 
        for(ii = 0; ii < zz; ++ii)
          { 
            
            if(charAt_CharSeqJc(s1/*J1cT2*/, from + ii, _thCxt) != charAt_CharSeqJc(s2/*J1cT2*/, ii, _thCxt)) { STACKTRC_LEAVE;
            return false;
          }
          }
      }
      { STACKTRC_LEAVE;
        return true;
      }
    }
  }
  STACKTRC_LEAVE;
}


/**Compares two Strings or StringBuilder-content or any other CharSequence.*/
bool equals_CsCs_StringFunctionsJc(/*J2C:static method*/ CharSeqJc s1, CharSeqJc s2, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("equals_CsCs_StringFunctionsJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return s1.addr.str == null ? s2.addr.str == null : equals_CsiiCs_StringFunctionsJc(/*J2C:static method call*/s1, 0, length_CharSeqJc(s1/*J1cT2*/, _thCxt), s2, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Returns true if s2 is contained in s1. */
bool contains_StringFunctionsJc(/*J2C:static method*/ CharSeqJc s1, CharSeqJc s2, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("contains_StringFunctionsJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return indexOf_CsiiCs_StringFunctionsJc(/*J2C:static method call*/s1, 0, MAX_VALUE_IntegerJc, s2, _thCxt) >= 0;
    }
  }
  STACKTRC_LEAVE;
}


/**Checks whether the given CharSequence starts with a CharSequence.*/
bool startsWith_CsCs_StringFunctionsJc(/*J2C:static method*/ CharSeqJc sq, CharSeqJc start, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("startsWith_CsCs_StringFunctionsJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return compare_CsiCsii_StringFunctionsJc(/*J2C:static method call*/sq, 0, start, 0, length_CharSeqJc(start/*J1cT2*/, _thCxt), _thCxt) == 0;
    }
  }
  STACKTRC_LEAVE;
}


/**Checks whether the given CharSequence starts with a CharSequence.*/
bool startsWith_CsiiCs_StringFunctionsJc(/*J2C:static method*/ CharSeqJc sq, int32 from, int32 to, CharSeqJc start, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("startsWith_CsiiCs_StringFunctionsJc");
  
  { 
    
    
    int32  zstart = length_CharSeqJc(start/*J1cT2*/, _thCxt);
    if((to - from) < zstart) { STACKTRC_LEAVE;
      return false;
    }
    { STACKTRC_LEAVE;
      return compare_CsiCsii_StringFunctionsJc(/*J2C:static method call*/sq, from, start, 0, zstart, _thCxt) == 0;
    }
  }
  STACKTRC_LEAVE;
}


/**Checks whether the given CharSequence ends with a CharSequence.*/
bool endsWith_StringFunctionsJc(/*J2C:static method*/ CharSeqJc sq, CharSeqJc end, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("endsWith_StringFunctionsJc");
  
  { 
    
    
    int32  z = length_CharSeqJc(end/*J1cT2*/, _thCxt);
    if(z > length_CharSeqJc(sq/*J1cT2*/, _thCxt)) { STACKTRC_LEAVE;
      return false;
    }
    else { STACKTRC_LEAVE;
      return compare_CsiCsii_StringFunctionsJc(/*J2C:static method call*/sq, length_CharSeqJc(sq/*J1cT2*/, _thCxt) - z, end, 0, z, _thCxt) == 0;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns false if at least one char was found in text which is not a whitespace.*/
bool isEmptyOrOnlyWhitespaces_StringFunctionsJc(/*J2C:static method*/ CharSeqJc text, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("isEmptyOrOnlyWhitespaces_StringFunctionsJc");
  
  { 
    
    
    char  cc;/*no initvalue*/
    
    int32  zz = length_CharSeqJc(text/*J1cT2*/, _thCxt);
    
    int32  ii = -1;
    
    while(++ii < zz)
      { 
        
        cc = charAt_CharSeqJc(text/*J1cT2*/, ii, _thCxt);
        if(indexOf_C_StringJc(zI_StringJc(" \t\n\r",4), cc) < 0) 
        { 
          
          { STACKTRC_LEAVE;
          return false;
        }
        }/*other character than whitespace*/
        
      }
    { STACKTRC_LEAVE;
      return true;
    }
  }
  STACKTRC_LEAVE;
}


/**Searches the first occurrence of the given character in a CharSequence.*/
int32 indexOf_Csiic_StringFunctionsJc(/*J2C:static method*/ CharSeqJc sq, int32 fromIndex, int32 to, char ch, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOf_Csiic_StringFunctionsJc");
  
  { 
    
    
    int32  zsq = length_CharSeqJc(sq/*J1cT2*/, _thCxt);
    
    int32  max = to > zsq ? zsq : to;
    
    int32  ii = fromIndex - 1;
    if(fromIndex < 0) 
    { 
      
      ii = -1;
    }
    else if(fromIndex >= max) 
    { 
      
      { STACKTRC_LEAVE;
        return -1;
      }
    }
    
    while(++ii < max)
      { 
        
        if(charAt_CharSeqJc(sq/*J1cT2*/, ii, _thCxt) == ch) 
        { 
          
          { STACKTRC_LEAVE;
          return ii;
        }
        }
      }
    { STACKTRC_LEAVE;
      return -1;
    }/*not found;*/
    
  }
  STACKTRC_LEAVE;
}


/**Searches the first occurrence of the given Character in a CharSequence.*/
int32 indexOf_Csci_StringFunctionsJc(/*J2C:static method*/ CharSeqJc sq, char ch, int32 fromIndex, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOf_Csci_StringFunctionsJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return indexOf_Csiic_StringFunctionsJc(/*J2C:static method call*/sq, fromIndex, MAX_VALUE_IntegerJc, ch, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Searches the first occurrence of the given Character in a CharSequence.*/
int32 indexOf_Csc_StringFunctionsJc(/*J2C:static method*/ CharSeqJc sq, char ch, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOf_Csc_StringFunctionsJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return indexOf_Csiic_StringFunctionsJc(/*J2C:static method call*/sq, 0, MAX_VALUE_IntegerJc, ch, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Searches any char inside sChars in the given Charsequence*/
int32 indexOfAnyChar_StringFunctionsJc(/*J2C:static method*/ CharSeqJc sq, int32 begin, int32 end, CharSeqJc sChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOfAnyChar_StringFunctionsJc");
  
  { 
    
    
    int32  pos = begin - 1;
    if(end == MAX_VALUE_IntegerJc) 
    { 
      
      end = length_CharSeqJc(sq/*J1cT2*/, _thCxt);
    }
    
    while(++pos < end && indexOf_Csc_StringFunctionsJc(/*J2C:static method call*/sChars, charAt_CharSeqJc(sq/*J1cT2*/, pos, _thCxt), _thCxt) < 0)
      { }/*while any of char in sChars not found:*/
      
    if(pos < end || (pos == end && indexOf_Csc_StringFunctionsJc(/*J2C:static method call*/sChars, cEndOfText_StringFunctionsJc, _thCxt) >= 0)) 
    { 
      
      { STACKTRC_LEAVE;
        return pos;
      }
    }
    else { STACKTRC_LEAVE;
      return -1;
    }
  }
  STACKTRC_LEAVE;
}


/**Searches the last occurrence of the given char in a CharSequence.*/
int32 lastIndexOf_Csiic_StringFunctionsJc(/*J2C:static method*/ CharSeqJc sq, int32 from, int32 to, char ch, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lastIndexOf_Csiic_StringFunctionsJc");
  
  { 
    
    
    int32  zsq = length_CharSeqJc(sq/*J1cT2*/, _thCxt);
    
    int32  ii = to > zsq ? zsq : to;
    
    while(--ii >= from)
      { 
        
        if(charAt_CharSeqJc(sq/*J1cT2*/, ii, _thCxt) == ch) 
        { 
          
          { STACKTRC_LEAVE;
          return ii;
        }
        }
      }
    { STACKTRC_LEAVE;
      return -1;
    }/*not found;*/
    
  }
  STACKTRC_LEAVE;
}


/**Searches the last occurrence of the given char in a CharSequence.*/
int32 lastIndexOf_Csc_StringFunctionsJc(/*J2C:static method*/ CharSeqJc sq, char ch, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lastIndexOf_Csc_StringFunctionsJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return lastIndexOf_Csiic_StringFunctionsJc(/*J2C:static method call*/sq, 0, MAX_VALUE_IntegerJc, ch, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Searches the last occurrence of the given char in a CharSequence.*/
int32 lastIndexOfAnyChar_StringFunctionsJc(/*J2C:static method*/ CharSeqJc sq, int32 from, int32 to, CharSeqJc chars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lastIndexOfAnyChar_StringFunctionsJc");
  
  { 
     /*J2C: temporary Stringbuffer for String concatenation*/
    StringBuilderJc_s* _tempString2_1=null; 
    
    
    int32  zsq = length_CharSeqJc(sq/*J1cT2*/, _thCxt);
    
    int32  ii = to > zsq ? zsq : to;
    if(from < 0) { THROW(IndexOutOfBoundsException, 
      ( _tempString2_1 = new_StringBuilderJc(-1, _thCxt)
      , setStringConcatBuffer_StringBuilderJc(_tempString2_1)
      , append_z_StringBuilderJc(_tempString2_1, "StringFunctions.lastIndexOfAnyChar - form <0; ", _thCxt)
      , append_I_StringBuilderJc(_tempString2_1, from, _thCxt)
      , toStringMarkPersist_StringBuilderJc(&(_tempString2_1)->base.object, _thCxt)
      ), 0, 0); return 0; };
    
    while(--ii >= from && indexOf_Csc_StringFunctionsJc(/*J2C:static method call*/chars, charAt_CharSeqJc(sq/*J1cT2*/, ii, _thCxt), _thCxt) < 0)
      { }/*pre-decrement.*/
      
    { STACKTRC_LEAVE;
      activateGC_ObjectJc(&_tempString2_1->base.object, null, _thCxt);
      return ii >= from ? ii + 1 : -1;
    }/*not found;*/
    
    activateGC_ObjectJc(&_tempString2_1->base.object, null, _thCxt);
  }
  STACKTRC_LEAVE;
}


/**Checks whether the given CharSequence contains the other given CharSequence.*/
int32 indexOf_CsiiS_StringFunctionsJc(/*J2C:static method*/ CharSeqJc sq, int32 fromIndex, int32 to, StringJc str, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOf_CsiiS_StringFunctionsJc");
  
  { 
    
    
    int32  zsq = length_CharSeqJc(sq/*J1cT2*/, _thCxt);
    
    int32  max = (to >= zsq ? zsq : to) - length_StringJc(str) + 1;
    
    int32  ii = fromIndex - 1;
    if(fromIndex < 0) 
    { 
      
      ii = -1;
    }
    else if(fromIndex >= max) 
    { 
      
      { STACKTRC_LEAVE;
        return -1;
      }
    }
    
    char  ch = charAt_StringJc(str, 0);
    
    while(++ii < max)
      { 
        
        if(charAt_CharSeqJc(sq/*J1cT2*/, ii, _thCxt) == ch) 
        { /*:search first char of str*/
          
          
          
          int32  s1 = 0;
          { int32 jj; 
            for(jj = ii + 1; jj < ii + length_StringJc(str); ++jj)
              { 
                
                if(charAt_CharSeqJc(sq/*J1cT2*/, jj, _thCxt) != charAt_StringJc(str, ++s1)) 
                { 
                  
                  s1 = -1;/*designate: not found*/
                  
                  break;
                }
              }
          }
          if(s1 >= 0) { STACKTRC_LEAVE;
          return ii;
        }/*found.*/
          
        }
      }
    { STACKTRC_LEAVE;
      return -1;
    }/*not found;*/
    
  }
  STACKTRC_LEAVE;
}


/**Checks whether the given CharSequence contains the other given CharSequence.*/
int32 indexOf_CsiiCs_StringFunctionsJc(/*J2C:static method*/ CharSeqJc sq, int32 fromIndex, int32 to, CharSeqJc str, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOf_CsiiCs_StringFunctionsJc");
  
  { 
    
    
    int32  zsq = length_CharSeqJc(sq/*J1cT2*/, _thCxt);
    
    int32  max = (to >= zsq ? zsq : to) - length_CharSeqJc(str/*J1cT2*/, _thCxt) + 1;
    
    int32  ii = fromIndex - 1;
    if(fromIndex < 0) 
    { 
      
      ii = -1;
    }
    else if(fromIndex >= max) 
    { 
      
      { STACKTRC_LEAVE;
        return -1;
      }
    }
    
    char  ch = charAt_CharSeqJc(str/*J1cT2*/, 0, _thCxt);
    
    while(++ii < max)
      { 
        
        if(charAt_CharSeqJc(sq/*J1cT2*/, ii, _thCxt) == ch) 
        { /*:search first char of str*/
          
          
          
          int32  s1 = 0;
          { int32 jj; 
            for(jj = ii + 1; jj < ii + length_CharSeqJc(str/*J1cT2*/, _thCxt); ++jj)
              { 
                
                if(charAt_CharSeqJc(sq/*J1cT2*/, jj, _thCxt) != charAt_CharSeqJc(str/*J1cT2*/, ++s1, _thCxt)) 
                { 
                  
                  s1 = -1;/*designate: not found*/
                  
                  break;
                }
              }
          }
          if(s1 >= 0) { STACKTRC_LEAVE;
          return ii;
        }/*found.*/
          
        }
      }
    { STACKTRC_LEAVE;
      return -1;
    }/*not found;*/
    
  }
  STACKTRC_LEAVE;
}


/**Searches the first occurrence of the given CharSequence in a CharSequence.*/
int32 indexOf_CsCsi_StringFunctionsJc(/*J2C:static method*/ CharSeqJc sq, CharSeqJc str, int32 fromIndex, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOf_CsCsi_StringFunctionsJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return indexOf_CsiiCs_StringFunctionsJc(/*J2C:static method call*/sq, fromIndex, MAX_VALUE_IntegerJc, str, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Searches the first occurrence of the given CharSequence in a CharSequence.*/
int32 indexOf_CsCs_StringFunctionsJc(/*J2C:static method*/ CharSeqJc sq, CharSeqJc str, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOf_CsCs_StringFunctionsJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return indexOf_CsiiCs_StringFunctionsJc(/*J2C:static method call*/sq, 0, MAX_VALUE_IntegerJc, str, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Checks whether the given CharSequence contains the given String.*/
int32 lastIndexOf_CsiiS_StringFunctionsJc(/*J2C:static method*/ CharSeqJc sq, int32 fromIndex, int32 to, StringJc str, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lastIndexOf_CsiiS_StringFunctionsJc");
  
  { 
    
    
    int32  zsq = length_CharSeqJc(sq/*J1cT2*/, _thCxt);
    
    int32  max = (to >= zsq ? zsq : to) - length_StringJc(str) + 1;
    if(fromIndex >= max) 
    { 
      
      { STACKTRC_LEAVE;
        return -1;
      }
    }
    
    char  ch = charAt_StringJc(str, 0);
    
    while(--max >= fromIndex)
      { 
        
        if(charAt_CharSeqJc(sq/*J1cT2*/, max, _thCxt) == ch) 
        { 
          
          
          int32  s1 = 0;
          { int32 jj; 
            for(jj = max + 1; jj < max + length_StringJc(str) - 1; ++jj)
              { 
                
                if(charAt_CharSeqJc(sq/*J1cT2*/, jj, _thCxt) != charAt_StringJc(str, ++s1)) 
                { 
                  
                  s1 = -1;/*designate: not found*/
                  
                  break;
                }
              }
          }
          if(s1 >= 0) { STACKTRC_LEAVE;
          return max;
        }/*found.*/
          
        }
      }
    { STACKTRC_LEAVE;
      return -1;
    }/*not found;*/
    
  }
  STACKTRC_LEAVE;
}


/**Checks whether the given CharSequence contains the other given CharSequence.*/
int32 lastIndexOf_CsiiCs_StringFunctionsJc(/*J2C:static method*/ CharSeqJc sq, int32 fromIndex, int32 to, CharSeqJc str, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lastIndexOf_CsiiCs_StringFunctionsJc");
  
  { 
    
    
    int32  zsq = length_CharSeqJc(sq/*J1cT2*/, _thCxt);
    
    int32  max = (to >= zsq ? zsq : to) - length_CharSeqJc(str/*J1cT2*/, _thCxt) + 1;
    if(fromIndex >= max) 
    { 
      
      { STACKTRC_LEAVE;
        return -1;
      }
    }
    
    char  ch = charAt_CharSeqJc(str/*J1cT2*/, 0, _thCxt);
    
    while(--max >= fromIndex)
      { 
        
        if(charAt_CharSeqJc(sq/*J1cT2*/, max, _thCxt) == ch) 
        { 
          
          
          int32  s1 = 0;
          { int32 jj; 
            for(jj = max + 1; jj < max + length_CharSeqJc(str/*J1cT2*/, _thCxt); ++jj)
              { 
                
                if(charAt_CharSeqJc(sq/*J1cT2*/, jj, _thCxt) != charAt_CharSeqJc(str/*J1cT2*/, ++s1, _thCxt)) 
                { 
                  
                  s1 = -1;/*designate: not found*/
                  
                  break;
                }
              }
          }
          if(s1 > 0) { STACKTRC_LEAVE;
          return max;
        }/*found.*/
          
        }
      }
    { STACKTRC_LEAVE;
      return -1;
    }/*not found;*/
    
  }
  STACKTRC_LEAVE;
}


/**Returns the position of one of the strings in listStrings within the given sq, maybe started inside the sq with from,*/
int32 indexOfAnyString_StringFunctionsJc(/*J2C:static method*/ CharSeqJc sq, int32 from, int32 to, CharSeqJc_Y* listStrings, int32* nrofFoundString, StringJc* foundString, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOfAnyString_StringFunctionsJc");
  
  { 
    
    
    int32  pos = from;
    ASSERT(/*J2C:static method call*/listStrings->head.length < 100);/*static size is need*/
    
    
    StringBufferJc  sFirstCharBuffer = { 0 };//J2C: constructor for embedded element-ObjectJc
    init_ObjectJc(&(sFirstCharBuffer.base.object), sizeof(sFirstCharBuffer), 0); 
    ctorO_I_StringBufferJc(/*J2C:static method call*/&(sFirstCharBuffer.base.object), 100, _thCxt);
    
    bool  acceptToEndOfText = false;
    /**Compose a String with all first chars, to test whether a current char of src is equal. */
    
    { 
      
      
      int32  ii = -1;
      /**Compose a String with all first chars, to test whether a current char of src is equal. */
      
      while(++ii < listStrings->head.length)/**Compose a String with all first chars, to test whether a current char of src is equal. */
        
        { /*:String sString = (String)(iter.next());*/
          
          
          
          CharSeqJc sString ; sString = listStrings->data[ii];
          /**Compose a String with all first chars, to test whether a current char of src is equal. */
          if(charAt_CharSeqJc(sString/*J1cT2*/, 0, _thCxt) == cEndOfText_StringFunctionsJc) /**Compose a String with all first chars, to test whether a current char of src is equal. */
          
          { 
            
            /**Compose a String with all first chars, to test whether a current char of src is equal. */
            acceptToEndOfText = true;
          }
          else /**Compose a String with all first chars, to test whether a current char of src is equal. */
          
          { 
            
            /**Compose a String with all first chars, to test whether a current char of src is equal. */
            append_C_StringBufferJc(& (sFirstCharBuffer), charAt_CharSeqJc(sString/*J1cT2*/, 0, _thCxt), _thCxt);
          }/*to search the first char as one of chars*/
          
        }
    }
    
    StringJc sFirstChars ; sFirstChars = toString_StringBufferJc(& ((sFirstCharBuffer).base.object), _thCxt)/*J2C:non-persistent*/;
    
    bool  found = false;
    
    while(!found && pos < to)
      { 
        
        
        int32  nrofFoundString1 = -1;
        /**increment over not matching chars, test all first chars: */
        
        while(pos < to && (nrofFoundString1 = /*? assignment*/indexOf_C_StringJc(sFirstChars, charAt_CharSeqJc(sq/*J1cT2*/, pos, _thCxt))) < 0)/**increment over not matching chars, test all first chars: */
          pos += 1;
        if(pos < to) 
        { 
          
          
          int32  ii = -1;
          
          while(!found && ++ii < listStrings->head.length)
            { /*:String sString = (String)(iter.next());*/
              
              
              
              CharSeqJc sString ; sString = listStrings->data[ii];
              
              int32  testLen = length_CharSeqJc(sString/*J1cT2*/, _thCxt);
              if((to - pos) >= testLen && equals_CsiiCs_StringFunctionsJc(/*J2C:static method call*/sq, pos, pos + testLen, sString, _thCxt)) 
              { 
                
                found = true;
                if(foundString != null) 
                { 
                  
                  foundString[0] = toString_CharSeqJc(sString/*J1cT2*/)/*J2C:non-persistent*/;
                }
                if(nrofFoundString != null) 
                { 
                  
                  nrofFoundString[0] = ii;
                }
              }/*else { nrofFoundString1 +=1; }*/
              
            }
          if(!found) 
          { 
            
            pos += 1;
          }/*check from the next char because no string matches.*/
          
        }
      }
    if(pos > to || (pos == to && !acceptToEndOfText)) 
    { /*:nothing found */
      
      
      pos = -1;
      if(foundString != null) 
      { 
        
        foundString[0] = null_StringJc/*J2C:non-persistent*/;
      }
      if(nrofFoundString != null) 
      { 
        
        nrofFoundString[0] = -1;
      }
    }
    { STACKTRC_LEAVE;
      return pos;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns a String with 2*indent spaces for indentation.*/
StringJc indent2_StringFunctionsJc(/*J2C:static method*/ int32 indent, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indent2_StringFunctionsJc");
  
  { 
    
    if(2 * indent < length_StringJc(indentString_StringFunctionsJc) - 1) 
    { 
      
      { STACKTRC_LEAVE;
        return substring_StringJc(indentString_StringFunctionsJc, 1, 1 + 2 * indent, _thCxt);
      }
    }
    else { STACKTRC_LEAVE;
      return substring_I_StringJc(indentString_StringFunctionsJc, 1, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Returns a String with a newline \n character and 2*indent spaces for indentation.*/
StringJc nl_indent2_StringFunctionsJc(/*J2C:static method*/ int32 indent, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("nl_indent2_StringFunctionsJc");
  
  { 
    
    if(2 * indent < length_StringJc(indentString_StringFunctionsJc) - 1) 
    { 
      
      { STACKTRC_LEAVE;
        return substring_StringJc(indentString_StringFunctionsJc, 0, 1 + 2 * indent, _thCxt);
      }
    }
    else { STACKTRC_LEAVE;
      return indentString_StringFunctionsJc;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the number of bytes to the UTF start byte.*/
int32 nrofBytesUTF8_StringFunctionsJc(/*J2C:static method*/ int8 b, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("nrofBytesUTF8_StringFunctionsJc");
  
  { 
    
    if(b >= 0) { STACKTRC_LEAVE;
      return 1;
    }
    if((b & 0xe0) == 0xc0) { STACKTRC_LEAVE;
      return 2;
    }
    if((b & 0xf0) == 0xe0) { STACKTRC_LEAVE;
      return 3;
    }
    if((b & 0xf8) == 0xf0) { STACKTRC_LEAVE;
      return 4;
    }
    if((b & 0xfc) == 0xf8) { STACKTRC_LEAVE;
      return 5;
    }
    if((b & 0xfe) == 0xfc) { STACKTRC_LEAVE;
      return 6;
    }
    if(b == (int8)0xfe) { STACKTRC_LEAVE;
      return 7;
    }
    if(b == (int8)0xff) { STACKTRC_LEAVE;
      return 8;
    }
    else { STACKTRC_LEAVE;
      return 0;
    }/*all codes 80..BF = 10xxxxxx*/
    
  }
  STACKTRC_LEAVE;
}


/**Converts the current bytes in a byte[] from UTF-8 in a UTF16-character.*/
int16 byte2UTF8_StringFunctionsJc(/*J2C:static method*/ int8_Y* src, int32_Y* ixSrc, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("byte2UTF8_StringFunctionsJc");
  
  { 
    
    
    int8  b = src->data[ixSrc->data[0]];
    if(b >= 0) 
    { 
      
      { STACKTRC_LEAVE;
        return (int16 /*J2C_cast*/)b;
      }
    }/**/
    
    if((b & 0xc0) == 0x80) { STACKTRC_LEAVE;
      return 0;
    }/**/
    
    
    int8  b2 = src->data[ixSrc->data[0]];
    if((b2 & 0xc0) != 0x80) { STACKTRC_LEAVE;
      return 0;
    }
    ixSrc->data[0] += 1;
    
    int32  cc = b;
    cc <<= 6;
    cc |= b2 & 0x3f;
    if((b & 0xe0) == 0xc0) 
    { 
      
      { STACKTRC_LEAVE;
        return (int16 /*J2C_cast*/)(cc & 0x7ff);
      }/*remove 3 MSB from b.*/
      
    }/**/
    
    
    int8  b3 = src->data[ixSrc->data[0]];
    if((b3 & 0xc0) != 0x80) { STACKTRC_LEAVE;
      return 0;
    }
    ixSrc->data[0] += 1;
    cc <<= 6;
    cc |= b3 & 0x3f;
    if((b & 0xf0) == 0xe0) 
    { 
      
      { STACKTRC_LEAVE;
        return (int16 /*J2C_cast*/)(cc & 0xffff);
      }/*remove 3 MSB from b.*/
      
    }/**/
    /*That is an higher UTF character than UTF16-range:*/
    
    
    int8  b4 = src->data[ixSrc->data[0]];
    if((b4 & 0xc0) != 0x80) { STACKTRC_LEAVE;
      return 0;
    }
    ixSrc->data[0] += 1;
    if((b & 0xf8) == 0xf0) 
    { 
      
      { STACKTRC_LEAVE;
        return (int16 /*J2C_cast*/)(0xfffd);
      }
    }/*    */
    
    
    int8  b5 = src->data[ixSrc->data[0]];
    ixSrc->data[0] += 1;
    if((b5 & 0xc0) != 0x80) { STACKTRC_LEAVE;
      return 0;
    }
    if((b & 0xfc) == 0xf8) 
    { 
      
      { STACKTRC_LEAVE;
        return (int16 /*J2C_cast*/)(0xfffd);
      }
    }/*    */
    
    
    int8  b6 = src->data[ixSrc->data[0]];
    if((b6 & 0xc0) != 0x80) { STACKTRC_LEAVE;
      return 0;
    }
    ixSrc->data[0] += 1;
    if((b & 0xfe) == 0xfc) 
    { 
      
      { STACKTRC_LEAVE;
        return (int16 /*J2C_cast*/)(0xfffd);
      }
    }/*    */
    
    
    int8  b7 = src->data[ixSrc->data[0]];
    if((b7 & 0xc0) != 0x80) { STACKTRC_LEAVE;
      return 0;
    }
    ixSrc->data[0] += 1;
    if((b & 0xff) == 0xfe) 
    { 
      
      { STACKTRC_LEAVE;
        return (int16 /*J2C_cast*/)(0xfffd);
      }
    }/*    */
    
    ASSERT(/*J2C:static method call*/b == (int8)0xff);
    
    int8  b8 = src->data[ixSrc->data[0]++];
    if((b8 & 0xc0) != 0x80) { STACKTRC_LEAVE;
      return 0;
    }
    ixSrc->data[0] += 1;
    { STACKTRC_LEAVE;
      return (int16 /*J2C_cast*/)(0xfffd);
    }
  }
  STACKTRC_LEAVE;
}


#ifdef DEF_ClassJc_Vtbl
/**J2C: Reflections and Method-table *************************************************/
const VtblDef_StringFunctionsJc mtblStringFunctionsJc = {
{ { sign_Vtbl_StringFunctionsJc //J2C: Head of methodtable of StringFunctionsJc
  , (struct Size_Vtbl_t*)((1 +2) * sizeof(void*)) //J2C:size. NOTE: all elements has the size of void*.
  }
  //J2C: Dynamic methods of the class :StringFunctionsJc:
, test_StringFunctionsJc_F //test
  //J2C: The superclass's methodtable: 
, { { sign_Vtbl_ObjectJc //J2C: Head of methodtable of ObjectJc
    , (struct Size_Vtbl_t*)((5 +2) * sizeof(void*)) //J2C:size. NOTE: all elements has the size of void*.
    }
    //J2C: Dynamic methods of the class :ObjectJc:
  , clone_ObjectJc_F //clone
  , equals_ObjectJc_F //equals
  , finalize_ObjectJc_F //finalize
  , hashCode_ObjectJc_F //hashCode
  , toString_ObjectJc_F //toString
  }
}, { signEnd_Vtbl_ObjectJc, null } }; //Vtbl
#endif //#ifdef DEF_ClassJc_Vtbl



#ifdef DEF_ClassJc_Vtbl

 extern_C struct ClassJc_t const refl_ObjectJc;
 static struct superClasses_StringFunctionsJc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxVtblJc data[1];
 }superclasses_StringFunctionsJc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxVtblJc, 1, OBJTYPE_ClassOffset_idxVtblJc, null, null)
 , { {&refl_ObjectJc, OFFSET_Vtbl(Vtbl_StringFunctionsJc, ObjectJc) }
   }
 };

extern_C struct ClassJc_t const refl_StringFunctionsJc_s;
extern_C struct ClassJc_t const refl_StringJc;
const struct Reflection_Fields_StringFunctionsJc_s_t
{ ObjectArrayJc head; FieldJc data[5];
} refl_Fields_StringFunctionsJc_s =
{ CONST_ObjectArrayJc(FieldJc, 5, OBJTYPE_FieldJc, null, &refl_Fields_StringFunctionsJc_s)
, {
     { "version"
    , 0 //nrofArrayElements
    , &refl_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&version_StringFunctionsJc) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&version_StringFunctionsJc)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &refl_StringFunctionsJc_s
    }
   , { "cEndOfText"
    , 0 //nrofArrayElements
    , REFLECTION_char
    , 4 << kBitPrimitiv_Modifier_reflectJc |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&cEndOfText_StringFunctionsJc) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&cEndOfText_StringFunctionsJc)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &refl_StringFunctionsJc_s
    }
   , { "cStartOfText"
    , 0 //nrofArrayElements
    , REFLECTION_char
    , 4 << kBitPrimitiv_Modifier_reflectJc |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&cStartOfText_StringFunctionsJc) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&cStartOfText_StringFunctionsJc)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &refl_StringFunctionsJc_s
    }
   , { "cNoCidentifier"
    , 0 //nrofArrayElements
    , REFLECTION_char
    , 4 << kBitPrimitiv_Modifier_reflectJc |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&cNoCidentifier_StringFunctionsJc) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&cNoCidentifier_StringFunctionsJc)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &refl_StringFunctionsJc_s
    }
   , { "indentString"
    , 0 //nrofArrayElements
    , &refl_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&indentString_StringFunctionsJc) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&indentString_StringFunctionsJc)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &refl_StringFunctionsJc_s
    }
} };
const ClassJc refl_StringFunctionsJc_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &refl_ObjectJc, &refl_ClassJc) 
, "StringFunctionsJc_s"
,  0 //position of ObjectJc
, sizeof(StringFunctionsJc_s)
, (FieldJc_Y const*)&refl_Fields_StringFunctionsJc_s
, null //method
, &superclasses_StringFunctionsJc_s.head.object //superclass
, null //interfaces
, 0    //modifiers
, &mtblStringFunctionsJc.mtbl.head
};


#endif  //#ifdef DEF_ClassJc_Vtbl



#endif //#ifdef DEF_ObjectJcpp_REFLECTION  //only possible with reflection because Vtable is need
