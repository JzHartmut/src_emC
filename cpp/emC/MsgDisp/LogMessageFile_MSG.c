/**************************************************************************
 * This file is generated by Java2C
 **copyright***************************************************************
 *************************************************************************/
#include "MsgDisp/LogMessageFile_MSG.h"
#include <string.h>  //because using memset()
#include <Jc/ReflectionJc.h>   //Reflection concept 
  //basic stacktrace concept
#include "Jc/FormatterJc.h"  //embedded type in block
#include "Jc/LocaleJc.h"  //reference-association: LocaleJc_s
#include "Jc/TimeZoneJc.h"  //reference-association: TimeZoneJc_s
#include "MsgDisp/MsgDispatcherCore_MSG.h"  //reference-association: parkedEntry
#include "emC/VaArgBuffer.h"  //reference-association: values


/* J2C: Forward declaration of struct ***********************************************/
struct Entry_MsgDispatcherCore_MSG_t;


/* J2C: Method-table-references *********************************************************/
#ifndef LogMessageFWMTBDEF
  #define LogMessageFWMTBDEF
  typedef struct LogMessageFWMTB_t { struct Vtbl_LogMessageFW_t const* mtbl; struct LogMessageFW_t* ref; } LogMessageFWMTB;
#endif


/**This class is a LogMessage output which writes the messages into a file.
<br>Capability:
<ul>
<li>The file will be flushed or closed after a given time. Therefore it is possible to read the file with another tool.
<li>It is possible to define a name with a timestamp part. Then new files will be created with a timestamp in the name
<li>etc. todo
</ul>
@author Hartmut Schorrig

*/


const char sign_Vtbl_LogMessageFile_MSG[] = "LogMessageFile_MSG"; //to mark method tables of all implementations

typedef struct VtblDef_LogMessageFile_MSG_t { Vtbl_LogMessageFile_MSG mtbl; VtblHeadJc end; } VtblDef_LogMessageFile_MSG;
 extern VtblDef_LogMessageFile_MSG const mtblLogMessageFile_MSG;

/*Constructor */
struct LogMessageFile_MSG_t* ctorO_LogMessageFile_MSG(ObjectJc* othis, StringJc sFilename, int32 nrofSecondsToFlush, int32 nrofHoursPerFile, struct LocaleJc_t* localization, struct TimeZoneJc_t* timeZoneP, struct ConcurrentLinkedQueueJc_t* freeEntriesP, ThCxt* _thCxt)
{ LogMessageFile_MSG_s* thiz = (LogMessageFile_MSG_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_LogMessageFile_MSG");
  checkConsistence_ObjectJc(othis, sizeof(LogMessageFile_MSG_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &refl_LogMessageFile_MSG_s, sizeof(LogMessageFile_MSG_s));  
  //j2c: Initialize all class variables:
  {
    //J2C: constructor for embedded fix-size-StringBuffer
      init_ObjectJc(&thiz->sFilenameBuffer.sb.base.object, sizeof(StringBuilderJc_s) + 120 - 4, 0);
      ctorO_I_StringBuilderJc(&thiz->sFilenameBuffer.sb.base.object, 120, _thCxt);
    //J2C: constructor for embedded fix-size-StringBuffer
      init_ObjectJc(&thiz->sDateformatBuffer.sb.base.object, sizeof(StringBuilderJc_s) + 32 - 4, 0);
      ctorO_I_StringBuilderJc(&thiz->sDateformatBuffer.sb.base.object, 32, _thCxt);
    //J2C: constructor for embedded element-ObjectJc
      init_ObjectJc(&(thiz->formatTimestamp.base.object), sizeof(thiz->formatTimestamp), 0); 
      ctorO_SimpleDateFormatJc(/*J2C:static method call*/&(thiz->formatTimestamp.base.object), _thCxt);
    thiz->counterMultifile = 0;
    //J2C: constructor for embedded element-ObjectJc
      init_ObjectJc(&(thiz->formatField.base.object), sizeof(thiz->formatField), 0); 
      ctorO_TextFieldPositionJc(/*J2C:static method call*/&(thiz->formatField.base.object), DATE_FIELD_SimpleDateFormatJc, _thCxt);
    //J2C: constructor for embedded element-ObjectJc
      init_ObjectJc(&(thiz->file.base.object), sizeof(thiz->file), 0); 
      ctorO_FileWriterJc(/*J2C:static method call*/&(thiz->file.base.object), _thCxt);
    //J2C: constructor for embedded element
      INIT_OS_TimeStamp(/*J2C:static method call*/thiz->timeOpen);
    thiz->bNewFile = true;
    //J2C: constructor for embedded element
      INIT_OS_TimeStamp(/*J2C:static method call*/thiz->timeWrite);
    //J2C: constructor for embedded element
      INIT_OS_TimeStamp(/*J2C:static method call*/thiz->timeClose);
    thiz->shouldFlushed = false;
    //J2C: constructor for embedded element-MemC
      ctorM_Dbg_LogMessageFile_MSG(/*J2C:static method call*/build_MemC(&thiz->dbg, sizeof(thiz->dbg)), _thCxt);
    //J2C: constructor for embedded element-ObjectJc
      init_ObjectJc(&(thiz->parkedOrders.base.object), sizeof(thiz->parkedOrders), 0); 
      ctorO_init_ConcurrentLinkedQueueJc(/*J2C:static method call*/&(thiz->parkedOrders.base.object), false, _thCxt);
    //J2C: constructor for embedded element-ObjectJc
      init_ObjectJc(&(thiz->dateFormat.base.object), sizeof(thiz->dateFormat), 0); 
      ctorO_s_SimpleDateFormatJc(/*J2C:static method call*/&(thiz->dateFormat.base.object), s0_StringJc("yyyy-MM-dd HH:mm:ss,SSS; "), _thCxt);
    //J2C: constructor for embedded fix-size-StringBuffer
      init_ObjectJc(&thiz->sBuffer.sb.base.object, sizeof(StringBuilderJc_s) + 1000 - 4, 0);
      ctorO_I_StringBuilderJc(&thiz->sBuffer.sb.base.object, 1000, _thCxt);
  }
  { 
    ObjectJc *newObj2_1=null; /*J2C: temporary Objects for new operations
    */StringJc _temp2_1; /*J2C: temporary references for concatenation */
    
    if(localization == null) 
    { 
      
      SETREFJc(thiz->localization, & (ROOT_LocaleJc), LocaleJc_s);
    }
    else 
    { 
      
      SETREFJc(thiz->localization, localization, LocaleJc_s);
    }
    thiz->charsFormatTimestampFilename = (char_Y*)ctorO_ObjectArrayJc((newObj2_1 = alloc_ObjectJc( sizeof(ObjectArrayJc) + (32) * sizeof(char), mIsLargeSize_ObjectJc, _thCxt)), 32, sizeof(char),REFLECTION_char, 0);  //J2C: assign a new ObjectArrayJc. ;
    SETREFJc(thiz->timeZone, timeZoneP == null ? getTimeZone_TimeZoneJc(/*J2C:static method call*/s0_StringJc("GMT"), _thCxt) : timeZoneP, TimeZoneJc_s);
    setTimeZone_SimpleDateFormatJc(& (thiz->dateFormat), REFJc (thiz->timeZone), _thCxt);
    setTimeZone_SimpleDateFormatJc(& (thiz->formatTimestamp), REFJc (thiz->timeZone), _thCxt);
    
    StringJc sTimestampInFilename ; sTimestampInFilename;/*no initvalue*/
    thiz->freeEntries = freeEntriesP;
    if(freeEntriesP != null) 
    { 
      
      shareNodePool_ConcurrentLinkedQueueJc(& (thiz->parkedOrders), freeEntriesP);
    }
    else 
    { }
    
    int32  pos2TimestampInFilename;/*no initvalue*/
    if(nrofSecondsToFlush > 0) 
    { 
      
      thiz->nrofSecondsToFlush = nrofSecondsToFlush;
      thiz->nrofSecondsToClose = -1;
    }
    else 
    { 
      
      thiz->nrofSecondsToClose = -nrofSecondsToFlush;/*use positive value!*/
      
      thiz->nrofSecondsToFlush = -1;
    }
    thiz->nrofHoursPerFile = nrofHoursPerFile;
    thiz->posTimestampInFilename = indexOf_C_StringJc(sFilename, '$');
    if(thiz->posTimestampInFilename >= 0) 
    { 
      
      pos2TimestampInFilename = indexOf_CI_StringJc(sFilename, '$', thiz->posTimestampInFilename + 1);
      if(pos2TimestampInFilename > 0) 
      { 
        
        sTimestampInFilename = substring_StringJc(sFilename, thiz->posTimestampInFilename + 1, pos2TimestampInFilename, _thCxt)/*J2C:non-persistent*/;
        
        int32  nrofCharsTimestampInFilename = length_StringJc(sTimestampInFilename);
        /*Store the format String localy in this class. It's not depend from outside memory management. */
        getChars_StringJc(sTimestampInFilename, 0, nrofCharsTimestampInFilename, thiz->charsFormatTimestampFilename, 0, _thCxt);/*charsFormatTimestampFilename.append(sTimestampInFilename);*/
        
        /*Represent the StringBuilder with a String.*/
        set_StringJc(&(thiz->sFormatTimestampFilename), declarePersist_StringJc(new_CYI_StringJc(/*J2C:static method call*/thiz->charsFormatTimestampFilename, 0, nrofCharsTimestampInFilename, _thCxt)));/*sFormatTimestampFilename = charsFormatTimestampFilename.toString();*/
        
      }
      else { throw_s0Jc(ident_IllegalArgumentExceptionJc, "second $ to delimit timestamp in filename missing.", 0, &_thCxt->stacktrc, __LINE__); return 0; };/*, this.posTimestampInFilename);*/
      
      applyPattern_SimpleDateFormatJc(& (thiz->formatTimestamp), thiz->sFormatTimestampFilename, _thCxt);
      append_c_StringBuilderJc(& (thiz->sFilenameBuffer.sb), substring_StringJc(sFilename, 0, thiz->posTimestampInFilename, _thCxt), _thCxt);
      if(indexOf_C_StringJc(sFilename, '*') >= 0) 
      { /*:The current timeStamp should be applied only here, it is the startup of the application.*/
        
        
        set_OS_TimeStamp(thiz->timeOpen, os_getDateTime());
        setLength_StringBufferJc(& (thiz->sDateformatBuffer.sb), 0, _thCxt);/*clear it.*/
        
        format_tu_SimpleDateFormatJc(& (thiz->formatTimestamp), thiz->timeOpen, & (thiz->sDateformatBuffer.sb), & (thiz->formatField), _thCxt);
        
        StringJc sTimeFileOpen ; sTimeFileOpen = toString_StringBufferJc(& ((thiz->sDateformatBuffer.sb).base.object), _thCxt)/*J2C:non-persistent*/;
        append_c_StringBuilderJc(& (thiz->sFilenameBuffer.sb), sTimeFileOpen, _thCxt);
        thiz->posTimestampInFilename = -1;/*don't replace the time stamp a second one.*/
        
      }
      else 
      { /*:use the format string only as placeholder*/
        
        
        append_c_StringBuilderJc(& (thiz->sFilenameBuffer.sb), thiz->sFormatTimestampFilename, _thCxt);
      }
      append_c_StringBuilderJc(& (thiz->sFilenameBuffer.sb), substring_I_StringJc(sFilename, pos2TimestampInFilename + 1, _thCxt), _thCxt);
    }
    else 
    { /*:no timeStamp in filename given, not used.*/
      
      
      append_c_StringBuilderJc(& (thiz->sFilenameBuffer.sb), sFilename, _thCxt);
      thiz->bNewFile = false;/*append on existing file.*/
      
    }
    /**Determines the position of an asterisk. It shouldn't done in sFilename-parameter because deleted $$.*/
    thiz->posMultifileInFilename = 
      ( _temp2_1= toStringNonPersist_StringBuilderJc(& ((thiz->sFilenameBuffer.sb).base.object), _thCxt)
      , indexOf_C_StringJc(_temp2_1, '*')
      );/*may be -1, than not used.*/
    
    thiz->currentLengthMultifileNr = 1;/*initial the '*' is to replace.*/
    
    activateGC_ObjectJc(newObj2_1, null, _thCxt);
  }
  STACKTRC_LEAVE;
  return thiz;
}



/**Sets a log output if a open or close action is done. This is useful especially in test situations.*/
void setLogMessageOpenClose_LogMessageFile_MSG_F(LogMessageFile_MSG_s* thiz, struct LogMessageFW_t* msg, int32 msgIdentOpenClose, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setLogMessageOpenClose_LogMessageFile_MSG_F");
  
  { 
    
    SETREFJc(thiz->msgOpenClose, msg, LogMessageFW_s);
    thiz->msgIdentOpenClose = msgIdentOpenClose;
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void setLogMessageOpenClose_LogMessageFile_MSG(LogMessageFile_MSG_s* thiz, struct LogMessageFW_t* msg, int32 msgIdentOpenClose, ThCxt* _thCxt)
{ Vtbl_LogMessageFile_MSG const* mtbl = (Vtbl_LogMessageFile_MSG const*)getVtbl_ObjectJc(&thiz->base.object, sign_Vtbl_LogMessageFile_MSG);
  mtbl->setLogMessageOpenClose(thiz, msg, msgIdentOpenClose, _thCxt);
}


/**Sends a message. See interface.  */
bool sendMsg_izv_LogMessageFile_MSG_F(LogMessageFW_s* ithis, int32 identNumber, char const* text, char const* args, ...)
{ LogMessageFile_MSG_s* thiz = (LogMessageFile_MSG_s*)ithis;
  Vtbl_LogMessageFile_MSG const* mtthis = (Vtbl_LogMessageFile_MSG const*)getVtbl_ObjectJc(&thiz->base.object, sign_Vtbl_LogMessageFile_MSG);
  
  STACKTRC_ENTRY("sendMsg_izv_LogMessageFile_MSG_F");
  
  { 
    
    
    Va_listFW  vaArgs = { 0 };va_start(vaArgs.args, args); vaArgs.typeArgs = args;
    { STACKTRC_LEAVE;
      return mtthis->LogMessageFW.sendMsgVaList(& ((* (thiz)).base.LogMessageFW)/*J2cT1*/, identNumber, os_getDateTime(), text, vaArgs, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
bool sendMsg_izv_LogMessageFile_MSG(LogMessageFW_s* ithis, int32 identNumber, char const* text, char const* args, ...)
{ Vtbl_LogMessageFW const* mtbl = (Vtbl_LogMessageFW const*)getVtbl_ObjectJc(&ithis->base.object, sign_Vtbl_LogMessageFW);
  return mtbl->sendMsg((LogMessageFW_s*)ithis, identNumber, text, args);
}


/**Sends a message. See interface.  */
bool sendMsgTime_iDtzv_LogMessageFile_MSG(LogMessageFW_s* ithis, int32 identNumber, OS_TimeStamp creationTime, char const* text, char const* args, ...)
{ LogMessageFile_MSG_s* thiz = (LogMessageFile_MSG_s*)ithis;
  Vtbl_LogMessageFile_MSG const* mtthis = (Vtbl_LogMessageFile_MSG const*)getVtbl_ObjectJc(&thiz->base.object, sign_Vtbl_LogMessageFile_MSG);
  
  STACKTRC_ENTRY("sendMsgTime_iDtzv_LogMessageFile_MSG");
  
  { 
    
    
    Va_listFW  vaArgs = { 0 };va_start(vaArgs.args, args); vaArgs.typeArgs = args;
    { STACKTRC_LEAVE;
      return mtthis->LogMessageFW.sendMsgVaList(& ((* (thiz)).base.LogMessageFW)/*J2cT1*/, identNumber, creationTime, text, vaArgs, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Sends a message. See interface.  */
bool sendMsgVaList_iDtzv_LogMessageFile_MSG_F(LogMessageFW_s* ithis, int32 identNumber, OS_TimeStamp creationTime, char const* text, Va_listFW args, ThCxt* _thCxt)
{ LogMessageFile_MSG_s* thiz = (LogMessageFile_MSG_s*)ithis;
  Vtbl_LogMessageFile_MSG const* mtthis = (Vtbl_LogMessageFile_MSG const*)getVtbl_ObjectJc(&thiz->base.object, sign_Vtbl_LogMessageFile_MSG);
  
  STACKTRC_TENTRY("sendMsgVaList_iDtzv_LogMessageFile_MSG_F");
  
  { 
    
    
    bool  sent;/*no initvalue*/
    
    LogMessageFWMTB msgOpenClose ; SETMTBJc(msgOpenClose, REFJc (thiz->msgOpenClose), LogMessageFW);
    if(!thiz->bNewFile && thiz->nrofHoursPerFile != 0) 
    { 
      
      
      OS_TimeStamp  timeTest = { 0 };//J2C: constructor for embedded element
      INIT_OS_TimeStamp(/*J2C:static method call*/timeTest);
      
      int32  secDiff;/*no initvalue*/
      set_OS_TimeStamp(timeTest, os_getDateTime());
      secDiff = timeTest.time_sec - thiz->timeOpen.time_sec;
      
      int32  secDiffTest = thiz->nrofHoursPerFile > 0 ? 3600 * thiz->nrofHoursPerFile : -thiz->nrofHoursPerFile;
      if(secDiff >= secDiffTest) 
      { 
        
        if(isOpen_FileWriterJc(& (thiz->file))) 
        { /*:printf("\nclose log-file\n");*/
          
          
          close_FileWriterJc(& (thiz->file), _thCxt);/*catch(IOException exc){  }*/
          
        }
        /*indicate, that a new filename should be used. */
        thiz->bNewFile = true;
      }
    }
    if(!isOpen_FileWriterJc(& (thiz->file))) 
    { 
      
      
      bool  canOpen;/*no initvalue*/
      if(thiz->nrofSecondsToClose > 0) 
      { 
        
        
        OS_TimeStamp  timeTest = { 0 };//J2C: constructor for embedded element
        INIT_OS_TimeStamp(/*J2C:static method call*/timeTest);
        set_OS_TimeStamp(timeTest, os_getDateTime());
        
        int32  secDiff = timeTest.time_sec - thiz->timeClose.time_sec;
        canOpen = (secDiff >= thiz->nrofSecondsToClose);
      }
      else 
      { 
        
        canOpen = true;
      }
      if(canOpen) 
      { 
        
        
        bool  isOpen = false;
        
        bool  shouldOpenWithNewName = false;
        do 
          { 
            
            if(thiz->bNewFile && thiz->posTimestampInFilename >= 0) 
            { 
              
              /**Build a new filename, after nrofHoursPerFile, but also first. */
              set_OS_TimeStamp(thiz->timeOpen, os_getDateTime());
              setLength_StringBufferJc(& (thiz->sDateformatBuffer.sb), 0, _thCxt);/*clear it.*/
              
              format_tu_SimpleDateFormatJc(& (thiz->formatTimestamp), thiz->timeOpen, & (thiz->sDateformatBuffer.sb), & (thiz->formatField), _thCxt);
              
              StringJc sTimeFileOpen ; sTimeFileOpen = toString_StringBufferJc(& ((thiz->sDateformatBuffer.sb).base.object), _thCxt)/*J2C:non-persistent*/;
              replace_StringBuilderJc(& (thiz->sFilenameBuffer.sb), thiz->posTimestampInFilename, thiz->posTimestampInFilename + length_StringJc(sTimeFileOpen), sTimeFileOpen, _thCxt);
            }
            else if(thiz->bNewFile && thiz->posMultifileInFilename >= 0) 
            { 
              
              
              struct { StringBufferJc sb;  char _b[16]; } bufferFormat = { 0 };//J2C: constructor for embedded fix-size-StringBuffer
              init_ObjectJc(&bufferFormat.sb.base.object, sizeof(StringBuilderJc_s) + 20 - 4, 0);
              ctorO_I_StringBuilderJc(&bufferFormat.sb.base.object, 20, _thCxt);
              /***/
              append_I_StringBuilderJc(& (bufferFormat.sb), ++thiz->counterMultifile, _thCxt);
              
              StringJc sCounterMultifile ; sCounterMultifile = toStringNonPersist_StringBuilderJc(& ((bufferFormat.sb).base.object), _thCxt)/*J2C:non-persistent*/;
              replace_StringBuilderJc(& (thiz->sFilenameBuffer.sb), thiz->posMultifileInFilename, thiz->posMultifileInFilename + thiz->currentLengthMultifileNr, sCounterMultifile, _thCxt);
              thiz->currentLengthMultifileNr = length_StringJc(sCounterMultifile);
            }
            else 
            { 
              
              thiz->bNewFile = false;/*reopen the existing one.*/
              
            }
            
            int32  error = open_FileWriterJc(& (thiz->file), toStringNonPersist_StringBuilderJc(& ((thiz->sFilenameBuffer.sb).base.object), _thCxt), !thiz->bNewFile, _thCxt);
            if(error >= 0) 
            { 
              
              isOpen = true;
              thiz->bNewFile = false;
              if(msgOpenClose.ref!= null) 
              { 
                
                /** */
                msgOpenClose.mtbl->sendMsg( (msgOpenClose.ref), thiz->msgIdentOpenClose + kMsgOpen_LogMessageFile_MSG, "open %s", "s", toStringNonPersist_StringBuilderJc(& ((thiz->sFilenameBuffer.sb).base.object), _thCxt));
              }
            }
            else 
            { 
              
              if(false && error == kFileNotFound_FileWriterJc) 
              { /*:System.err.println("file path incorrect");*/
                
                
                thiz->dbg.cntFilePathIncorrect += 1;
              }
              else 
              { 
                
                if(!shouldOpenWithNewName) 
                { 
                  
                  thiz->bNewFile = true;
                  shouldOpenWithNewName = true;
                  thiz->dbg.cntCreateNewBecauseOpenFailed += 1;
                  if(msgOpenClose.ref!= null) 
                  { 
                    
                    sendMsg_z_LogMessageFW( (msgOpenClose.ref), thiz->msgIdentOpenClose + kMsgNewFile_LogMessageFile_MSG, "new File", _thCxt);
                  }
                }
                else 
                { 
                  
                  /**Don't try again if it is tried already. */
                  shouldOpenWithNewName = false;
                  thiz->dbg.cntOpenFailed += 1;
                  if(msgOpenClose.ref!= null) 
                  { 
                    
                    sendMsg_z_LogMessageFW( (msgOpenClose.ref), thiz->msgIdentOpenClose + kMsgOpenError_LogMessageFile_MSG, "fatalOpenError", _thCxt);
                  }
                }
              }
            }
          }while(!isOpen && shouldOpenWithNewName);
      }
    }
    if(isOpen_FileWriterJc(& (thiz->file))) 
    { 
      
      
      struct Entry_MsgDispatcherCore_MSG_t*  parkedEntry;/*no initvalue*/
      do 
        { 
          
          parkedEntry = ((/*J2C:cast from void*/Entry_MsgDispatcherCore_MSG_s*)(poll_ConcurrentLinkedQueueJc(& (thiz->parkedOrders), _thCxt)));
          if(parkedEntry != null) 
          { 
            
            /**There are parked outputs, now output it. */
            mtthis->writeInFile(thiz, parkedEntry->ident, parkedEntry->timestamp, parkedEntry->text, get_va_list_VaArgBuffer(& (parkedEntry->values), _thCxt), _thCxt);
            clean_VaArgBuffer(& (parkedEntry->values), _thCxt);
            parkedEntry->ident = 0;
            offer_ConcurrentLinkedQueueJc(thiz->freeEntries, parkedEntry, _thCxt);
          }
        }while(parkedEntry != null);
      /**Output the current message. */
      mtthis->writeInFile(thiz, identNumber, creationTime, text, args, _thCxt);
      sent = true;
    }
    else 
    { /*:file can't open, */
      
      
      if(thiz->freeEntries != null) 
      { 
        
        
        struct Entry_MsgDispatcherCore_MSG_t*  entry = ((/*J2C:cast from void*/Entry_MsgDispatcherCore_MSG_s*)(poll_ConcurrentLinkedQueueJc(thiz->freeEntries, _thCxt)));
        if(entry == null) 
        { 
          
          /**Not able to send, because no entries. */
          sent = false;
        }
        else 
        { 
          
          /**write the informations to the entry, store it. */
          entry->dst = 0;
          entry->ident = identNumber;
          entry->text = text;
          set_OS_TimeStamp(entry->timestamp, creationTime);
          copyFrom_VaArgBuffer(& (entry->values), text, args, _thCxt);
          offer_ConcurrentLinkedQueueJc(& (thiz->parkedOrders), entry, _thCxt);
          /**Storing message in queue is adequate to send. */
          sent = true;
        }
      }
      else 
      { 
        
        /**Not able to send. No queue available. */
        sent = false;
      }
    }
    { STACKTRC_LEAVE;
      return sent;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
bool sendMsgVaList_iDtzv_LogMessageFile_MSG(LogMessageFW_s* ithis, int32 identNumber, OS_TimeStamp creationTime, char const* text, Va_listFW args, ThCxt* _thCxt)
{ Vtbl_LogMessageFW const* mtbl = (Vtbl_LogMessageFW const*)getVtbl_ObjectJc(&ithis->base.object, sign_Vtbl_LogMessageFW);
  return mtbl->sendMsgVaList((LogMessageFW_s*)ithis, identNumber, creationTime, text, args, _thCxt);
}


/**This method can be called after a cyclic time less than the nrofSecondsToFlush,*/
void flush_LogMessageFile_MSG_F(LogMessageFW_s* ithis, ThCxt* _thCxt)
{ LogMessageFile_MSG_s* thiz = (LogMessageFile_MSG_s*)ithis;
  
  STACKTRC_TENTRY("flush_LogMessageFile_MSG_F");
  
  { 
    
    if(thiz->nrofSecondsToClose > 0 && isOpen_FileWriterJc(& (thiz->file))) 
    { 
      
      
      int32  secDiff;/*no initvalue*/
      
      OS_TimeStamp  timeTest1 = { 0 };//J2C: constructor for embedded element
      INIT_now_OS_TimeStamp(/*J2C:static method call*/timeTest1, true);
      secDiff = timeTest1.time_sec - thiz->timeWrite.time_sec;
      if(secDiff >= thiz->nrofSecondsToClose) 
      { 
        
        close_FileWriterJc(& (thiz->file), _thCxt);/*catch(IOException exc){ dbg.cntCloseError +=1; }*/
        
        if(thiz->maxCntNonFlushedWrite < thiz->cntNonFlushedWrite) 
        { 
          
          /**Gets the maximum. */
          thiz->maxCntNonFlushedWrite = thiz->cntNonFlushedWrite;
        }
        thiz->shouldFlushed = false;
        set_OS_TimeStamp(thiz->timeClose, timeTest1);
        if(REFJc(thiz->msgOpenClose)!= null) 
        { 
          
          sendMsg_z_LogMessageFW(REFJc (thiz->msgOpenClose), thiz->msgIdentOpenClose + kMsgClose_LogMessageFile_MSG, "close", _thCxt);
        }
      }
    }
    if(thiz->nrofSecondsToFlush > 0 && thiz->shouldFlushed) 
    { 
      
      
      int32  secDiff;/*no initvalue*/
      
      OS_TimeStamp  timeTest = { 0 };//J2C: constructor for embedded element
      INIT_now_OS_TimeStamp(/*J2C:static method call*/timeTest, true);
      secDiff = timeTest.time_sec - thiz->timeOpen.time_sec;
      if(secDiff >= thiz->nrofSecondsToFlush) 
      { 
        
        TRY
        { 
          
          flush_FileWriterJc(& (thiz->file), _thCxt);
        }_TRY
        CATCH(IOException, exc)
        
          { 
            
            thiz->dbg.cntCloseError += 1;
          }
        END_TRY
        if(thiz->maxCntNonFlushedWrite < thiz->cntNonFlushedWrite) 
        { 
          
          /**Gets the maximum. */
          thiz->maxCntNonFlushedWrite = thiz->cntNonFlushedWrite;
        }
        thiz->shouldFlushed = false;
      }
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void flush_LogMessageFile_MSG(LogMessageFW_s* ithis, ThCxt* _thCxt)
{ Vtbl_LogMessageFW const* mtbl = (Vtbl_LogMessageFW const*)getVtbl_ObjectJc(&ithis->base.object, sign_Vtbl_LogMessageFW);
  mtbl->flush((LogMessageFW_s*)ithis, _thCxt);
}


/**Tests*/
void writeInFile_LogMessageFile_MSG_F(LogMessageFile_MSG_s* thiz, int32 identNumber, OS_TimeStamp creationTime, char const* text, Va_listFW args, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("writeInFile_LogMessageFile_MSG_F");
  
  { /*:@Java4C.*/
    
    
    
    struct { StringBufferJc sb;  char _b[996]; } bufferFormat = { 0 };//J2C: constructor for embedded fix-size-StringBuffer
    init_ObjectJc(&bufferFormat.sb.base.object, sizeof(StringBuilderJc_s) + 1000 - 4, 0);
    ctorO_I_StringBuilderJc(&bufferFormat.sb.base.object, 1000, _thCxt);
    
    CharSeqJc formattedText ; formattedText;/*no initvalue*/
    if(size_Va_listFW(args) > 0) 
    { 
      
      
      FormatterJc_s  formatter = { 0 };//J2C: constructor for embedded element-ObjectJc
      init_ObjectJc(&(formatter.object), sizeof(formatter), 0); 
      ctorO_SbLo_FormatterJc(/*J2C:static method call*/&(formatter.object), & (bufferFormat.sb), REFJc (thiz->localization), _thCxt);
      TRY
      { 
        
        format_FormatterJc(& (formatter), s0_StringJc(text), (args), _thCxt);
      }_TRY
      CATCH(IllegalFormatConversionException, exc)
      
        { 
          
          
            ( append_z_StringBuilderJc(& (bufferFormat.sb), "error in text format: ", _thCxt)
            , append_z_StringBuilderJc(& (bufferFormat.sb), text, _thCxt)
            );
        }
      CATCH(IllegalFormatConversionException, exc)
      
        { 
          
          
            ( append_z_StringBuilderJc(& (bufferFormat.sb), "error-precision in text format: ", _thCxt)
            , append_z_StringBuilderJc(& (bufferFormat.sb), text, _thCxt)
            );
        }
      CATCH(IllegalFormatConversionException, exc)
      
        { 
          
          
            ( append_z_StringBuilderJc(& (bufferFormat.sb), "error-argument in text format: ", _thCxt)
            , append_z_StringBuilderJc(& (bufferFormat.sb), text, _thCxt)
            );
        }
      CATCH(ExceptionJc, exc)
      
        { 
          
          
            ( append_z_StringBuilderJc(& (bufferFormat.sb), "error-unknown in text format: ", _thCxt)
            , append_z_StringBuilderJc(& (bufferFormat.sb), text, _thCxt)
            );
        }
      END_TRY
      close_FormatterJc(& (formatter), _thCxt);
      formattedText = fromStringBuilderJc_CharSeqJc(& (bufferFormat.sb));/*XX*/
      
    }
    else 
    { 
      
      formattedText = z_StringJc(text);/*without args, don't try to format! The text may contain format characters.    */
      
    }
    
    struct { StringBufferJc sb;  char _b[26]; } bufferTimestamp = { 0 };//J2C: constructor for embedded fix-size-StringBuffer
    init_ObjectJc(&bufferTimestamp.sb.base.object, sizeof(StringBuilderJc_s) + 30 - 4, 0);
    ctorO_I_StringBuilderJc(&bufferTimestamp.sb.base.object, 30, _thCxt);
    format_tu_SimpleDateFormatJc(& (thiz->dateFormat), creationTime, & (bufferTimestamp.sb), & (thiz->formatField), _thCxt);
    setLength_StringBuilderJc(& (thiz->sBuffer.sb), 0, _thCxt);
    
    char const*  sComGo;/*no initvalue*/
    if(identNumber >= 0) 
    { 
      
      sComGo = "+";
    }
    else 
    { 
      
      sComGo = "-";
      identNumber = -identNumber;
    }
    
      ( append_u_StringBuilderJc(& (thiz->sBuffer.sb), & (bufferTimestamp.sb), _thCxt)
      , append_z_StringBuilderJc(& (thiz->sBuffer.sb), "; ", _thCxt)
      , append_I_StringBuilderJc(& (thiz->sBuffer.sb), identNumber, _thCxt)
      , append_z_StringBuilderJc(& (thiz->sBuffer.sb), ";", _thCxt)
      , append_z_StringBuilderJc(& (thiz->sBuffer.sb), sComGo, _thCxt)
      , append_z_StringBuilderJc(& (thiz->sBuffer.sb), ";", _thCxt)
      , append_c_StringBuilderJc(& (thiz->sBuffer.sb), formattedText, _thCxt)
      , append_z_StringBuilderJc(& (thiz->sBuffer.sb), "\r\n", _thCxt)
      );
    TRY
    { 
      
      /**The StringBuilder-instance exists only one time, to prevent dynamically memory.*/
      write_FileWriterJc(& (thiz->file), toStringNonPersist_StringBuilderJc(& ((thiz->sBuffer.sb).base.object), _thCxt), _thCxt);
      /**The file should closed only after nrofSecondsToFlush,*/
      if(thiz->nrofSecondsToFlush == 0) /**The file should closed only after nrofSecondsToFlush,*/
      
      { /*:file.close();*/
        
        
        /**The file should closed only after nrofSecondsToFlush,*/
        flush_FileWriterJc(& (thiz->file), _thCxt);
      }
      else /**The file should closed only after nrofSecondsToFlush,*/
      if(!thiz->shouldFlushed) /**The file should closed only after nrofSecondsToFlush,*/
      
      { 
        
        /**The first write after a flush or in new file, get and store the time. */
        set_OS_TimeStamp(thiz->timeWrite, os_getDateTime());
        /**The file should closed only after nrofSecondsToFlush,*/
        thiz->cntNonFlushedWrite = 1;
        /**The file should closed only after nrofSecondsToFlush,*/
        thiz->shouldFlushed = true;
      }
      else /**The file should closed only after nrofSecondsToFlush,*/
      
      { 
        
        /**A second write in non-flushed file. */
        thiz->cntAllNonFlushedWrite += 1;
        /**The file should closed only after nrofSecondsToFlush,*/
        thiz->cntNonFlushedWrite += 1;
      }
    }_TRY
    CATCH(IOException, exc)
    
      { 
        
        thiz->dbg.cntWriteError += 1;
      }
    END_TRY
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void writeInFile_LogMessageFile_MSG(LogMessageFile_MSG_s* thiz, int32 identNumber, OS_TimeStamp creationTime, char const* text, Va_listFW args, ThCxt* _thCxt)
{ Vtbl_LogMessageFile_MSG const* mtbl = (Vtbl_LogMessageFile_MSG const*)getVtbl_ObjectJc(&thiz->base.object, sign_Vtbl_LogMessageFile_MSG);
  mtbl->writeInFile(thiz, identNumber, creationTime, text, args, _thCxt);
}


/**Closes the file and forces usage of a new file on next open.*/
void close_LogMessageFile_MSG_F(LogMessageFW_s* ithis, ThCxt* _thCxt)
{ LogMessageFile_MSG_s* thiz = (LogMessageFile_MSG_s*)ithis;
  
  STACKTRC_TENTRY("close_LogMessageFile_MSG_F");
  
  { 
    
    
    { 
      
      close_FileWriterJc(& (thiz->file), _thCxt);/*catch(IOException exc){ dbg.cntCloseError +=1; }*/
      
    }
    thiz->bNewFile = true;
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void close_LogMessageFile_MSG(LogMessageFW_s* ithis, ThCxt* _thCxt)
{ Vtbl_LogMessageFW const* mtbl = (Vtbl_LogMessageFW const*)getVtbl_ObjectJc(&ithis->base.object, sign_Vtbl_LogMessageFW);
  mtbl->close((LogMessageFW_s*)ithis, _thCxt);
}

bool isOnline_LogMessageFile_MSG_F(LogMessageFW_s* ithis, ThCxt* _thCxt)
{ LogMessageFile_MSG_s* thiz = (LogMessageFile_MSG_s*)ithis;
  
  STACKTRC_TENTRY("isOnline_LogMessageFile_MSG_F");
  
  { 
    
    { STACKTRC_LEAVE;
      return true;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
bool isOnline_LogMessageFile_MSG(LogMessageFW_s* ithis, ThCxt* _thCxt)
{ Vtbl_LogMessageFW const* mtbl = (Vtbl_LogMessageFW const*)getVtbl_ObjectJc(&ithis->base.object, sign_Vtbl_LogMessageFW);
  return mtbl->isOnline((LogMessageFW_s*)ithis, _thCxt);
}


void finalize_LogMessageFile_MSG_F(ObjectJc* othis, ThCxt* _thCxt)
{ LogMessageFile_MSG_s* thiz = (LogMessageFile_MSG_s*)othis;  //upcasting to the real class.
 STACKTRC_TENTRY("finalize_LogMessageFile_MSG_F");
  finalize_ObjectJc_F(&thiz->sFilenameBuffer.sb.base.object, _thCxt); //J2C: finalizing the embedded instance.
  finalize_ObjectJc_F(&thiz->sDateformatBuffer.sb.base.object, _thCxt); //J2C: finalizing the embedded instance.
  finalize_ObjectJc_F(&thiz->formatTimestamp.base.object, _thCxt); //J2C: finalizing the embedded instance.
  finalize_ObjectJc_F(&thiz->formatField.base.object, _thCxt); //J2C: finalizing the embedded instance.
  finalize_ObjectJc_F(&thiz->file.base.object, _thCxt); //J2C: finalizing the embedded instance.
  CLEAR_REFJc(thiz->msgOpenClose);
  finalize_ObjectJc_F(&thiz->parkedOrders.base.object, _thCxt); //J2C: finalizing the embedded instance.
  finalize_ObjectJc_F(&thiz->dateFormat.base.object, _thCxt); //J2C: finalizing the embedded instance.
  CLEAR_REFJc(thiz->localization);
  CLEAR_REFJc(thiz->timeZone);
  finalize_ObjectJc_F(&thiz->sBuffer.sb.base.object, _thCxt); //J2C: finalizing the embedded instance.
  finalize_ObjectJc_F(&thiz->base.object, _thCxt); //J2C: finalizing the superclass.
  STACKTRC_LEAVE;
}




/**J2C: Reflections and Method-table *************************************************/
const VtblDef_LogMessageFile_MSG mtblLogMessageFile_MSG = {
{ { sign_Vtbl_LogMessageFile_MSG //J2C: Head of methodtable of LogMessageFile_MSG
  , (struct Size_Vtbl_t*)((2 +2) * sizeof(void*)) //J2C:size. NOTE: all elements has the size of void*.
  }
  //J2C: Dynamic methods of the class :LogMessageFile_MSG:
, setLogMessageOpenClose_LogMessageFile_MSG_F //setLogMessageOpenClose
, writeInFile_LogMessageFile_MSG_F //writeInFile
  //J2C: The superclass's methodtable: 
, { { sign_Vtbl_ObjectJc //J2C: Head of methodtable of ObjectJc
    , (struct Size_Vtbl_t*)((5 +2) * sizeof(void*)) //J2C:size. NOTE: all elements has the size of void*.
    }
    //J2C: Dynamic methods of the class :ObjectJc:
  , clone_ObjectJc_F //clone
  , equals_ObjectJc_F //equals
  , finalize_LogMessageFile_MSG_F //finalize
  , hashCode_ObjectJc_F //hashCode
  , toString_ObjectJc_F //toString
  }
  //J2C: The interface's methodtable: 
  //J2C: Vtbl-interfaces of :LogMessageFile_MSG: */
, { { sign_Vtbl_LogMessageFW //J2C: Head of methodtable of LogMessageFW
    , (struct Size_Vtbl_t*)((6 +2) * sizeof(void*)) //J2C:size. NOTE: all elements has the size of void*.
    }
    //J2C: Dynamic methods of the class :LogMessageFW:
  , sendMsgVaList_iDtzv_LogMessageFile_MSG_F //sendMsgVaList
  , flush_LogMessageFile_MSG_F //flush
  , close_LogMessageFile_MSG_F //close
  , isOnline_LogMessageFile_MSG_F //isOnline
  , sendMsg_izv_LogMessageFile_MSG_F //sendMsg
  , sendMsgTime_iDtzv_LogMessageFile_MSG //sendMsgTime
    //J2C: The superclass's methodtable: 
  , { { sign_Vtbl_ObjectJc //J2C: Head of methodtable of ObjectJc
      , (struct Size_Vtbl_t*)((5 +2) * sizeof(void*)) //J2C:size. NOTE: all elements has the size of void*.
      }
      //J2C: Dynamic methods of the class :ObjectJc:
    , clone_ObjectJc_F //clone
    , equals_ObjectJc_F //equals
    , finalize_LogMessageFile_MSG_F //finalize
    , hashCode_ObjectJc_F //hashCode
    , toString_ObjectJc_F //toString
    }
  }
}, { signEnd_Vtbl_ObjectJc, null } }; //Vtbl


 extern_C struct ClassJc_t const refl_ObjectJc;
 static struct superClasses_LogMessageFile_MSG_s_t
 { ObjectArrayJc head;
   ClassOffset_idxVtblJc data[1];
 }superclasses_LogMessageFile_MSG_s =
 { CONST_ObjectArrayJc(ClassOffset_idxVtblJc, 1, OBJTYPE_ClassOffset_idxVtblJc, null, null)
 , { {&refl_ObjectJc, OFFSET_Vtbl(Vtbl_LogMessageFile_MSG, ObjectJc) }
   }
 };

 extern_C struct ClassJc_t const refl_LogMessageFW;
 static struct ifcClasses_LogMessageFile_MSG_s_t
 { ObjectArrayJc head;
   ClassOffset_idxVtblJc data[1];
 }interfaces_LogMessageFile_MSG_s =
 { CONST_ObjectArrayJc(ClassOffset_idxVtblJc, 1, OBJTYPE_ClassOffset_idxVtblJc, null, null)
, { {&refl_LogMessageFW, OFFSET_Vtbl(Vtbl_LogMessageFile_MSG, LogMessageFW) }
  }
};

extern_C struct ClassJc_t const refl_LogMessageFile_MSG_s;
extern_C struct ClassJc_t const refl_ConcurrentLinkedQueueJc_s;
extern_C struct ClassJc_t const refl_Dbg_LogMessageFile_MSG_s;
extern_C struct ClassJc_t const refl_FileWriterJc;
extern_C struct ClassJc_t const refl_LocaleJc;
extern_C struct ClassJc_t const refl_LogMessageFW;
extern_C struct ClassJc_t const refl_OS_TimeStamp;
extern_C struct ClassJc_t const refl_SimpleDateFormatJc;
extern_C struct ClassJc_t const refl_StringBufferJc;
extern_C struct ClassJc_t const refl_StringBuilderJc;
extern_C struct ClassJc_t const refl_StringJc;
extern_C struct ClassJc_t const refl_TextFieldPositionJc;
extern_C struct ClassJc_t const refl_TimeZoneJc;
const struct Reflection_Fields_LogMessageFile_MSG_s_t
{ ObjectArrayJc head; FieldJc data[31];
} refl_Fields_LogMessageFile_MSG_s =
{ CONST_ObjectArrayJc(FieldJc, 31, OBJTYPE_FieldJc, null, &refl_Fields_LogMessageFile_MSG_s)
, {
     { "sFilenameBuffer"
    , 0 //nrofArrayElements
    , &refl_StringBuilderJc
    , kEmbedded_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((LogMessageFile_MSG_s*)(0x1000))->sFilenameBuffer) - (int32)(LogMessageFile_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_LogMessageFile_MSG_s
    }
   , { "sDateformatBuffer"
    , 0 //nrofArrayElements
    , &refl_StringBufferJc
    , kEmbedded_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((LogMessageFile_MSG_s*)(0x1000))->sDateformatBuffer) - (int32)(LogMessageFile_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_LogMessageFile_MSG_s
    }
   , { "sFormatTimestampFilename"
    , 0 //nrofArrayElements
    , &refl_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ //bitModifiers
    , (int16)((int32)(&((LogMessageFile_MSG_s*)(0x1000))->sFormatTimestampFilename) - (int32)(LogMessageFile_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_LogMessageFile_MSG_s
    }
   , { "formatTimestamp"
    , 0 //nrofArrayElements
    , &refl_SimpleDateFormatJc
    , kEmbedded_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((LogMessageFile_MSG_s*)(0x1000))->formatTimestamp) - (int32)(LogMessageFile_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_LogMessageFile_MSG_s
    }
   , { "counterMultifile"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((LogMessageFile_MSG_s*)(0x1000))->counterMultifile) - (int32)(LogMessageFile_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_LogMessageFile_MSG_s
    }
   , { "formatField"
    , 0 //nrofArrayElements
    , &refl_TextFieldPositionJc
    , kEmbedded_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((LogMessageFile_MSG_s*)(0x1000))->formatField) - (int32)(LogMessageFile_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_LogMessageFile_MSG_s
    }
   , { "charsFormatTimestampFilename"
    , 0 //nrofArrayElements
    , REFLECTION_char
    , 4 << kBitPrimitiv_Modifier_reflectJc |kObjectArrayJc_Modifier_reflectJc |kReferencedContainer_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((LogMessageFile_MSG_s*)(0x1000))->charsFormatTimestampFilename) - (int32)(LogMessageFile_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_LogMessageFile_MSG_s
    }
   , { "posTimestampInFilename"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((LogMessageFile_MSG_s*)(0x1000))->posTimestampInFilename) - (int32)(LogMessageFile_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_LogMessageFile_MSG_s
    }
   , { "posMultifileInFilename"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((LogMessageFile_MSG_s*)(0x1000))->posMultifileInFilename) - (int32)(LogMessageFile_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_LogMessageFile_MSG_s
    }
   , { "currentLengthMultifileNr"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((LogMessageFile_MSG_s*)(0x1000))->currentLengthMultifileNr) - (int32)(LogMessageFile_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_LogMessageFile_MSG_s
    }
   , { "file"
    , 0 //nrofArrayElements
    , &refl_FileWriterJc
    , kEmbedded_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((LogMessageFile_MSG_s*)(0x1000))->file) - (int32)(LogMessageFile_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_LogMessageFile_MSG_s
    }
   , { "timeOpen"
    , 0 //nrofArrayElements
    , &refl_OS_TimeStamp
    , kEmbedded_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((LogMessageFile_MSG_s*)(0x1000))->timeOpen) - (int32)(LogMessageFile_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_LogMessageFile_MSG_s
    }
   , { "bNewFile"
    , 0 //nrofArrayElements
    , REFLECTION_bool
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((LogMessageFile_MSG_s*)(0x1000))->bNewFile) - (int32)(LogMessageFile_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_LogMessageFile_MSG_s
    }
   , { "timeWrite"
    , 0 //nrofArrayElements
    , &refl_OS_TimeStamp
    , kEmbedded_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((LogMessageFile_MSG_s*)(0x1000))->timeWrite) - (int32)(LogMessageFile_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_LogMessageFile_MSG_s
    }
   , { "timeClose"
    , 0 //nrofArrayElements
    , &refl_OS_TimeStamp
    , kEmbedded_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((LogMessageFile_MSG_s*)(0x1000))->timeClose) - (int32)(LogMessageFile_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_LogMessageFile_MSG_s
    }
   , { "nrofSecondsToFlush"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((LogMessageFile_MSG_s*)(0x1000))->nrofSecondsToFlush) - (int32)(LogMessageFile_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_LogMessageFile_MSG_s
    }
   , { "nrofSecondsToClose"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((LogMessageFile_MSG_s*)(0x1000))->nrofSecondsToClose) - (int32)(LogMessageFile_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_LogMessageFile_MSG_s
    }
   , { "cntAllNonFlushedWrite"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((LogMessageFile_MSG_s*)(0x1000))->cntAllNonFlushedWrite) - (int32)(LogMessageFile_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_LogMessageFile_MSG_s
    }
   , { "cntNonFlushedWrite"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((LogMessageFile_MSG_s*)(0x1000))->cntNonFlushedWrite) - (int32)(LogMessageFile_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_LogMessageFile_MSG_s
    }
   , { "maxCntNonFlushedWrite"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((LogMessageFile_MSG_s*)(0x1000))->maxCntNonFlushedWrite) - (int32)(LogMessageFile_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_LogMessageFile_MSG_s
    }
   , { "shouldFlushed"
    , 0 //nrofArrayElements
    , REFLECTION_bool
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((LogMessageFile_MSG_s*)(0x1000))->shouldFlushed) - (int32)(LogMessageFile_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_LogMessageFile_MSG_s
    }
   , { "msgOpenClose"
    , 0 //nrofArrayElements
    , &refl_LogMessageFW
    , kEnhancedReference_Modifier_reflectJc /*@*/ |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((LogMessageFile_MSG_s*)(0x1000))->msgOpenClose) - (int32)(LogMessageFile_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_LogMessageFile_MSG_s
    }
   , { "msgIdentOpenClose"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((LogMessageFile_MSG_s*)(0x1000))->msgIdentOpenClose) - (int32)(LogMessageFile_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_LogMessageFile_MSG_s
    }
   , { "nrofHoursPerFile"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((LogMessageFile_MSG_s*)(0x1000))->nrofHoursPerFile) - (int32)(LogMessageFile_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_LogMessageFile_MSG_s
    }
   , { "dbg"
    , 0 //nrofArrayElements
    , &refl_Dbg_LogMessageFile_MSG_s
    , kEmbedded_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((LogMessageFile_MSG_s*)(0x1000))->dbg) - (int32)(LogMessageFile_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_LogMessageFile_MSG_s
    }
   , { "parkedOrders"
    , 0 //nrofArrayElements
    , &refl_ConcurrentLinkedQueueJc_s
    , kEmbedded_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((LogMessageFile_MSG_s*)(0x1000))->parkedOrders) - (int32)(LogMessageFile_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_LogMessageFile_MSG_s
    }
   , { "freeEntries"
    , 0 //nrofArrayElements
    , &refl_ConcurrentLinkedQueueJc_s
    , kReference_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((LogMessageFile_MSG_s*)(0x1000))->freeEntries) - (int32)(LogMessageFile_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_LogMessageFile_MSG_s
    }
   , { "dateFormat"
    , 0 //nrofArrayElements
    , &refl_SimpleDateFormatJc
    , kEmbedded_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((LogMessageFile_MSG_s*)(0x1000))->dateFormat) - (int32)(LogMessageFile_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_LogMessageFile_MSG_s
    }
   , { "localization"
    , 0 //nrofArrayElements
    , &refl_LocaleJc
    , kEnhancedReference_Modifier_reflectJc /*@*/ |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((LogMessageFile_MSG_s*)(0x1000))->localization) - (int32)(LogMessageFile_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_LogMessageFile_MSG_s
    }
   , { "timeZone"
    , 0 //nrofArrayElements
    , &refl_TimeZoneJc
    , kEnhancedReference_Modifier_reflectJc /*@*/ |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((LogMessageFile_MSG_s*)(0x1000))->timeZone) - (int32)(LogMessageFile_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_LogMessageFile_MSG_s
    }
   , { "sBuffer"
    , 0 //nrofArrayElements
    , &refl_StringBuilderJc
    , kEmbedded_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((LogMessageFile_MSG_s*)(0x1000))->sBuffer) - (int32)(LogMessageFile_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_LogMessageFile_MSG_s
    }
} };
const ClassJc refl_LogMessageFile_MSG_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &refl_ObjectJc, &refl_ClassJc) 
, "LogMessageFile_MSG_s"
, (int16)((int32)(&((LogMessageFile_MSG_s*)(0x1000))->base.object) - (int32)(LogMessageFile_MSG_s*)0x1000)
, sizeof(LogMessageFile_MSG_s)
, (FieldJc_Y const*)&refl_Fields_LogMessageFile_MSG_s
, null //method
, &superclasses_LogMessageFile_MSG_s.head.object //superclass
, (ClassOffset_idxVtblJcARRAY*)&interfaces_LogMessageFile_MSG_s //interfaces
, mObjectJc_Modifier_reflectJc
, &mtblLogMessageFile_MSG.mtbl.head
};

/**Helper class for some debug informations.
*/


const char sign_Vtbl_Dbg_LogMessageFile_MSG[] = "Dbg_LogMessageFile_MSG"; //to mark method tables of all implementations


/*Constructor *//**J2C: autogenerated as default constructor. */
struct Dbg_LogMessageFile_MSG_t* ctorM_Dbg_LogMessageFile_MSG(MemC mthis, ThCxt* _thCxt)
{ Dbg_LogMessageFile_MSG_s* thiz = PTR_MemC(mthis, Dbg_LogMessageFile_MSG_s);  //reference casting to the real class.
  int sizeObj = size_MemC(mthis);
  STACKTRC_TENTRY("ctor_Dbg_LogMessageFile_MSG");
  if(sizeof(Dbg_LogMessageFile_MSG_s) > sizeObj) THROW1_s0(IllegalArgumentException, "faut size", sizeObj);
  //j2c: Initialize all class variables:
  {
  }/*J2C:No body for constructor*/

  STACKTRC_LEAVE;
  return thiz;
}


extern_C struct ClassJc_t const refl_Dbg_LogMessageFile_MSG_s;
const struct Reflection_Fields_Dbg_LogMessageFile_MSG_s_t
{ ObjectArrayJc head; FieldJc data[5];
} refl_Fields_Dbg_LogMessageFile_MSG_s =
{ CONST_ObjectArrayJc(FieldJc, 5, OBJTYPE_FieldJc, null, &refl_Fields_Dbg_LogMessageFile_MSG_s)
, {
     { "cntWriteError"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((Dbg_LogMessageFile_MSG_s*)(0x1000))->cntWriteError) - (int32)(Dbg_LogMessageFile_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_Dbg_LogMessageFile_MSG_s
    }
   , { "cntCloseError"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((Dbg_LogMessageFile_MSG_s*)(0x1000))->cntCloseError) - (int32)(Dbg_LogMessageFile_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_Dbg_LogMessageFile_MSG_s
    }
   , { "cntOpenFailed"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((Dbg_LogMessageFile_MSG_s*)(0x1000))->cntOpenFailed) - (int32)(Dbg_LogMessageFile_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_Dbg_LogMessageFile_MSG_s
    }
   , { "cntCreateNewBecauseOpenFailed"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((Dbg_LogMessageFile_MSG_s*)(0x1000))->cntCreateNewBecauseOpenFailed) - (int32)(Dbg_LogMessageFile_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_Dbg_LogMessageFile_MSG_s
    }
   , { "cntFilePathIncorrect"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((Dbg_LogMessageFile_MSG_s*)(0x1000))->cntFilePathIncorrect) - (int32)(Dbg_LogMessageFile_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_Dbg_LogMessageFile_MSG_s
    }
} };
const ClassJc refl_Dbg_LogMessageFile_MSG_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &refl_ObjectJc, &refl_ClassJc) 
, "Dbg_LogMessageFile_MSG_s"
,  0 //position of ObjectJc
, sizeof(Dbg_LogMessageFile_MSG_s)
, (FieldJc_Y const*)&refl_Fields_Dbg_LogMessageFile_MSG_s
, null //method
, null //superclass
, null //interfaces
, 0    //modifiers
};
