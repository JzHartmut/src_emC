/**************************************************************************
 * This file is generated by Java2C
 **copyright***************************************************************
 *************************************************************************/
#include "MsgDisp/MsgDispatcher_MSG.h"
#include <string.h>  //because using memset()
#include <Jc/ReflectionJc.h>   //Reflection concept 
  //basic stacktrace concept
  //reference-association: ExceptionJc
#include "emC/LogMessage.h"  //reference-association: LogMessageStream_FW
#include "J1c/StringPartScanJc.h"  //embedded type in block
#include "Jc/ArraysJc.h"  //reference-association: ArraysJc
#include "Jc/ConcurrentLinkedQueueJc.h"  //reference-association: freeOrders
#include "Jc/FileIoJc.h"  //reference-association: FileDescriptorJc
#include "Jc/ObjectJc.h"  //reference-association: IntegerJc
#include "Jc/StringJc.h"  //embedded type in class data
#include "Jc/SystemJc.h"  //reference-association: SystemJc


/* J2C: Forward declaration of struct ***********************************************/
struct Output_MsgDispatcherCore_MSG_t;

/**The message dispatcher supports to dispatch messages by an ident number to several destinations.

@author Hartmut Schorrig

*/


const char sign_Vtbl_MsgDispatcher_MSG[] = "MsgDispatcher_MSG"; //to mark method tables of all implementations

typedef struct VtblDef_MsgDispatcher_MSG_t { Vtbl_MsgDispatcher_MSG mtbl; VtblHeadJc end; } VtblDef_MsgDispatcher_MSG;
 extern VtblDef_MsgDispatcher_MSG const mtblMsgDispatcher_MSG;

/*Constructor */
struct MsgDispatcher_MSG_t* ctorO_MsgDispatcher_MSG(ObjectJc* othis, int32 maxDispatchEntries, int32 maxQueue, int32 maxOutputs, int32 nrofMixedOutputs, int32 msgIdentQueueOverflow, struct RunnableJc_t* runNoEntryMessage, ThCxt* _thCxt)
{ MsgDispatcher_MSG_s* thiz = (MsgDispatcher_MSG_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_MsgDispatcher_MSG");
  checkConsistence_ObjectJc(othis, sizeof(MsgDispatcher_MSG_s), null, _thCxt);  
  //J2C:super Constructor
  ctorO_MsgDispatcherCore_MSG(/*J2C:static method call*/othis, maxQueue, nrofMixedOutputs, runNoEntryMessage, _thCxt);
  setReflection_ObjectJc(othis, &refl_MsgDispatcher_MSG_s, sizeof(MsgDispatcher_MSG_s));  
  //j2c: Initialize all class variables:
  {
    thiz->outputConsole = create_LogMessageStream_FW(/*J2C:static method call*/(* (out_FileDescriptorJc)), _thCxt);
    thiz->maxDst = 0;
  }
  { 
    ObjectJc *newObj2_1=null, *newObj2_2=null; /*J2C: temporary Objects for new operations
    */
    thiz->base.super.entryMsgBufferOverflow.ident = msgIdentQueueOverflow;
    thiz->base.super.entryMsgBufferOverflow.text = "Message queue overflow; nrof msg=%d";
    
    Entry_MsgDispatcherCore_MSG_Y*  entries = (Entry_MsgDispatcherCore_MSG_Y*)ctorO_ObjectArrayJc((newObj2_1 = alloc_ObjectJc( sizeof(ObjectArrayJc) + (maxQueue) * sizeof(Entry_MsgDispatcherCore_MSG_s), mIsLargeSize_ObjectJc, _thCxt)), maxQueue, sizeof(Entry_MsgDispatcherCore_MSG_s),&refl_Entry_MsgDispatcherCore_MSG_s, 0);
    { int32 idxEntry; 
      for(idxEntry = 0; idxEntry < entries->head.length; idxEntry++)
        { 
          
          //J2C: constructor for embedded element-MemC
          ctorM_Entry_MsgDispatcherCore_MSG(/*J2C:static method call*/build_MemC(&entries->data[idxEntry], sizeof(entries->data[idxEntry])), _thCxt);
        }
    }
    
    int32  idxEntry;/*no initvalue*/
    /**All entries, 1 time allocated, are stored in the freeOrders. From there they are taken*/
    for(idxEntry = 0; idxEntry < maxQueue; idxEntry++)
      { 
        
        add_ConcurrentLinkedQueueJc(thiz->base.super.freeOrders, & (entries->data[idxEntry]), _thCxt);
      }
    
    { 
      ObjectJc *newObj3_1=null, *newObj3_2=null; /*J2C: temporary Objects for new operations
      */
      thiz->base.super.listIdents = (int32_Y*)ctorO_ObjectArrayJc((newObj3_1 = alloc_ObjectJc( sizeof(ObjectArrayJc) + (maxDispatchEntries) * sizeof(int32), mIsLargeSize_ObjectJc, _thCxt)), maxDispatchEntries, sizeof(int32),REFLECTION_int32, 0);  //J2C: assign a new ObjectArrayJc. ;
      thiz->base.super.listBitDst = (int32_Y*)ctorO_ObjectArrayJc((newObj3_2 = alloc_ObjectJc( sizeof(ObjectArrayJc) + (maxDispatchEntries) * sizeof(int32), mIsLargeSize_ObjectJc, _thCxt)), maxDispatchEntries, sizeof(int32),REFLECTION_int32, 0);  //J2C: assign a new ObjectArrayJc. ;
      thiz->base.super.listIdents->data[0] = 0;
      thiz->base.super.listIdents->data[1] = MAX_VALUE_IntegerJc;
      thiz->base.super.listBitDst->data[0] = 0;
      thiz->base.super.listBitDst->data[1] = 0xffffffff;/*this value will be unused because MAX_VALUE don't be used.*/
      
      thiz->base.super.actNrofListIdents = 2;
      activateGC_ObjectJc(newObj3_1, null, _thCxt);
      activateGC_ObjectJc(newObj3_2, null, _thCxt);
    }
    /*allocate the output array: */
    thiz->base.super.outputs = (Output_MsgDispatcherCore_MSG_Y*)ctorO_ObjectArrayJc((newObj2_2 = alloc_ObjectJc( sizeof(ObjectArrayJc) + (maxOutputs) * sizeof(Output_MsgDispatcherCore_MSG_s), mIsLargeSize_ObjectJc, _thCxt)), maxOutputs, sizeof(Output_MsgDispatcherCore_MSG_s),&refl_Output_MsgDispatcherCore_MSG_s, 0);  //J2C: assign a new ObjectArrayJc. ;
    { int32 idxDst; 
      for(idxDst = 0; idxDst < maxOutputs; idxDst++)
        { 
          
          //J2C: constructor for embedded element-MemC
          ctorM_Output_MsgDispatcherCore_MSG(/*J2C:static method call*/build_MemC(&thiz->base.super.outputs->data[idxDst], sizeof(thiz->base.super.outputs->data[idxDst])), _thCxt);
        }
    }
    /**Set default output to console. */
    setOutputRoutine_MsgDispatcher_MSG(thiz, 0, s0_StringJc("CON"), false, true, thiz->outputConsole, _thCxt);/*mConsole*/
    
    setOutputRoutine_MsgDispatcher_MSG(thiz, 1, s0_StringJc("qCON"), true, true, thiz->outputConsole, _thCxt);/*mConsoleQueued*/
    
    setOutputRange_MsgDispatcher_MSG(thiz, 0, MAX_VALUE_IntegerJc, mConsole_MsgDispatcherCore_MSG, mSet_MsgDispatcherCore_MSG, 3, _thCxt);
    activateGC_ObjectJc(newObj2_1, null, _thCxt);
    activateGC_ObjectJc(newObj2_2, null, _thCxt);
  }
  STACKTRC_LEAVE;
  return thiz;
}



/**Gets the internal free entries for sharing with an other log output, */
struct ConcurrentLinkedQueueJc_t* getSharedFreeEntries_MsgDispatcher_MSG(MsgDispatcher_MSG_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getSharedFreeEntries_MsgDispatcher_MSG");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->base.super.freeOrders;
    }
  }
  STACKTRC_LEAVE;
}

void setDefaults_MsgDispatcher_MSG(MsgDispatcher_MSG_s* thiz, StringJc fileOut, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setDefaults_MsgDispatcher_MSG");
  
  { 
    
    setOutputRoutine_MsgDispatcher_MSG(thiz, 0, s0_StringJc("CON"), false, true, thiz->outputConsole, _thCxt);/*mConsole*/
    
    setOutputRoutine_MsgDispatcher_MSG(thiz, 1, s0_StringJc("qCON"), true, true, thiz->outputConsole, _thCxt);/*mConsoleQueued*/
    
    setOutputRange_MsgDispatcher_MSG(thiz, 0, MAX_VALUE_IntegerJc, mConsole_MsgDispatcherCore_MSG, mSet_MsgDispatcherCore_MSG, 3, _thCxt);
  }
  STACKTRC_LEAVE;
}


/**inserts an ident range after given position:*/
int32 insertIdent_MsgDispatcher_MSG(MsgDispatcher_MSG_s* thiz, int32 idx, int32 fromIdent, int32 toIdent, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("insertIdent_MsgDispatcher_MSG");
  
  { 
    
    
    int32  ident0 = thiz->base.super.listIdents->data[idx];
    
    int32  ident3 = thiz->base.super.listIdents->data[idx + 1];
    
    int32  idxFrom;/*no initvalue*/
    if(ident0 < fromIdent && toIdent + 1 < ident3) 
    { 
      
      /**insert two new positions, {..., ident0, fromIdent, toIdent, ident3, ...} :*/
      idxFrom = idx + 1;
      thiz->base.super.actNrofListIdents += 2;/*copy after idx, src from idx+1, because the content at idx is okay. */
      
      arraycopy_SystemJc(/*J2C:static method call*/& ((thiz->base.super.listIdents)->head.object), idx + 1, & ((thiz->base.super.listIdents)->head.object), idx + 3, thiz->base.super.actNrofListIdents - (idx + 3), _thCxt);
      arraycopy_SystemJc(/*J2C:static method call*/& ((thiz->base.super.listBitDst)->head.object), idx + 1, & ((thiz->base.super.listBitDst)->head.object), idx + 3, thiz->base.super.actNrofListIdents - (idx + 3), _thCxt);
      thiz->base.super.listIdents->data[idxFrom] = fromIdent;
      thiz->base.super.listIdents->data[idxFrom + 1] = toIdent + 1;
      /**Copy the mask from range ident0.. to the new positions. */
      thiz->base.super.listBitDst->data[idxFrom] = thiz->base.super.listBitDst->data[idxFrom + 1] = /*? assignment*/thiz->base.super.listBitDst->data[idx];/*listBitDst[idxFrom] |= mask;*/
      
    }
    else if(ident0 < fromIdent) 
    { 
      
      /**insert one new positions, {..., ident0, fromIdent, ident3, ...} :*/
      ASSERT(/*J2C:static method call*/toIdent + 1 == ident3);
      idxFrom = idx + 1;
      thiz->base.super.actNrofListIdents += 1;
      arraycopy_SystemJc(/*J2C:static method call*/& ((thiz->base.super.listIdents)->head.object), idx + 1, & ((thiz->base.super.listIdents)->head.object), idx + 2, thiz->base.super.actNrofListIdents - (idx + 2), _thCxt);
      arraycopy_SystemJc(/*J2C:static method call*/& ((thiz->base.super.listBitDst)->head.object), idx + 1, & ((thiz->base.super.listBitDst)->head.object), idx + 2, thiz->base.super.actNrofListIdents - (idx + 2), _thCxt);
      thiz->base.super.listIdents->data[idxFrom] = fromIdent;
      /**Copy the mask from range ident0.. to the new positions. */
      thiz->base.super.listBitDst->data[idxFrom] = thiz->base.super.listBitDst->data[idx];/*listBitDst[idxFrom] |= mask; */
      
    }
    else if(ident0 == fromIdent && toIdent + 1 < ident3) 
    { 
      
      /**insert one new positions, {..., ident0, toIdent, ident3, ...} :*/
      thiz->base.super.actNrofListIdents += 1;
      idxFrom = idx;
      arraycopy_SystemJc(/*J2C:static method call*/& ((thiz->base.super.listIdents)->head.object), idx + 1, & ((thiz->base.super.listIdents)->head.object), idx + 2, thiz->base.super.actNrofListIdents - (idx + 2), _thCxt);
      arraycopy_SystemJc(/*J2C:static method call*/& ((thiz->base.super.listBitDst)->head.object), idx + 1, & ((thiz->base.super.listBitDst)->head.object), idx + 2, thiz->base.super.actNrofListIdents - (idx + 2), _thCxt);
      thiz->base.super.listIdents->data[idx + 1] = toIdent + 1;
      /**Copy the mask from range ident0.. to the new positions. */
      thiz->base.super.listBitDst->data[idx + 1] = thiz->base.super.listBitDst->data[idx];
    }
    else 
    { 
      
      ASSERT(/*J2C:static method call*/ident0 == fromIdent && toIdent + 1 == ident3);
      idxFrom = idx;/*replace only*/
      
    }
    { STACKTRC_LEAVE;
      return idxFrom;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets a destination interface to a index for dispatching.*/
void setOutputRoutine_MsgDispatcher_MSG(MsgDispatcher_MSG_s* thiz, int32 dstIdx, StringJc name, bool bQueued, bool bText, struct LogMessageFW_t* dst, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setOutputRoutine_MsgDispatcher_MSG");
  
  { 
    
    
    int32  mask;/*no initvalue*/
    if(dstIdx < 0 || dstIdx > thiz->base.super.outputs->head.length) { throw_s0Jc(ident_IllegalArgumentExceptionJc, "dstIdx fault. Hint: an index, not a mask!", 0, &_thCxt->stacktrc, __LINE__); };
    if(thiz->maxDst <= dstIdx) 
    { 
      
      thiz->maxDst = dstIdx + 1;
    }
    /*if(dstIdx >= nrofMixedOutputs)*/
    SETREFJc(thiz->base.super.outputs->data[dstIdx].outputIfc, dst, LogMessageFW_s);
    thiz->base.super.outputs->data[dstIdx].dstInDispatcherThread = bQueued;
    thiz->base.super.outputs->data[dstIdx].bUseText = bText;
    set_StringJc(&(thiz->base.super.outputs->data[dstIdx].name), name);
  }
  STACKTRC_LEAVE;
}


/**Sets the output dispatch bits for the given message number range.*/
int32 setOutputRange_MsgDispatcher_MSG(MsgDispatcher_MSG_s* thiz, int32 fromIdent, int32 toIdent, int32 dst, int32 mode, int32 level, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setOutputRange_MsgDispatcher_MSG");
  
  { 
    
    
    int32  idx1;/*no initvalue*/
    
    int32  idx2;/*no initvalue*/
    
    int32  maskSet = completeDispatchInThreadBits_MsgDispatcher_MSG(thiz, dst, _thCxt);
    if(toIdent == MAX_VALUE_IntegerJc) 
    { /*:the range is from ...inclusive to, let the MAX_VALUE outside, because there should be and end entry,*/
      
      
      toIdent = MAX_VALUE_IntegerJc - 1;
    }
    idx1 = binarySearch_int_ii_ArraysJc(/*J2C:static method call*/thiz->base.super.listIdents/*J2C-error testAndChangeAccess: XY*/, 0, thiz->base.super.actNrofListIdents, fromIdent, _thCxt);
    if(idx1 < 0) idx1 = -idx1 - 2;/*example: nr between idx=2 and 3 returns -4, converted to 2*/
    
    if(idx1 < 0) idx1 = 0;/*if nr before idx = 0, use properties of msg nr=0*/
    /*at idx1 : ident0  <= fromIdent*/
    
    
    int32  ident2 = thiz->base.super.listIdents->data[idx1 + 1];
    
    int32  idx1Mask;/*no initvalue*/
    
    int32  idx2Mask;/*no initvalue*/
    if(toIdent < ident2) 
    { /*:the whole range fromIdent...toIdent is at or between idx1...idx1+1 */
      
      
      idx1Mask = insertIdent_MsgDispatcher_MSG(thiz, idx1, fromIdent, toIdent, _thCxt);
      idx2Mask = idx1Mask + 1;
    }
    else 
    { 
      
      
      int32  ident1 = thiz->base.super.listIdents->data[idx1 + 1];
      idx1Mask = insertIdent_MsgDispatcher_MSG(thiz, idx1, fromIdent, ident1 - 1, _thCxt);/*inserts after idx1, if necessary*/
      
      idx2 = binarySearch_int_ii_ArraysJc(/*J2C:static method call*/thiz->base.super.listIdents/*J2C-error testAndChangeAccess: XY*/, 0, thiz->base.super.actNrofListIdents, toIdent + 1, _thCxt);
      if(idx2 < 0) idx2 = -idx2 - 2;/*example: nr between idx=2 and 3 returns -4, converted to 2*/
      /*at idx2 : ident3 <= toIdent //<= ident3*/
      
      
      int32  ident3 = thiz->base.super.listIdents->data[idx2 + 1];
      
      int32  mask3 = thiz->base.super.listBitDst->data[idx2];
      idx2Mask = insertIdent_MsgDispatcher_MSG(thiz, idx2, toIdent + 1, ident3 - 1, _thCxt);/*inserts before idx2+1, if necessary*/
      
    }
    { int32 imask; 
      for(imask = idx1Mask; imask < idx2Mask; imask++)
        { 
          
          switch(mode){
            case mSet_MsgDispatcherCore_MSG: thiz->base.super.listBitDst->data[imask] = maskSet;break;
            case mAdd_MsgDispatcherCore_MSG: thiz->base.super.listBitDst->data[imask] |= maskSet;break;
            case mRemove_MsgDispatcherCore_MSG: thiz->base.super.listBitDst->data[imask] &= ~(maskSet & mDispatchBits_MsgDispatcherCore_MSG);break;
            default: { throw_s0Jc(ident_IllegalArgumentExceptionJc, "failed mode", 0, &_thCxt->stacktrc, __LINE__); return 0; };
          }/*switch*/;
        }
    }
    { STACKTRC_LEAVE;
      return 0;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the output from a String content.*/
StringJc setOutputFromString_MsgDispatcher_MSG(MsgDispatcher_MSG_s* thiz, StringJc ctrl, struct StringBuilderJc_t* errorBuffer, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setOutputFromString_MsgDispatcher_MSG");
  
  { 
    
    
    StringJc sError ; sError = null_StringJc/*J2C:non-persistent*/;
    if(errorBuffer != null) 
    { 
      
      setLength_StringBuilderJc(errorBuffer, 0, _thCxt);
    }
    
    StringPartScanJc_s  spCtrl = { 0 };//J2C: constructor for embedded element-ObjectJc
    init_ObjectJc(&(spCtrl.base.object), sizeof(spCtrl), 0); 
    ctorO_Cs_StringPartScanJc(/*J2C:static method call*/&(spCtrl.base.object), ctrl, _thCxt);
    setIgnoreWhitespaces_StringPartJc(& ((spCtrl).base.super), true, _thCxt);
    setIgnoreComment_SS_StringPartJc(& ((spCtrl).base.super), s0_StringJc("/*"), s0_StringJc("*/"), _thCxt);
    setIgnoreEndlineComment_S_StringPartJc(& ((spCtrl).base.super), s0_StringJc("//"), _thCxt);
    
    bool  continueAll = true;
    TRY
    { 
      
      do 
        { 
          
          
          int32  fromIdent;/*no initvalue*/
          
          int32  toIdent;/*no initvalue*/
          if(
          ( seekNoWhitespaceOrComments_StringPartJc(& ((spCtrl).base.super), _thCxt)
          , length_StringPartJc((&(spCtrl).base.object), _thCxt)
          ) == 0) 
          { 
            
            continueAll = false;/*finish.*/
            
          }
          else if(
          ( scanInteger_StringPartScanJc(& (spCtrl), _thCxt)
          , scanOk_StringPartScanJc(& (spCtrl), _thCxt)
          )) 
          { 
            
            fromIdent = (int32 /*J2C_cast*/)getLastScannedIntegerNumber_StringPartScanJc(& (spCtrl), _thCxt);
            toIdent = -1;
            if(
            ( scan_Cs_StringPartScanJc(& (spCtrl), z_StringJc(".."), _thCxt)
            , scanInteger_StringPartScanJc(& (spCtrl), _thCxt)
            , scanOk_StringPartScanJc(& (spCtrl), _thCxt)
            )) 
            { 
              
              toIdent = (int32 /*J2C_cast*/)getLastScannedIntegerNumber_StringPartScanJc(& (spCtrl), _thCxt);
            }
            if(!
            ( scan_Cs_StringPartScanJc(& (spCtrl), z_StringJc(":"), _thCxt)
            , scanOk_StringPartScanJc(& (spCtrl), _thCxt)
            )) 
            { 
              
              sError = z_StringJc(toIdent == -1 ? "\":\"or \"..\" expected" : "\":\" expected")/*J2C:non-persistent*/;
            }
            else 
            { 
              
              if(toIdent == -1) 
              { 
                
                toIdent = fromIdent;
              }
              if(
              ( scanHexOrDecimal_StringPartScanJc(& (spCtrl), 8, _thCxt)
              , scanOk_StringPartScanJc(& (spCtrl), _thCxt)
              )) 
              { 
                
                
                int32  dst = (int32 /*J2C_cast*/)getLastScannedIntegerNumber_StringPartScanJc(& (spCtrl), _thCxt);
                setOutputRange_MsgDispatcher_MSG(thiz, fromIdent, toIdent, dst, mSet_MsgDispatcherCore_MSG, 3, _thCxt);
                if(!
                ( scan_Cs_StringPartScanJc(& (spCtrl), z_StringJc(";"), _thCxt)
                , scanOk_StringPartScanJc(& (spCtrl), _thCxt)
                )) 
                { 
                  
                  sError = z_StringJc("\";\" expected after number-output.")/*J2C:non-persistent*/;
                }
              }
              else 
              { 
                
                
                bool  continueEntry = true;
                
                int32  mode = mSet_MsgDispatcherCore_MSG;
                do 
                  { 
                    
                    
                    StringJc sOutput ; sOutput = null_StringJc/*J2C:non-persistent*/;
                    if(
                  ( scan_Cs_StringPartScanJc(& (spCtrl), z_StringJc("+"), _thCxt)
                  , scanOk_StringPartScanJc(& (spCtrl), _thCxt)
                  )) 
                    { 
                      
                      mode = mAdd_MsgDispatcherCore_MSG;
                    }
                    else if(
                  ( scan_Cs_StringPartScanJc(& (spCtrl), z_StringJc("-"), _thCxt)
                  , scanOk_StringPartScanJc(& (spCtrl), _thCxt)
                  )) 
                    { 
                      
                      mode = mRemove_MsgDispatcherCore_MSG;
                    }
                    else if(
                  ( scan_Cs_StringPartScanJc(& (spCtrl), z_StringJc(";"), _thCxt)
                  , scanOk_StringPartScanJc(& (spCtrl), _thCxt)
                  )) 
                    { 
                      
                      continueEntry = false;
                    }
                    else 
                    { 
                      
                      if(mode != mSet_MsgDispatcherCore_MSG) 
                      { 
                        
                        sError = z_StringJc("\"+\" or \"-\" or \";\" expected")/*J2C:non-persistent*/;
                      }
                    }
                    if(continueEntry && sError.ref== null) 
                    { 
                      
                      if(
                    ( scanIdentifier_StringPartScanJc(& (spCtrl), _thCxt)
                    , scanOk_StringPartScanJc(& (spCtrl), _thCxt)
                    )) 
                      { 
                        CharSeqJc _temp10_1; /*J2C: temporary references for concatenation */
                        
                        sOutput = 
                      ( _temp10_1= getLastScannedString_StringPartScanJc(& (spCtrl), _thCxt)
                      , toString_CharSeqJc(_temp10_1/*J1cT2*/)
                      )/*J2C:non-persistent*/;
                      }
                      else 
                      { 
                        
                        sError = z_StringJc("\"DST\" expected, DST should be an identifier.")/*J2C:non-persistent*/;
                      }
                      if(sError.ref== null) 
                      { 
                        
                        ASSERT(/*J2C:static method call*/sOutput.ref!= null);
                        
                        int32  bitOutput = -1;
                        
                        int32  idxDst = 0;
                        
                        while(idxDst < thiz->base.super.outputs->head.length && bitOutput == -1)
                          { 
                            
                            if(thiz->base.super.outputs->data[idxDst].name.ref!= null && equals_StringJc(thiz->base.super.outputs->data[idxDst].name, sOutput)) 
                            { 
                              
                              bitOutput = 1 << idxDst;
                            }
                            else 
                            { 
                              
                              idxDst++;
                            }
                          }
                        if(bitOutput == -1) 
                        { 
                          
                          if(errorBuffer != null) 
                          { 
                            
                            
                          ( append_z_StringBuilderJc(errorBuffer, "Output not found:", _thCxt)
                          , append_c_StringBuilderJc(errorBuffer, sOutput, _thCxt)
                          );
                          }
                          sError = sOutput/*J2C:non-persistent*/;/*short variant if buffer isn't given.*/
                          
                          continueAll = false;
                        }
                        else 
                        { 
                          
                          setOutputRange_MsgDispatcher_MSG(thiz, fromIdent, toIdent, bitOutput, mode, 3, _thCxt);
                          mode = -1;/*other mode as mSet expected.*/
                          
                        }
                      }
                    }
                  }while(sError.ref== null && continueEntry && continueAll);
              }/*if hexInt else ident;*/
              
            }/*: scanned*/
            
          }
          else 
          { 
            
            sError = z_StringJc("Number for first message to dispatch expected")/*J2C:non-persistent*/;
            continueAll = false;
          }
        }while(continueAll && sError.ref== null);
    }_TRY
    CATCH(ParseException, exc)
    
      { 
        
        sError = getMessage_ExceptionJc(exc, _thCxt)/*J2C:non-persistent*/;
      }
    END_TRY
    if(sError.ref!= null && errorBuffer != null && length_StringBuilderJc(errorBuffer) == 0) 
    { 
      CharSeqJc _thCxtRef3_1;
      
      int32  nrofCharsRest = capacity_StringBuilderJc(errorBuffer) - length_StringJc(sError) - 5;
      /**Prevent Buffer expansion, use rest size. */
      
        ( append_c_StringBuilderJc(errorBuffer, sError, _thCxt)
        , append_z_StringBuilderJc(errorBuffer, " at:", _thCxt)
        , append_c_StringBuilderJc(errorBuffer, ( _thCxtRef3_1 = getCurrent_StringPartJc(& ((spCtrl).base.super), nrofCharsRest, _thCxt)), _thCxt)
        );
      releaseUserBuffer_ThreadContext_emC(PTR_CharSeqJc(_thCxtRef3_1), _thCxt);
    }
    close_StringPartScanJc_F(& ((spCtrl).base.super), _thCxt);
    { STACKTRC_LEAVE;
      return sError;
    }
  }
  STACKTRC_LEAVE;
}


/**Writes the msg dispatching outputs in file. */
bool reportOutput_MsgDispatcher_MSG(MsgDispatcher_MSG_s* thiz, struct FileWriterJc_t* file, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("reportOutput_MsgDispatcher_MSG");
  
  { 
    
    
    bool  bOk = true;
    TRY
    { 
      
      write_FileWriterJc(file, s0_StringJc("//Syntax-Example\n"), _thCxt);
      write_FileWriterJc(file, s0_StringJc("//  1200..1257: +File +qCON -CON;\n"), _thCxt);
      write_FileWriterJc(file, s0_StringJc("//  4567:File;\n"), _thCxt);
      write_FileWriterJc(file, s0_StringJc("//Ident number from..to or only one ident number.\n"), _thCxt);
      write_FileWriterJc(file, s0_StringJc("//\":\" and \";\" are obligatory. Whitespaces in a line and line end comment are allowed.\n"), _thCxt);
      write_FileWriterJc(file, s0_StringJc("//if first DST without \"+\" or \"-\": Redirect first only to this destination, all existing dst are deleted.\n"), _thCxt);
      write_FileWriterJc(file, s0_StringJc("//All following dst have to be separated with \"+\" or \"-\":\n"), _thCxt);
      write_FileWriterJc(file, s0_StringJc("//\"+\" means: use Dst, \"-\" means, don't use, delete if exists before.\n"), _thCxt);
      write_FileWriterJc(file, s0_StringJc("//at exampe switch off file output for a single ident, than write:\n"), _thCxt);
      write_FileWriterJc(file, s0_StringJc("//1234:-File;  \n"), _thCxt);
      write_FileWriterJc(file, s0_StringJc("\n//All existing dst (destinations):\n"), _thCxt);
      
      struct { StringBufferJc sb;  char _b[196]; } line = { 0 };//J2C: constructor for embedded fix-size-StringBuffer
      init_ObjectJc(&line.sb.base.object, sizeof(StringBuilderJc_s) + 200 - 4, 0);
      ctorO_I_StringBuilderJc(&line.sb.base.object, 200, _thCxt);
      { int32 ii; 
        for(ii = 0; ii < thiz->maxDst; ii++)
          { 
            
            setLength_StringBuilderJc(& (line.sb), 0, _thCxt);
            
            struct Output_MsgDispatcherCore_MSG_t*  dst = & (thiz->base.super.outputs->data[ii]);
            if(REFJc(dst->outputIfc)!= null) 
            { 
              
              
              ( append_z_StringBuilderJc(& (line.sb), "//", _thCxt)
              , append_I_StringBuilderJc(& (line.sb), ii, _thCxt)
              , append_z_StringBuilderJc(& (line.sb), ": ", _thCxt)
              , append_c_StringBuilderJc(& (line.sb), dst->name, _thCxt)
              );
              if(dst->dstInDispatcherThread) 
              { 
                
                append_z_StringBuilderJc(& (line.sb), " - queued", _thCxt);
              }
              append_z_StringBuilderJc(& (line.sb), ";\n", _thCxt);
              write_FileWriterJc(file, toString_StringBuilderJc(& ((line.sb).base.object), _thCxt), _thCxt);
            }
          }
      }
      write_FileWriterJc(file, s0_StringJc("\n//All existing dispatching entries:\n"), _thCxt);
      { int32 ii; 
        for(ii = 0; ii < thiz->base.super.actNrofListIdents - 1; ii++)
          { 
            
            
            int32  ident1 = thiz->base.super.listIdents->data[ii];
            
            int32  ident2 = thiz->base.super.listIdents->data[ii + 1] - 1;
            setLength_StringBuilderJc(& (line.sb), 0, _thCxt);
            append_I_StringBuilderJc(& (line.sb), ident1, _thCxt);
            if(ident2 != ident1) 
            { 
              
              /**not single message ident */
              
              ( append_z_StringBuilderJc(& (line.sb), "..", _thCxt)
              , append_I_StringBuilderJc(& (line.sb), ident2, _thCxt)
              );
            }
            append_z_StringBuilderJc(& (line.sb), ":", _thCxt);
            
            int32  bitDst = thiz->base.super.listBitDst->data[ii];
            
            bool  bFirst = true;
            
            int32  maskBitDst = 1;
            { int32 iDst; 
              for(iDst = 0; iDst < thiz->maxDst; iDst++)
                { 
                  
                  if((bitDst & maskBitDst) != 0) 
                  { 
                    
                    
                    struct Output_MsgDispatcherCore_MSG_t*  dst = & (thiz->base.super.outputs->data[iDst]);
                    if(REFJc(dst->outputIfc)!= null) 
                    { 
                      
                      if(!bFirst) 
                      { 
                        
                        append_z_StringBuilderJc(& (line.sb), "+", _thCxt);
                      }
                      else 
                      { 
                        
                        bFirst = false;
                      }
                      append_c_StringBuilderJc(& (line.sb), dst->name, _thCxt);
                    }
                  }
                  if(iDst < thiz->base.super.nrofMixedOutputs) 
                  { 
                    
                    /**Test next bit. */
                    maskBitDst <<= 1;
                  }
                  else 
                  { 
                    
                    
                    int32  idxNonMixedDst = ((bitDst & thiz->base.super.mDstOneOutput) >> thiz->base.super.nrofMixedOutputs) - 1 + thiz->base.super.nrofMixedOutputs;
                    if(idxNonMixedDst >= thiz->base.super.nrofMixedOutputs) 
                    { 
                      
                      
                      struct Output_MsgDispatcherCore_MSG_t*  dst = & (thiz->base.super.outputs->data[iDst]);
                      if(REFJc(dst->outputIfc)!= null) 
                      { 
                        
                        if(!bFirst) 
                        { 
                          
                          append_z_StringBuilderJc(& (line.sb), "+", _thCxt);
                        }
                        else 
                        { 
                          
                          bFirst = false;
                        }
                        append_c_StringBuilderJc(& (line.sb), dst->name, _thCxt);
                      }
                    }
                  }
                }/*for,all dst of one line*/
                
            }
            append_z_StringBuilderJc(& (line.sb), ";\n", _thCxt);
            write_FileWriterJc(file, toString_StringBuilderJc(& ((line.sb).base.object), _thCxt), _thCxt);
          }
      }
    }_TRY
    CATCH(IOException, exc)
    
      { 
        
        bOk = false;/*end it. write no more lines. It may be disk is full.*/
        
      }
    END_TRY
    { STACKTRC_LEAVE;
      return bOk;
    }
  }
  STACKTRC_LEAVE;
}


/**Completes a destination bit mask with the information, whether any destinations are used*/
int32 completeDispatchInThreadBits_MsgDispatcher_MSG(MsgDispatcher_MSG_s* thiz, int32 dstBits, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("completeDispatchInThreadBits_MsgDispatcher_MSG");
  
  { 
    
    
    int32  dstBitRet = dstBits;
    /**Assert: The bits should not be negative, because elsewhere >> shifts a 1-bit into, */
    ASSERT(/*J2C:static method call*/dstBits >= 0);
    
    int32  idst = 0;
    
    while(dstBits != 0)
      { 
        
        if((dstBits & 1) != 0) 
        { 
          
          if(thiz->base.super.outputs->data[idst].dstInDispatcherThread) 
          { 
            
            dstBitRet |= mDispatchInDispatcherThread_MsgDispatcherCore_MSG;
          }
          else 
          { 
            
            dstBitRet |= mDispatchInCallingThread_MsgDispatcherCore_MSG;
          }
        }
        dstBits >>= 1;
        idst += 1;
      }
    { STACKTRC_LEAVE;
      return dstBitRet;
    }
  }
  STACKTRC_LEAVE;
}


/**It's a debug helper. The method is empty, but it is a mark to set a breakpoint. */
void stop_MsgDispatcher_MSG(MsgDispatcher_MSG_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("stop_MsgDispatcher_MSG");
  
  { 
    
    
  }
  STACKTRC_LEAVE;
}


/**close and flush forces the dispatching of the messages in the queue. */
void close_MsgDispatcher_MSG(LogMessageFW_s* ithis, ThCxt* _thCxt)
{ MsgDispatcher_MSG_s* thiz = (MsgDispatcher_MSG_s*)ithis;
  
  STACKTRC_TENTRY("close_MsgDispatcher_MSG");
  
  { /*:flush(); //do the same*/
    
    
    dispatchQueuedMsg_MsgDispatcherCore_MSG(& ((* (thiz)).base.super), _thCxt);
  }
  STACKTRC_LEAVE;
}


/**flush forces the dispatching of the messages in the queue. */
void flush_MsgDispatcher_MSG(LogMessageFW_s* ithis, ThCxt* _thCxt)
{ MsgDispatcher_MSG_s* thiz = (MsgDispatcher_MSG_s*)ithis;
  
  STACKTRC_TENTRY("flush_MsgDispatcher_MSG");
  
  { 
    
    dispatchQueuedMsg_MsgDispatcherCore_MSG(& ((* (thiz)).base.super), _thCxt);
  }
  STACKTRC_LEAVE;
}



/**J2C: Reflections and Method-table *************************************************/
const VtblDef_MsgDispatcher_MSG mtblMsgDispatcher_MSG = {
{ { sign_Vtbl_MsgDispatcher_MSG //J2C: Head of methodtable of MsgDispatcher_MSG
  , (struct Size_Vtbl_t*)((0 +2) * sizeof(void*)) //J2C:size. NOTE: all elements has the size of void*.
  }
  //J2C: The superclass's methodtable: 
, { { sign_Vtbl_MsgDispatcherCore_MSG //J2C: Head of methodtable of MsgDispatcherCore_MSG
    , (struct Size_Vtbl_t*)((1 +2) * sizeof(void*)) //J2C:size. NOTE: all elements has the size of void*.
    }
    //J2C: Dynamic methods of the class :MsgDispatcherCore_MSG:
  , setIdThreadForMsgDispatching_MsgDispatcherCore_MSG_F //setIdThreadForMsgDispatching
    //J2C: The superclass's methodtable: 
  , { { sign_Vtbl_ObjectJc //J2C: Head of methodtable of ObjectJc
      , (struct Size_Vtbl_t*)((5 +2) * sizeof(void*)) //J2C:size. NOTE: all elements has the size of void*.
      }
      //J2C: Dynamic methods of the class :ObjectJc:
    , clone_ObjectJc_F //clone
    , equals_ObjectJc_F //equals
    , finalize_MsgDispatcherCore_MSG_F //finalize
    , hashCode_ObjectJc_F //hashCode
    , toString_ObjectJc_F //toString
    }
    //J2C: The interface's methodtable: 
    //J2C: Vtbl-interfaces of :MsgDispatcher_MSG: */
  , { { sign_Vtbl_LogMessageFW //J2C: Head of methodtable of LogMessageFW
      , (struct Size_Vtbl_t*)((6 +2) * sizeof(void*)) //J2C:size. NOTE: all elements has the size of void*.
      }
      //J2C: Dynamic methods of the class :LogMessageFW:
    , sendMsgVaList_iDtzv_MsgDispatcherCore_MSG //sendMsgVaList
    , flush_MsgDispatcher_MSG //flush
    , close_MsgDispatcher_MSG //close
    , isOnline_MsgDispatcherCore_MSG //isOnline
    , sendMsg_izv_MsgDispatcherCore_MSG //sendMsg
    , sendMsgTime_iDtzv_MsgDispatcherCore_MSG //sendMsgTime
      //J2C: The superclass's methodtable: 
    , { { sign_Vtbl_ObjectJc //J2C: Head of methodtable of ObjectJc
        , (struct Size_Vtbl_t*)((5 +2) * sizeof(void*)) //J2C:size. NOTE: all elements has the size of void*.
        }
        //J2C: Dynamic methods of the class :ObjectJc:
      , clone_ObjectJc_F //clone
      , equals_ObjectJc_F //equals
      , finalize_MsgDispatcherCore_MSG_F //finalize
      , hashCode_ObjectJc_F //hashCode
      , toString_ObjectJc_F //toString
      }
    }
  }
}, { signEnd_Vtbl_ObjectJc, null } }; //Vtbl


 extern_C struct ClassJc_t const refl_MsgDispatcherCore_MSG_s;
 static struct superClasses_MsgDispatcher_MSG_s_t
 { ObjectArrayJc head;
   ClassOffset_idxVtblJc data[1];
 }superclasses_MsgDispatcher_MSG_s =
 { CONST_ObjectArrayJc(ClassOffset_idxVtblJc, 1, OBJTYPE_ClassOffset_idxVtblJc, null, null)
 , { {&refl_MsgDispatcherCore_MSG_s, OFFSET_Vtbl(Vtbl_MsgDispatcher_MSG, MsgDispatcherCore_MSG) }
   }
 };

extern_C struct ClassJc_t const refl_MsgDispatcher_MSG_s;
extern_C struct ClassJc_t const refl_LogMessageFW;
const struct Reflection_Fields_MsgDispatcher_MSG_s_t
{ ObjectArrayJc head; FieldJc data[2];
} refl_Fields_MsgDispatcher_MSG_s =
{ CONST_ObjectArrayJc(FieldJc, 2, OBJTYPE_FieldJc, null, &refl_Fields_MsgDispatcher_MSG_s)
, {
     { "outputConsole"
    , 0 //nrofArrayElements
    , &refl_LogMessageFW
    , kReference_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((MsgDispatcher_MSG_s*)(0x1000))->outputConsole) - (int32)(MsgDispatcher_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_MsgDispatcher_MSG_s
    }
   , { "maxDst"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((MsgDispatcher_MSG_s*)(0x1000))->maxDst) - (int32)(MsgDispatcher_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_MsgDispatcher_MSG_s
    }
} };
const ClassJc refl_MsgDispatcher_MSG_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &refl_ObjectJc, &refl_ClassJc) 
, "MsgDispatcher_MSG_s"
,  0 //position of ObjectJc
, sizeof(MsgDispatcher_MSG_s)
, (FieldJc_Y const*)&refl_Fields_MsgDispatcher_MSG_s
, null //method
, &superclasses_MsgDispatcher_MSG_s.head.object //superclass
, null //interfaces
, 0    //modifiers
, &mtblMsgDispatcher_MSG.mtbl.head
};

/**Class to organize a dispatcher thread. This class can be used if another cyclic thread is not available
in the users application space which runs the {@link MsgDispatcher#tickAndFlushOrClose()} cyclically.
If the user has a cyclic thread, in embedded systems the background loop can be used too, 
then this instance is not necessary. */


const char sign_Vtbl_DispatcherThread_MsgDispatcher_MSG[] = "DispatcherThread_MsgDispatcher_MSG"; //to mark method tables of all implementations

typedef struct VtblDef_DispatcherThread_MsgDispatcher_MSG_t { Vtbl_DispatcherThread_MsgDispatcher_MSG mtbl; VtblHeadJc end; } VtblDef_DispatcherThread_MsgDispatcher_MSG;
 extern VtblDef_DispatcherThread_MsgDispatcher_MSG const mtblDispatcherThread_MsgDispatcher_MSG;

/*Constructor */
struct DispatcherThread_MsgDispatcher_MSG_t* ctorO_DispatcherThread_MsgDispatcher_MSG(struct MsgDispatcher_MSG_t* outer, ObjectJc* othis, int32 cycleMillisec, ThCxt* _thCxt)
{ DispatcherThread_MsgDispatcher_MSG_s* thiz = (DispatcherThread_MsgDispatcher_MSG_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_DispatcherThread_MsgDispatcher_MSG");
  checkConsistence_ObjectJc(othis, sizeof(DispatcherThread_MsgDispatcher_MSG_s), null, _thCxt);  
  //J2C:super Constructor
  ctorO_z_ThreadJc(/*J2C:static method call*/othis, "MsgDisptch", _thCxt);
  setReflection_ObjectJc(othis, &refl_DispatcherThread_MsgDispatcher_MSG_s, sizeof(DispatcherThread_MsgDispatcher_MSG_s));  
  thiz->outer = outer;
  //j2c: Initialize all class variables:
  {
  }
  { 
    
    thiz->cycleMillisec = cycleMillisec;
    start_ThreadJc(& ((* (thiz)).base.super), -1, _thCxt);
  }
  STACKTRC_LEAVE;
  return thiz;
}


void run_DispatcherThread_MsgDispatcher_MSG_F(ObjectJc* ithis, ThCxt* _thCxt)
{ DispatcherThread_MsgDispatcher_MSG_s* thiz = (DispatcherThread_MsgDispatcher_MSG_s*)ithis;
  
  STACKTRC_TENTRY("run_DispatcherThread_MsgDispatcher_MSG_F");
  
  { 
    
    
    while(true)
      { 
        
        TRY
        { 
          
          sleep_ThreadJc(/*J2C:static method call*/thiz->cycleMillisec, _thCxt);
        }_TRY
        CATCH(InterruptedException, exc)
        
          { 
            
            
          }
        END_TRY
        tickAndFlushOrClose_MsgDispatcherCore_MSG(((/*J2C:cast from DispatcherThread_MsgDispatcher_MSG_s*/MsgDispatcherCore_MSG_s*)(thiz)), _thCxt);
      }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void run_DispatcherThread_MsgDispatcher_MSG(ObjectJc* ithis, ThCxt* _thCxt)
{ Vtbl_RunnableJc const* mtbl = (Vtbl_RunnableJc const*)getVtbl_ObjectJc(ithis, sign_Vtbl_RunnableJc);
  mtbl->run(ithis, _thCxt);
}



/**J2C: Reflections and Method-table *************************************************/
const VtblDef_DispatcherThread_MsgDispatcher_MSG mtblDispatcherThread_MsgDispatcher_MSG = {
{ { sign_Vtbl_DispatcherThread_MsgDispatcher_MSG //J2C: Head of methodtable of DispatcherThread_MsgDispatcher_MSG
  , (struct Size_Vtbl_t*)((0 +2) * sizeof(void*)) //J2C:size. NOTE: all elements has the size of void*.
  }
  //J2C: The superclass's methodtable: 
, { { sign_Vtbl_ThreadJc //J2C: Head of methodtable of ThreadJc
    , (struct Size_Vtbl_t*)((0 +2) * sizeof(void*)) //J2C:size. NOTE: all elements has the size of void*.
    }
    //J2C: The superclass's methodtable: 
  , { { sign_Vtbl_ObjectJc //J2C: Head of methodtable of ObjectJc
      , (struct Size_Vtbl_t*)((5 +2) * sizeof(void*)) //J2C:size. NOTE: all elements has the size of void*.
      }
      //J2C: Dynamic methods of the class :ObjectJc:
    , clone_ObjectJc_F //clone
    , equals_ObjectJc_F //equals
    , finalize_ObjectJc_F //finalize
    , hashCode_ObjectJc_F //hashCode
    , toString_ObjectJc_F //toString
    }
    //J2C: The interface's methodtable: 
    //J2C: Vtbl-interfaces of :DispatcherThread_MsgDispatcher_MSG: */
  , { { sign_Vtbl_RunnableJc //J2C: Head of methodtable of RunnableJc
      , (struct Size_Vtbl_t*)((1 +2) * sizeof(void*)) //J2C:size. NOTE: all elements has the size of void*.
      }
      //J2C: Dynamic methods of the class :RunnableJc:
    , run_DispatcherThread_MsgDispatcher_MSG_F //run
      //J2C: The superclass's methodtable: 
    , { { sign_Vtbl_ObjectJc //J2C: Head of methodtable of ObjectJc
        , (struct Size_Vtbl_t*)((5 +2) * sizeof(void*)) //J2C:size. NOTE: all elements has the size of void*.
        }
        //J2C: Dynamic methods of the class :ObjectJc:
      , clone_ObjectJc_F //clone
      , equals_ObjectJc_F //equals
      , finalize_ObjectJc_F //finalize
      , hashCode_ObjectJc_F //hashCode
      , toString_ObjectJc_F //toString
      }
    }
  }
}, { signEnd_Vtbl_ObjectJc, null } }; //Vtbl


 extern_C struct ClassJc_t const refl_ThreadJc;
 static struct superClasses_DispatcherThread_MsgDispatcher_MSG_s_t
 { ObjectArrayJc head;
   ClassOffset_idxVtblJc data[1];
 }superclasses_DispatcherThread_MsgDispatcher_MSG_s =
 { CONST_ObjectArrayJc(ClassOffset_idxVtblJc, 1, OBJTYPE_ClassOffset_idxVtblJc, null, null)
 , { {&refl_ThreadJc, OFFSET_Vtbl(Vtbl_DispatcherThread_MsgDispatcher_MSG, ThreadJc) }
   }
 };

extern_C struct ClassJc_t const refl_DispatcherThread_MsgDispatcher_MSG_s;
extern_C struct ClassJc_t const refl_ConcurrentLinkedQueueJc_s;
extern_C struct ClassJc_t const refl_Entry_MsgDispatcherCore_MSG_s;
extern_C struct ClassJc_t const refl_LogMessageFW;
extern_C struct ClassJc_t const refl_MsgText_ifc_MSG_s;
extern_C struct ClassJc_t const refl_Output_MsgDispatcherCore_MSG_s;
extern_C struct ClassJc_t const refl_RunnableJc;
extern_C struct ClassJc_t const refl_TestCnt_MsgDispatcherCore_MSG_s;
const struct Reflection_Fields_DispatcherThread_MsgDispatcher_MSG_s_t
{ ObjectArrayJc head; FieldJc data[1];
} refl_Fields_DispatcherThread_MsgDispatcher_MSG_s =
{ CONST_ObjectArrayJc(FieldJc, 1, OBJTYPE_FieldJc, null, &refl_Fields_DispatcherThread_MsgDispatcher_MSG_s)
, {
     { "cycleMillisec"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((DispatcherThread_MsgDispatcher_MSG_s*)(0x1000))->cycleMillisec) - (int32)(DispatcherThread_MsgDispatcher_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_DispatcherThread_MsgDispatcher_MSG_s
    }
} };
const ClassJc refl_DispatcherThread_MsgDispatcher_MSG_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &refl_ObjectJc, &refl_ClassJc) 
, "DispatcherThread_M_her_MSG_s"
,  0 //position of ObjectJc
, sizeof(DispatcherThread_MsgDispatcher_MSG_s)
, (FieldJc_Y const*)&refl_Fields_DispatcherThread_MsgDispatcher_MSG_s
, null //method
, &superclasses_DispatcherThread_MsgDispatcher_MSG_s.head.object //superclass
, null //interfaces
, 0    //modifiers
, &mtblDispatcherThread_MsgDispatcher_MSG.mtbl.head
};
