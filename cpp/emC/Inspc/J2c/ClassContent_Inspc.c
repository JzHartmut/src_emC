/**************************************************************************
 * This file is generated by Java2C
 **copyright***************************************************************
 *************************************************************************/
#include <applstdef_emC.h>
#ifdef DEF_ClassJc_Vtbl
//NOTE: This file can only be used with full capability of emC, not for simple applications.
//      It is only necessary to full including the Inspc symbolic access on target

#include <emC/Inspc/J2c/ClassContent_Inspc.h>
#include <emC/InspcTargetSimple/IfcTargetProxy_Inspc.h>
#include <string.h>  //because using memset()
#include <emC/Jc/ReflectionJc.h>   //Reflection concept 
#include <emC/Inspc/Srv/CheckPwd_Inspc.h>
  //basic stacktrace concept
  //reference-association: ExceptionJc
#include "emC/Inspc/J2c/AnswerComm_ifc_Inspc.h"  //reference-association: answerCommVtbl
#include "emC/Inspc/J2c/SearchElement_Inspc.h"  //reference-association: SearchElement_Inspc_s
#include "emC/Jc/PrintStreamJc.h"  //reference-association: out
#include "emC/Jc/ReflMemAccessJc.h"  //embedded type in class data
#include "emC/Jc/ReflectionJc.h"  //reference-association: MemAccessArrayDebugJc
#include "emC/Jc/StringJc.h"  //embedded type in class data
#include "emC/Jc/SystemJc.h"  //reference-association: SystemJc
#include "emC/OSAL/os_time.h"  //reference-association: OS_TimeStamp


/* J2C: Forward declaration of struct ***********************************************/
struct InspcDataInfo_Inspc_t;


/* J2C: Method-table-references *********************************************************/
#ifndef AnswerComm_ifc_InspcMTBDEF
  #define AnswerComm_ifc_InspcMTBDEF
  typedef struct AnswerComm_ifc_InspcMTB_t { struct Vtbl_AnswerComm_ifc_Inspc_t const* mtbl; struct AnswerComm_ifc_Inspc_t* ref; } AnswerComm_ifc_InspcMTB;
#endif


/**Implements the commands to get fields and values from data and sets values. 
@author Hartmut Schorrig



*/


const char sign_Vtbl_ClassContent_Inspc[] = "ClassContent_Inspc"; //to mark method tables of all implementations

typedef struct VtblDef_ClassContent_Inspc_t { Vtbl_ClassContent_Inspc mtbl; VtblHeadJc end; } VtblDef_ClassContent_Inspc;
 extern VtblDef_ClassContent_Inspc const mtblClassContent_Inspc;
StringJc version_ClassContent_Inspc = CONST_z_StringJc("2015-08-08"); //J2C:static StringJc

/*Constructor */
struct ClassContent_Inspc_t* ctorO_ClassContent_Inspc(ObjectJc* othis, ThCxt* _thCxt)
{ ClassContent_Inspc_s* thiz = (ClassContent_Inspc_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_ClassContent_Inspc");
  checkConsistence_ObjectJc(othis, sizeof(ClassContent_Inspc_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &refl_ClassContent_Inspc_s, sizeof(ClassContent_Inspc_s));  
  //j2c: Initialize all class variables:
  {
    init0_MemC(build_MemC(&thiz->__TEST__, 20 * sizeof(int8))); //J2C: init the embedded simple array;
    //J2C: constructor for embedded element-MemC
      ctorM_Inspcitem_InspcDataExchangeAccess_Inspc(/*J2C:static method call*/build_MemC(&thiz->answerItem, sizeof(thiz->answerItem)), _thCxt);
    //J2C: constructor for embedded fix-size-StringBuffer
      init_ObjectJc(&thiz->uArray.sb.base.object, sizeof(StringBuilderJc_s) + 64 - 4, 0);
      ctorO_I_StringBuilderJc(&thiz->uArray.sb.base.object, 64, _thCxt);
    //J2C: constructor for embedded fix-size-StringBuffer
      init_ObjectJc(&thiz->uValue.sb.base.object, sizeof(StringBuilderJc_s) + 160 - 4, 0);
      ctorO_I_StringBuilderJc(&thiz->uValue.sb.base.object, 160, _thCxt);
    //J2C: constructor for embedded fix-size-StringBuffer
      init_ObjectJc(&thiz->uAnswer.sb.base.object, sizeof(StringBuilderJc_s) + 200 - 4, 0);
      ctorO_I_StringBuilderJc(&thiz->uAnswer.sb.base.object, 200, _thCxt);
    //J2C: constructor for embedded element-ObjectJc
      init_ObjectJc(&(thiz->test.base.object), sizeof(thiz->test), 0); 
      ctorO_InspcDataInfo_Inspc(/*J2C:static method call*/&(thiz->test.base.object), _thCxt);
    /*J2C: newArray*/
      init_ObjectJc(&thiz->handles.head.object, sizeof_ARRAYJc(InspcDataInfo_Inspc_s, 1024), 0);   //J2C: ctor embedded array.
      ctorO_ObjectArrayJc(&thiz->handles.head.object, 1024, sizeof(InspcDataInfo_Inspc_s), null, 0);//J2C: constructor for embedded array;
  }
  { 
    
    thiz->debugRemoteAccess = getSingleton_MemAccessArrayDebugJc();
    { int32 ii; 
      for(ii = 0; ii < thiz->handles.head.length; ++ii)
        { 
          
          //J2C: constructor for embedded element-ObjectJc
          init_ObjectJc(&(thiz->handles.data[ii].base.object), sizeof(thiz->handles.data[ii]), 0); 
          ctorO_InspcDataInfo_Inspc(/*J2C:static method call*/&(thiz->handles.data[ii].base.object), _thCxt);
        }/*TODO: Java2C-problem because different array annotations ... */
        
    }/*TODO: searchTrc should be used an onw instanc with idx!!!*/
    
  }
  STACKTRC_LEAVE;
  return thiz;
}



/**Sets the Object which is the root for all data.*/
void setRootObject_ClassContent_Inspc(ClassContent_Inspc_s* thiz, struct ObjectJc_t* rootObj, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setRootObject_ClassContent_Inspc");

  { 
    thiz->rootClass = getClass_ObjectJc(rootObj);
    setAddrSegm_MemSegmJc(thiz->rootAddr, rootObj, 0);
  }
  STACKTRC_LEAVE;
}



/**Sets the Object which is the root for all data.*/
void setRootObject_ClassAddr_ClassContent_Inspc(ClassContent_Inspc_s* thiz, struct ClassJc_t const* rootClass, MemSegmJc rootAddr, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setRootObject_ClassContent_Inspc");

  { 
    thiz->rootClass = rootClass;
    set_MemSegmJc(thiz->rootAddr, rootAddr);
  }
  STACKTRC_LEAVE;
}


/**sets all aggregations which are unknown on constuctor. */
void setAnswerComm_XX_ClassContent_Inspc(ObjectJc* ithis, struct AnswerComm_ifc_Inspc_t* answerComm, ThCxt* _thCxt)
{ ClassContent_Inspc_s* thiz = (ClassContent_Inspc_s*)ithis;
  
  STACKTRC_TENTRY("setAnswerComm_XX_ClassContent_Inspc");
  
  { 
    
    thiz->answerComm = answerComm;
  }
  STACKTRC_LEAVE;
}

int32 executeMonitorCmd_XXXXi_ClassContent_Inspc(ObjectJc* ithis, struct Inspcitem_InspcDataExchangeAccess_Inspc_t* cmd, struct InspcDatagram_InspcDataExchangeAccess_Inspc_t* answer, int32 maxNrofAnswerBytes, int32 accessLevels, MemC telg, ThCxt* _thCxt)
{ ClassContent_Inspc_s* thiz = (ClassContent_Inspc_s*)ithis;
  
  STACKTRC_TENTRY("executeMonitorCmd_XXXXi_ClassContent_Inspc");
  
  { 
    
    
    int32  nOrder = getOrder_Inspcitem_InspcDataExchangeAccess_Inspc(cmd);
    
    int32  nCmd = getCmd_Inspcitem_InspcDataExchangeAccess_Inspc(cmd);
    switch(nCmd){
      case kAccessCheck_Inspcitem_InspcDataExchangeAccess_Inspc: cmdAccessCheck_ClassContent_Inspc(thiz, cmd, answer, maxNrofAnswerBytes, accessLevels, telg, _thCxt); break;
      case kGetFields_Inspcitem_InspcDataExchangeAccess_Inspc: cmdGetFields_ClassContent_Inspc(thiz, cmd, answer, maxNrofAnswerBytes, accessLevels, _thCxt);break;
      case kGetValueByPath_Inspcitem_InspcDataExchangeAccess_Inspc: cmdGetValueByPath_ClassContent_Inspc(thiz, cmd, answer, _thCxt);break;
      case kSetValueByPath_Inspcitem_InspcDataExchangeAccess_Inspc: cmdSetValueByPath_ClassContent_Inspc(thiz, cmd, answer, _thCxt);break;
      case kGetAddressByPath_Inspcitem_InspcDataExchangeAccess_Inspc: cmdGetAddressByPath_ClassContent_Inspc(thiz, cmd, answer, maxNrofAnswerBytes, _thCxt);break;
      case kRegisterHandle_Inspcitem_InspcDataExchangeAccess_Inspc: cmdRegisterRepeat_ClassContent_Inspc(thiz, cmd, answer, maxNrofAnswerBytes, _thCxt);break;
      case kGetValueByHandle_Inspcitem_InspcDataExchangeAccess_Inspc: cmdGetValueByHandle_ClassContent_Inspc(thiz, cmd, answer, maxNrofAnswerBytes, _thCxt);break;
      default: 
      { 
        
        /**Unknown command - answer is: kFailedCommand.*/
        addChild_XX_ByteDataAccessBaseJc(& ((* (answer)).base.super), & ((thiz->answerItem).base.super), _thCxt);
        setInfoHead_Inspcitem_InspcDataExchangeAccess_Inspc(& (thiz->answerItem), sizeofHead_Inspcitem_InspcDataExchangeAccess_Inspc, kFailedCommand_Inspcitem_InspcDataExchangeAccess_Inspc, nOrder, _thCxt);
      }
    }/*switch*/;/*switch*/
    
    { STACKTRC_LEAVE;
      return 0;
    }
  }
  STACKTRC_LEAVE;
}


/**The information doesn't fit in the datagram: Send the last one and clear it. */
void txAnswerAndPrepareNewTelg_ClassContent_Inspc(ClassContent_Inspc_s* thiz, struct InspcDatagram_InspcDataExchangeAccess_Inspc_t* answer, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("txAnswerAndPrepareNewTelg_ClassContent_Inspc");
  
  { /*://*/
    
    
    
    AnswerComm_ifc_InspcMTB answerCommVtbl ; SETMTBJc(answerCommVtbl, thiz->answerComm, AnswerComm_ifc_Inspc);
    
    int32  nrofBytesAnswer = getLengthTotal_ByteDataAccessBaseJc(& ((* (answer)).base.super), _thCxt);
    setLengthDatagram_InspcDatagram_InspcDataExchangeAccess_Inspc(answer, nrofBytesAnswer);
    answerCommVtbl.mtbl->txAnswer(&(( (answerCommVtbl.ref))->base.object), nrofBytesAnswer, false, _thCxt);/*for next usage, send is done:*/
    
    removeChildren_ByteDataAccessBaseJc(& ((* (answer)).base.super));/*reuse it.*/
    
  }
  STACKTRC_LEAVE;
}



int32 cmdAccessCheck_ClassContent_Inspc(ClassContent_Inspc_s* thiz, struct Inspcitem_InspcDataExchangeAccess_Inspc_t* cmd, struct InspcDatagram_InspcDataExchangeAccess_Inspc_t* answer, int32 maxNrofAnswerBytes, int32 accessLevels, MemC telg, ThCxt* _thCxt)
{
  STACKTRC_TENTRY("cmdAccessCheck_ClassContent_Inspc");

  { /*:this.maxNrofAnswerBytes = maxNrofAnswerBytes;*/
    /*:this.answerP = answer;*/
      int32 nPwdNew = getChildInt_ByteDataAccessBaseJc(&cmd->base.super, 4, _thCxt);
      int32 accessLevelsNew = check_CheckPwd_Inspc(telg, nPwdNew);
      int32  order = getOrder_Inspcitem_InspcDataExchangeAccess_Inspc(cmd);
      addChild_XX_ByteDataAccessBaseJc(&((*(answer)).base.super), &((thiz->answerItem).base.super), _thCxt);
      addChildInt_ByteDataAccessBaseJc(&(thiz->answerItem.base.super), 4, accessLevelsNew, _thCxt);
      setInfoHead_Inspcitem_InspcDataExchangeAccess_Inspc(&(thiz->answerItem), sizeofHead_Inspcitem_InspcDataExchangeAccess_Inspc + 4, kAccessCheck_Inspcitem_InspcDataExchangeAccess_Inspc, order, _thCxt);
 
  }
  STACKTRC_RETURN 0;
}



int32 cmdGetFields_ClassContent_Inspc(ClassContent_Inspc_s* thiz, struct Inspcitem_InspcDataExchangeAccess_Inspc_t* cmd, struct InspcDatagram_InspcDataExchangeAccess_Inspc_t* answer, int32 maxNrofAnswerBytes, int32 accessLevels, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("cmdGetFields_ClassContent_Inspc");
  
  { /*:this.maxNrofAnswerBytes = maxNrofAnswerBytes;*/
    /*:this.answerP = answer;*/
    
    
    
    int32  ixFieldStart;/*no initvalue*/
    
    StringJc sVariablePath ; sVariablePath;/*no initvalue*/
    
    struct ClassJc_t const*  clazz = null;/*no initvalue*/
    
    bool  bQuestCollectionSize;/*no initvalue*/
    
    int32  idxCollectionQuest;/*no initvalue*/
    
    int32  nCmd;/*no initvalue*/
    nCmd = getCmd_Inspcitem_InspcDataExchangeAccess_Inspc(cmd);
    
    int32  nrofBytesCmd = getLenInfo_Inspcitem_InspcDataExchangeAccess_Inspc(cmd);
    sVariablePath = getChildString_ByteDataAccessBaseJc(& ((* (cmd)).base.super), nrofBytesCmd - 8, _thCxt)/*J2C:non-persistent*/;
    

      ixFieldStart = 0;
      /**Check whether its a question to collection size: */
      idxCollectionQuest = indexOf_s_StringJc(sVariablePath, s0_StringJc("<?>"));
      if(idxCollectionQuest < 0) 
      { 
      
        idxCollectionQuest = indexOf_s_StringJc(sVariablePath, s0_StringJc("[?]"));
      }
      if(idxCollectionQuest >= 0) 
      { 
      
        bQuestCollectionSize = true;
        sVariablePath = substring_StringJc(sVariablePath, 0, idxCollectionQuest, _thCxt)/*J2C:non-persistent*/;
      }
      else 
      { 
      
        bQuestCollectionSize = false;
      }
      TRY
      { 
      
      
        struct FieldJc_t const*  field;/*no initvalue*/
      
        MemSegmJc  memObj = { 0 };//J2C: constructor for embedded element
        INIT_MemSegmJc(/*J2C:static method call*/memObj);
      
        int32  memSegment = 0;
      
        bool  found;/*no initvalue*/
      
        int32  modifiers;/*no initvalue*/
        if(length_StringJc(sVariablePath) == 0 || equals_StringJc(sVariablePath, s0_StringJc("."))) 
        { 
        
          /**root path: No field given, to access type and address. It is the rootClazz and rootAddr.*/
          found = true;
          if(segment_MemSegmJc(thiz->rootAddr) !=0) {
            //it is an access to a remote target. Renew the rootAddr because the target may be compiled and started newly:
            //get the rootAddr and rootClazz on the first access.
            int32 receive = accessTarget_Inspc(getRootInstance_InspcTargetProxy, 1, 0, 0);
            setADDR32_MemSegmJc(thiz->rootAddr, (intptr_t)receive); //always the root of the target.
            int ixClass = accessTarget_Inspc(getRootType_InspcTargetProxy, 1, 0, 0);
            if(ixClass >0 && ixClass <= extReflectionClasses_ReflectionJc[0]->head.length ) {                                 //TODO index from segment
              thiz->rootClass = extReflectionClasses_ReflectionJc[0]->data[ixClass -1]; //get from loaded reflection file.
            } else {
              THROW_s0(IllegalStateException, "target faulty ixClass=", ixClass, (int)(int_ptr)thiz->rootAddr.ref);
              //return startAddr;  //contains null? No access to target, maybe TODO
            }
          }
          clazz = thiz->rootClass; //getClass_ClassJc(/*J2C:static method call*/thiz->rootObj);/*the main class itself contains some pointer yet.*/
        
          field = null;
          bQuestCollectionSize = false;/*not at root level*/
        
          modifiers = 0;
          set_MemSegmJc(memObj, thiz->rootAddr);
        }
        else 
        { 
        
        
          int32  idx;/*no initvalue*/
        
          int32 idxP[1] ; idxP; /*J2C:modeAccess=Q*/
        
          struct FieldJc_t const* fieldP[1] ; fieldP; /*J2C:modeAccess=Q*/
          /**Search the field in its object, the referenced instance of the field is requested: */
          set_MemSegmJc(memObj, searchObject_SearchElement_Inspc(/*J2C:static method call*/sVariablePath, thiz->rootClass, thiz->rootAddr, &fieldP[0], &idxP[0], _thCxt));/*Note for Java2C: set should be used because memObj is an embedded instance.*/
        
          idx = idxP[0];
          field = fieldP[0];
          /**The memObj contains the reference to the Object which contains the field. */
          found = obj_MemSegmJc(memObj) != null && field != null;
          if(found) 
          { 
          
            /**Field and Object of Field is found. */
            modifiers = getModifiers_FieldJc(field);
            if(isCollection_ModifierJc(/*J2C:static method call*/modifiers) && (idx < 0 || (isStaticArray_ModifierJc(/*J2C:static method call*/modifiers) && idx >= getStaticArraySize_FieldJc(field)))) 
            { 
            
              bQuestCollectionSize = true;
              clazz = null;
            }
            else 
            { 
            
              /**normal Object: */
              TRY
              { 
              
              
                struct ClassJc_t const* retClazz[1] ; retClazz; /*J2C:modeAccess=Q*/
                getObjAndClass_FieldJc(field, memObj, &retClazz[0], "I", idx);/*index -1: if it is a container, no class is returned*/
              
                bQuestCollectionSize = false;/*the clazz may be null*/
              
                clazz = retClazz[0];
                found = (clazz != null);/*getFields with non acknowledge answer if it is a null-reference. */
              
              }_TRY
              CATCH(RuntimeException, exc)
            
                { 
                
                  clazz = null;
                  bQuestCollectionSize = true;/*Exception, no clazz info, but it may be a collection size quest.*/
                
                }
              END_TRY
            }
          }
          else 
          { /*:The requested field isn't found, faulty path */
          
          
            clazz = null;
            modifiers = 0;
          }
        }
        if(found) 
        { 
        
        
          int32  nOrderNr = getOrder_Inspcitem_InspcDataExchangeAccess_Inspc(cmd);
          if(bQuestCollectionSize) 
          { /*:the size of an container is requested:*/
            /*:NOTE: it is not the root instance, only for the root instance the field ==null*/
          
            struct ClassJc_t const* _temp5_1; /*J2C: temporary references for concatenation */
          
            ASSERT_emC(/*J2C:static method call*/field != null, "field is null", 0, 0);
          
            int32  nSize = getArraylength_FieldJc(field, memObj);
          
            bool  hasSubstructure = (modifiers & mPrimitiv_Modifier_reflectJc) == 0;
            setLength_StringBuilderJc(& (thiz->uAnswer.sb), 0, _thCxt);
          
              ( append_C_StringBuilderJc(& (thiz->uAnswer.sb), '[', _thCxt)
              , append_I_StringBuilderJc(& (thiz->uAnswer.sb), nSize, _thCxt)
              , append_z_StringBuilderJc(& (thiz->uAnswer.sb), "]:", _thCxt)
              );
          
            StringJc name ; name = z_StringJc(
              ( _temp5_1= getType_FieldJc(field)
              , getName_ClassJc(_temp5_1)
              ))/*J2C:non-persistent*/;
            append_c_StringBuilderJc(& (thiz->uAnswer.sb), name, _thCxt);
            if(hasSubstructure) 
            { 
            
              append_z_StringBuilderJc(& (thiz->uAnswer.sb), "...", _thCxt);
            }/*the GUI will expand it to some nodes, one per element.*/
          
          
            int32  lengthAnswer = length_StringBuilderJc(& (thiz->uAnswer.sb));
          
            int32  lengthAnswer4 = (lengthAnswer + 3) / 4 * 4;
            if(lengthAnswer4 > lengthAnswer) 
            { 
            
              append_c_StringBuilderJc(& (thiz->uAnswer.sb), substring_StringJc(zI_StringJc("\0\0\0",3), 0, lengthAnswer4 - lengthAnswer, _thCxt), _thCxt);/*fill rest with 0*/
            
            }/*adds the answer to the telegram:*/
          
            addChild_XX_ByteDataAccessBaseJc(& ((* (answer)).base.super), & ((thiz->answerItem).base.super), _thCxt);
          
            StringJc sAnswer ; sAnswer = toStringNonPersist_StringBuilderJc(& ((thiz->uAnswer.sb).base.object), _thCxt)/*J2C:non-persistent*/;
            addChildString_Cs_ByteDataAccessBaseJc(& ((thiz->answerItem).base.super), sAnswer);/*Note: first add the string, then set the head because the setInfoHead adjusts the length of head child.*/
          
            setInfoHead_Inspcitem_InspcDataExchangeAccess_Inspc(& (thiz->answerItem), lengthAnswer4 + sizeofHead_Inspcitem_InspcDataExchangeAccess_Inspc, kAnswerFieldMethod_Inspcitem_InspcDataExchangeAccess_Inspc, nOrderNr, _thCxt);/*  */
          
          }
          else if(clazz != null) 
          { /*:not a question to collection size, but real clazz found:*/
            /*:show the fields:*/
            int accesslevel = (accessLevels & mAccessLevel_CheckPwd_Inspc) >> kBitAccessLevel_CheckPwd_Inspc;
          
            //cccc2018-12-31 if(obj_MemSegmJc(memObj) != null && segment_MemSegmJc(/*J2C:static method call*/memObj) == 0) 
            { /*:Note: outer classes are designated in Java with this$0 etc. as Field already.*/
              /*:ClassJc superObj = clazz.getEnclosingClass();*/
            
              struct FieldJc_t const* superfield = getSuperField_ClassJc(clazz);
              if (superfield != null && ((superfield->bitModifiers & mAccessLevel_Modifier_FieldJc) >> kBitAccessLevel_Modifier_FieldJc) <= accesslevel) { //prevent error if reflection are manual programmed.

                //shows super as Field, possible to open it.                                                                                                                                 /**Generates one entry per field in the answer telegram. */
                evaluateFieldGetFields_XXFdii_ClassContent_Inspc(thiz, answer, superfield, nOrderNr, maxNrofAnswerBytes, _thCxt);
              }
              
            
              //struct ClassJc_t const*  superType = getSuperClass_ClassJc(clazz);
              //if(superType != null) 
              //{ 
              
              //  evaluateFieldGetFields_XXSFdiiii_ClassContent_Inspc(thiz, answer, s0_StringJc("super"), superType, 0, 0, nOrderNr, maxNrofAnswerBytes, _thCxt);
              //}
            }
          
            FieldJc_Y const*  fields = getDeclaredFields_ClassJc(clazz);
            if(fields != null) 
            { 
            
            
              int32  ii = ixFieldStart;
              if(ii < 0) 
              { 
              
                ii = 0;
              }
              { int32 ixField; 
                for(ixField = 0; ixField < fields->head.length; ++ixField)
                  { 
                    struct FieldJc_t const* field = &(fields->data[ixField]);
                    if (field != null && ((field->bitModifiers & mAccessLevel_Modifier_FieldJc)>> kBitAccessLevel_Modifier_FieldJc) <= accesslevel) { //prevent error if reflection are manual programmed.
                      
                      /**Generates one entry per field in the answer telegram. */
                      evaluateFieldGetFields_XXFdii_ClassContent_Inspc(thiz, answer, field, nOrderNr, maxNrofAnswerBytes, _thCxt);
                    }
                  }
              }
            }
          }
        }
        else 
        { 
        
          addChild_XX_ByteDataAccessBaseJc(& ((* (answer)).base.super), & ((thiz->answerItem).base.super), _thCxt);/*answerItem.setCmd(InspcDataExchangeAccess.Inspcitem.kFailedPath);*/
        
        
          int32  order = getOrder_Inspcitem_InspcDataExchangeAccess_Inspc(cmd);
          setInfoHead_Inspcitem_InspcDataExchangeAccess_Inspc(& (thiz->answerItem), sizeofHead_Inspcitem_InspcDataExchangeAccess_Inspc, kFailedPath_Inspcitem_InspcDataExchangeAccess_Inspc, order, _thCxt);
        }
      }_TRY
      CATCH(Exception, exc)
    
        { 
        
          /**Unexpected ...*/
          println_z_PrintStreamJc(REFJc (out_SystemJc), "ClassContent-getFields - unexpected:", _thCxt);
          printStackTrace_Exception_emC(exc, _thCxt);
          addChild_XX_ByteDataAccessBaseJc(& ((* (answer)).base.super), & ((thiz->answerItem).base.super), _thCxt);/*answerItem.setCmd(InspcDataExchangeAccess.Inspcitem.kFailedPath);*/
        
        
          int32  order = getOrder_Inspcitem_InspcDataExchangeAccess_Inspc(cmd);
          setInfoHead_Inspcitem_InspcDataExchangeAccess_Inspc(& (thiz->answerItem), sizeofHead_Inspcitem_InspcDataExchangeAccess_Inspc, kFailedPath_Inspcitem_InspcDataExchangeAccess_Inspc, order, _thCxt);
        }
      END_TRY
    { STACKTRC_LEAVE;
      return 0;
    }
  }
  STACKTRC_LEAVE;
}

void evaluateFieldGetFields_XXFdii_ClassContent_Inspc(ClassContent_Inspc_s* thiz, struct InspcDatagram_InspcDataExchangeAccess_Inspc_t* answer, struct FieldJc_t const* field, int32 orderNr, int32 maxNrofAnswerBytes, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("evaluateFieldGetFields_XXFdii_ClassContent_Inspc");
  
  { /*:FieldJc field = new FieldJc(fieldP);   //regard container types*/
    
    
    
    StringJc name ; name = z_StringJc(getName_FieldJc(field))/*J2C:non-persistent*/;
    
    struct ClassJc_t const*  typeField = getType_FieldJc(field);
    
    int32  modifiers = getModifiers_FieldJc(field);
    
    int32  staticArraySize = getStaticArraySize_FieldJc(field);
    if (typeField != null) {  //prevent null-pointer access if reflection are dirty
      evaluateFieldGetFields_XXSFdiiii_ClassContent_Inspc(thiz, answer, name, typeField, modifiers, staticArraySize, orderNr, maxNrofAnswerBytes, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

void evaluateFieldGetFields_XXSFdiiii_ClassContent_Inspc(ClassContent_Inspc_s* thiz, struct InspcDatagram_InspcDataExchangeAccess_Inspc_t* answer, StringJc name, struct ClassJc_t const* typeField, int32 modifiers, int32 staticArraySize, int32 orderNr, int32 maxNrofAnswerBytes, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("evaluateFieldGetFields_XXSFdiiii_ClassContent_Inspc");
  
  { 
    
    
    StringJc type ; type;/*no initvalue*/
    if(typeField == null) 
    { 
      
      type = z_StringJc("unknown")/*J2C:non-persistent*/;/*modifType = 0;*/
      
    }
    else 
    { 
      
      type = z_StringJc(getName_ClassJc(typeField))/*J2C:non-persistent*/;/*modifType = typeField.getClass().getModifiers();*/
      
    }
    //if(typeField == null || ((typeField->bitModifiers & mAccessLevel_Modifier_FieldJc) >> kBitAccessLevel_Modifier_FieldJc) <= accesslevel)
    int32  lengthName = length_StringJc(name);
    
    int32  lengthType = length_StringJc(type);
    
    int32  modifContainertype = modifiers & m_Containertype_Modifier_reflectJc;
    
    bool  hasSubstructure = !isPrimitive_ClassJc(typeField) || (modifContainertype != 0);
    setLength_StringBuilderJc(& (thiz->uArray.sb), 0, _thCxt);
    if(modifContainertype == kUML_LinkedList_Modifier_reflectJc) 
    { 
      
      append_z_StringBuilderJc(& (thiz->uArray.sb), "[?]:LinkedList", _thCxt);
    }
    else if(modifContainertype == kUML_ArrayList_Modifier_reflectJc) 
    { 
      
      append_z_StringBuilderJc(& (thiz->uArray.sb), "[?]:ArrayList", _thCxt);
    }
    else if(modifContainertype == kStaticArray_Modifier_reflectJc) 
    { 
      
      
        ( append_C_StringBuilderJc(& (thiz->uArray.sb), '[', _thCxt)
        , append_I_StringBuilderJc(& (thiz->uArray.sb), staticArraySize, _thCxt)
        , append_C_StringBuilderJc(& (thiz->uArray.sb), ']', _thCxt)
        );
    }
    else if(modifContainertype != 0) 
    { 
      
      append_z_StringBuilderJc(& (thiz->uArray.sb), "[?]:TODO-containerType", _thCxt);
    }
    
    { 
      
      setLength_StringBuilderJc(& (thiz->uValue.sb), 0, _thCxt);
      
      int32  lengthValue = 0;
      
      { 
        int8ARRAY _temp4_1; /*J2C: temporary references for concatenation */
        
        setLength_StringBuilderJc(& (thiz->uAnswer.sb), 0, _thCxt);
        append_c_StringBuilderJc(& (thiz->uAnswer.sb), name, _thCxt);
        append_u_StringBuilderJc(& (thiz->uAnswer.sb), & (thiz->uArray.sb), _thCxt);
        append_C_StringBuilderJc(& (thiz->uAnswer.sb), ':', _thCxt);
        append_c_StringBuilderJc(& (thiz->uAnswer.sb), type, _thCxt);
        if(lengthValue > 0) 
        { 
          
          append_C_StringBuilderJc(& (thiz->uAnswer.sb), '=', _thCxt);
          append_u_StringBuilderJc(& (thiz->uAnswer.sb), & (thiz->uValue.sb), _thCxt);
        }
        if(hasSubstructure) 
        { /*:answerItem->data [answerPos] = '*';*/
          /*:answerPos +=1;*/
          
          
          append_z_StringBuilderJc(& (thiz->uAnswer.sb), "...", _thCxt);
        }/*assert(uAnswer.length() + InspcDataExchangeAccess.Inspcitem.sizeofHead == lengthAnswer);  //should be the same.*/
        
        
        int32  lengthAnswer = length_StringBuilderJc(& (thiz->uAnswer.sb));
        
        int32  lengthAnswer4 = (lengthAnswer + 3) / 4 * 4;
        if(lengthAnswer4 > lengthAnswer) 
        { 
          
          append_c_StringBuilderJc(& (thiz->uAnswer.sb), substring_StringJc(zI_StringJc("\0\0\0",3), 0, lengthAnswer4 - lengthAnswer, _thCxt), _thCxt);/*fill rest with 0*/
          
        }
        
        int32  zChildAnswer = sizeofHead_Inspcitem_InspcDataExchangeAccess_Inspc + length_StringBuilderJc(& (thiz->uAnswer.sb));
        
        int32  lengthAnswerTelg = getLengthTotal_ByteDataAccessBaseJc(& ((* (answer)).base.super), _thCxt);
        
        int32  lengthData = 
          (_temp4_1= getData_ByteDataAccessBaseJc(& ((* (answer)).base.super), _thCxt)
          , _temp4_1.val
          );
        if(lengthAnswerTelg + zChildAnswer > lengthData) 
        { /*://*/
          /*:if(!answer.sufficingBytesForNextChild(zChildAnswer)) {*/
          
          
          txAnswerAndPrepareNewTelg_ClassContent_Inspc(thiz, answer, _thCxt);
        }
        addChild_XX_ByteDataAccessBaseJc(& ((* (answer)).base.super), & ((thiz->answerItem).base.super), _thCxt);
        
        StringJc sAnswerAdd ; sAnswerAdd = toStringNonPersist_StringBuilderJc(& ((thiz->uAnswer.sb).base.object), _thCxt)/*J2C:non-persistent*/;
        addChildString_Cs_ByteDataAccessBaseJc(& ((thiz->answerItem).base.super), sAnswerAdd);/*Prepare the answer item for this field:*/
        
        setInfoHead_Inspcitem_InspcDataExchangeAccess_Inspc(& (thiz->answerItem), zChildAnswer, kAnswerFieldMethod_Inspcitem_InspcDataExchangeAccess_Inspc, orderNr, _thCxt);
      }
    }
  }
  STACKTRC_LEAVE;
}

int32 cmdGetValueByPath_ClassContent_Inspc(ClassContent_Inspc_s* thiz, struct Inspcitem_InspcDataExchangeAccess_Inspc_t* cmd, struct InspcDatagram_InspcDataExchangeAccess_Inspc_t* answer, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("cmdGetValueByPath_ClassContent_Inspc");
  
  { 
    
    
    int32  nrofBytesCmd = getLenInfo_Inspcitem_InspcDataExchangeAccess_Inspc(cmd);
    
    StringJc sVariablePath ; sVariablePath = getChildString_ByteDataAccessBaseJc(& ((* (cmd)).base.super), nrofBytesCmd - sizeofHead_Inspcitem_InspcDataExchangeAccess_Inspc, _thCxt)/*J2C:non-persistent*/;
    addChild_XX_ByteDataAccessBaseJc(& ((* (answer)).base.super), & ((thiz->answerItem).base.super), _thCxt);
    getSetValueByPath_ClassContent_Inspc(thiz, getOrder_Inspcitem_InspcDataExchangeAccess_Inspc(cmd), sVariablePath, null, & (thiz->answerItem), _thCxt);
    { STACKTRC_LEAVE;
      return 0;
    }
  }
  STACKTRC_LEAVE;
}

int32 cmdSetValueByPath_ClassContent_Inspc(ClassContent_Inspc_s* thiz, struct Inspcitem_InspcDataExchangeAccess_Inspc_t* cmd, struct InspcDatagram_InspcDataExchangeAccess_Inspc_t* answer, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("cmdSetValueByPath_ClassContent_Inspc");
  
  { 
    
    
    int32  nrofBytesCmd = getLenInfo_Inspcitem_InspcDataExchangeAccess_Inspc(cmd);
    
    InspcSetValue_InspcDataExchangeAccess_Inspc_s  setValue = { 0 };//J2C: constructor for embedded element-MemC
    ctorM_InspcSetValue_InspcDataExchangeAccess_Inspc(/*J2C:static method call*/build_MemC(&setValue, sizeof(setValue)), _thCxt);
    addChild_XX_ByteDataAccessBaseJc(& ((* (cmd)).base.super), & ((setValue).base.super), _thCxt);
    
    int32  nrofBytesPath = nrofBytesCmd - sizeofHead_Inspcitem_InspcDataExchangeAccess_Inspc - sizeofElement_InspcSetValue_InspcDataExchangeAccess_Inspc;
    
    StringJc sVariablePath ; sVariablePath = getChildString_ByteDataAccessBaseJc(& ((* (cmd)).base.super), nrofBytesPath, _thCxt)/*J2C:non-persistent*/;
    addChild_XX_ByteDataAccessBaseJc(& ((* (answer)).base.super), & ((thiz->answerItem).base.super), _thCxt);
    getSetValueByPath_ClassContent_Inspc(thiz, getOrder_Inspcitem_InspcDataExchangeAccess_Inspc(cmd), sVariablePath, & (setValue), & (thiz->answerItem), _thCxt);
    detach_ByteDataAccessBaseJc(& ((setValue).base.super), _thCxt);/*because it is a stack instance.*/
    
    { STACKTRC_LEAVE;
      return 0;
    }
  }
  STACKTRC_LEAVE;
}


/**Gets or sets a value by given path of reflection.*/
void getSetValueByPath_ClassContent_Inspc(ClassContent_Inspc_s* thiz, int32 nOrderNr, StringJc sVariablePath, struct InspcSetValue_InspcDataExchangeAccess_Inspc_t* accSetValue, struct Inspcitem_InspcDataExchangeAccess_Inspc_t* answerItem, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getSetValueByPath_ClassContent_Inspc");
  
  { 
    
    
    struct FieldJc_t const*  theField = null;
    
    struct FieldJc_t const* theFieldP[1] = {null} ; /*J2C:modeAccess=Q*/
    
    MemSegmJc  theObject = { 0 };//J2C: constructor for embedded element
    INIT_MemSegmJc(/*J2C:static method call*/theObject);
    TRY
    { 
      
      
      int32  idx;/*no initvalue*/
      
      int32 idxP[1] ; idxP; /*J2C:modeAccess=Q*/
      set_MemSegmJc(theObject, searchObject_SearchElement_Inspc(/*J2C:static method call*/sVariablePath, thiz->rootClass, thiz->rootAddr, &theFieldP[0], &idxP[0], _thCxt));/*Note for Java2C: set should be used because memObj is an embedded instance.*/
      
      theField = theFieldP[0];
      idx = idxP[0];
      if(obj_MemSegmJc(theObject) != null && theField != null) 
      { 
        
        getSetValue_ClassContent_Inspc(/*J2C:static method call*/theField, idx, theObject, accSetValue, answerItem, true, _thCxt);
        
        int32  nBytesItem = getLength_ByteDataAccessBaseJc(& ((* (answerItem)).base.super), _thCxt);
        setInfoHead_Inspcitem_InspcDataExchangeAccess_Inspc(answerItem, nBytesItem, kAnswerValue_Inspcitem_InspcDataExchangeAccess_Inspc, nOrderNr, _thCxt);
      }
      else 
      { /*:Info failed value to return. Note: If nothing is returned, the calling doesn't know that problem */
        /*:and the whole telegram may not be sent. It would cause a timeout. Bugfix on 2013-01-10*/
        
        
        
        int32  nBytesItem = getLength_ByteDataAccessBaseJc(& ((* (answerItem)).base.super), _thCxt);
        setInfoHead_Inspcitem_InspcDataExchangeAccess_Inspc(answerItem, nBytesItem, kFailedPath_Inspcitem_InspcDataExchangeAccess_Inspc, nOrderNr, _thCxt);
      }
    }_TRY
    CATCH(Exception, exc)
    
      { 
        
        /**Unexpected ...*/
        println_z_PrintStreamJc(REFJc (out_SystemJc), "ClassContent-getValueByPath - unexpected:", _thCxt);
        printStackTrace_Exception_emC(exc, _thCxt);
        
        int32  nBytesItem = getLength_ByteDataAccessBaseJc(& ((* (answerItem)).base.super), _thCxt);
        setInfoHead_Inspcitem_InspcDataExchangeAccess_Inspc(answerItem, nBytesItem, kFailedPath_Inspcitem_InspcDataExchangeAccess_Inspc, nOrderNr, _thCxt);
      }
    END_TRY
  }
  STACKTRC_LEAVE;
}


/**Sets the value if accSetValue is not null, fills the {@link #answerItem} with the read value.*/
int16 getSetValue_ClassContent_Inspc(/*J2C:static method*/ struct FieldJc_t const* theField, int32 idx, MemSegmJc theObject, struct InspcSetValue_InspcDataExchangeAccess_Inspc_t* accSetValue, struct Inspcitem_InspcDataExchangeAccess_Inspc_t* answerItem, bool bStoreTypeInAnswer, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getSetValue_ClassContent_Inspc");
  
  { 
    int8ARRAY _temp2_1; /*J2C: temporary references for concatenation */
    
    
    struct ClassJc_t const*  type = getType_FieldJc(theField);
    
    int32  modifier = getModifiers_FieldJc(theField);
    
    StringJc sValue ; sValue = null_StringJc/*J2C:non-persistent*/;
    
    bool  bOk;/*no initvalue*/
    
    int32  actLenTelg = getLengthTotal_ByteDataAccessBaseJc(& ((* (answerItem)).base.super), _thCxt);
    
    int32  maxLen = 
      (_temp2_1= getData_ByteDataAccessBaseJc(& ((* (answerItem)).base.super), _thCxt)
      , _temp2_1.val
      );
    
    int32  restLen = maxLen - actLenTelg;
    
    int16  nType = -1;
    if(isPrimitive_ClassJc(type)) 
    { 
      
      
      StringJc sType ; sType = z_StringJc(getName_ClassJc(type))/*J2C:non-persistent*/;
      
      char  cType = charAt_StringJc(sType, 0);
      switch(cType){
        case 'u':
        case 'v': //? what is v
        case 'i': switch (type->nSize) {    //it is uint16, int16, int32, int64 etc.
          case 1:
          { /*:byte*/


            bOk = restLen >= 3;
            if (bOk)
            {


              int16  value = getByte_FieldJc(theField, theObject, "I", idx);
              nType = ((/*J2C:cast% from int32*/int16)(kScalarTypes_InspcDataExchangeAccess_Inspc + REFLECTION_int16_ClassJc));
              if (bStoreTypeInAnswer)
              {

                addChildInteger_ByteDataAccessBaseJc(&((*(answerItem)).base.super), 1, nType, _thCxt);
              }
              addChildInteger_ByteDataAccessBaseJc(&((*(answerItem)).base.super), 2, value, _thCxt);
              sValue = null_StringJc/*J2C:non-persistent*/;
            }
          }break;
          case 2:
          { /*:short*/


            bOk = restLen >= 3;
            if (bOk)
            {


              int32  value;/*no initvalue*/
              if (accSetValue != null)
              {


                int16  setValue = getShort_InspcSetValue_InspcDataExchangeAccess_Inspc(accSetValue);
                value = setShort_FieldJc(theField, theObject, setValue, "I", idx);
              }
              else
              {

                value = getShort_FieldJc(theField, theObject, "I", idx);
              }
              nType = ((/*J2C:cast% from int32*/int16)(kScalarTypes_InspcDataExchangeAccess_Inspc + REFLECTION_int16_ClassJc));
              if (bStoreTypeInAnswer)
              {

                addChildInteger_ByteDataAccessBaseJc(&((*(answerItem)).base.super), 1, nType, _thCxt);
              }
              addChildInteger_ByteDataAccessBaseJc(&((*(answerItem)).base.super), 2, value, _thCxt);
              sValue = null_StringJc/*J2C:non-persistent*/;
            }
          }break;
          case 8:
          { /*:long, it is int64*/


            bOk = restLen >= 9;
            if (bOk)
            {


              int64  value = getInt64_FieldJc(theField, theObject, "I", idx);
              nType = ((/*J2C:cast% from int32*/int16)(kScalarTypes_InspcDataExchangeAccess_Inspc + REFLECTION_int32_ClassJc));
              if (bStoreTypeInAnswer)
              {

                addChildInteger_ByteDataAccessBaseJc(&((*(answerItem)).base.super), 1, nType, _thCxt);
              }
              addChildInteger_ByteDataAccessBaseJc(&((*(answerItem)).base.super), 8, value, _thCxt);/*8 */

              sValue = null_StringJc/*J2C:non-persistent*/;
            }
          }break;
          case 4:
            { /*:int8*/
          
          
              bOk = restLen >= 5;
              if(bOk) 
              { 
            
            
                int32  value;/*no initvalue*/
                if(accSetValue != null) 
                { 
              
              
                  int32  setValue = getInt_InspcSetValue_InspcDataExchangeAccess_Inspc(accSetValue);
                  value = setInt_FieldJc(theField, theObject, setValue, "I", idx);
                }
                else 
                { 
              
                  value = getInt_FieldJc(theField, theObject, "I", idx);
                }
                nType = ((/*J2C:cast% from int32*/int16)(kScalarTypes_InspcDataExchangeAccess_Inspc + REFLECTION_int32_ClassJc));
                if(bStoreTypeInAnswer) 
                { 
              
                  addChildInteger_ByteDataAccessBaseJc(& ((* (answerItem)).base.super), 1, nType, _thCxt);
                }
                addChildInteger_ByteDataAccessBaseJc(& ((* (answerItem)).base.super), 4, value, _thCxt);
                sValue = null_StringJc/*J2C:non-persistent*/;
              }
            }break;
        } break;   //uint int 
        case 'c': 
        { /*:int*/
          
          
          bOk = restLen >= 3;
          if(bOk) 
          { 
            
            
            char  value;/*no initvalue*/
            if(accSetValue != null) 
            { 
              
              
              char  setValue = (char /*J2C_cast*/)getByte_InspcSetValue_InspcDataExchangeAccess_Inspc(accSetValue);
              value = setChar_FieldJc(theField, theObject, setValue, "I", idx);
            }
            else 
            { 
              
              value = getChar_FieldJc(theField, theObject, "I", idx);
            }
            nType = ((/*J2C:cast% from int32*/int16)(kScalarTypes_InspcDataExchangeAccess_Inspc + REFLECTION_int16_ClassJc));
            if(bStoreTypeInAnswer) 
            { 
              
              addChildInteger_ByteDataAccessBaseJc(& ((* (answerItem)).base.super), 1, nType, _thCxt);
            }
            addChildInteger_ByteDataAccessBaseJc(& ((* (answerItem)).base.super), 2, (int16 /*J2C_cast*/)value, _thCxt);
            sValue = null_StringJc/*J2C:non-persistent*/;
          }
        }break;
        case 's': 
        { /*:short*/
          
          
          bOk = restLen >= 3;
          if(bOk) 
          { 
            
            
            int32  value;/*no initvalue*/
            if(accSetValue != null) 
            { 
              
              
              int16  setValue = getShort_InspcSetValue_InspcDataExchangeAccess_Inspc(accSetValue);
              value = setShort_FieldJc(theField, theObject, setValue, "I", idx);
            }
            else 
            { 
              
              value = getShort_FieldJc(theField, theObject, "I", idx);
            }
            nType = ((/*J2C:cast% from int32*/int16)(kScalarTypes_InspcDataExchangeAccess_Inspc + REFLECTION_int16_ClassJc));
            if(bStoreTypeInAnswer) 
            { 
              
              addChildInteger_ByteDataAccessBaseJc(& ((* (answerItem)).base.super), 1, nType, _thCxt);
            }
            addChildInteger_ByteDataAccessBaseJc(& ((* (answerItem)).base.super), 2, value, _thCxt);
            sValue = null_StringJc/*J2C:non-persistent*/;
          }
        }break;
        case 'l': 
        { /*:long, it is int64*/
          
          
          bOk = restLen >= 9;
          if(bOk) 
          { 
            
            
            int64  value = getInt64_FieldJc(theField, theObject, "I", idx);
            nType = ((/*J2C:cast% from int32*/int16)(kScalarTypes_InspcDataExchangeAccess_Inspc + REFLECTION_int32_ClassJc));
            if(bStoreTypeInAnswer) 
            { 
              
              addChildInteger_ByteDataAccessBaseJc(& ((* (answerItem)).base.super), 1, nType, _thCxt);
            }
            addChildInteger_ByteDataAccessBaseJc(& ((* (answerItem)).base.super), 8, value, _thCxt);/*8 */
            
            sValue = null_StringJc/*J2C:non-persistent*/;
          }
        }break;
        case 'f': 
        { /*:float*/
          
          
          bOk = restLen >= 5;
          if(bOk) 
          { 
            
            
            float  valuef;/*no initvalue*/
            if(accSetValue != null) 
            { 
              
              
              float  setValue = (float /*J2C_cast*/)getDouble_InspcSetValue_InspcDataExchangeAccess_Inspc(accSetValue);
              valuef = setFloat_FieldJc(theField, theObject, setValue, "I", idx);
            }
            else 
            { 
              
              valuef = getFloat_FieldJc(theField, theObject, "I", idx);
            }
            
            int32  value = floatToRawIntBits_FloatJc(/*J2C:static method call*/valuef);
            nType = ((/*J2C:cast% from int32*/int16)(kScalarTypes_InspcDataExchangeAccess_Inspc + REFLECTION_float_ClassJc));
            if(bStoreTypeInAnswer) 
            { 
              
              addChildInteger_ByteDataAccessBaseJc(& ((* (answerItem)).base.super), 1, nType, _thCxt);
            }
            addChildInteger_ByteDataAccessBaseJc(& ((* (answerItem)).base.super), 4, value, _thCxt);
            sValue = null_StringJc/*J2C:non-persistent*/;
          }
        }break;
        case 'd': 
        { /*:double */
          
          
          bOk = restLen >= 9;
          if(bOk) 
          { 
            
            
            double  fvalue;/*no initvalue*/
            if(accSetValue != null) 
            { 
              
              
              double  setValue = getDouble_InspcSetValue_InspcDataExchangeAccess_Inspc(accSetValue);
              fvalue = setDouble_FieldJc(theField, theObject, setValue, "I", idx);
            }
            else 
            { 
              
              fvalue = getDouble_FieldJc(theField, theObject, "I", idx);
            }
            
            bool  fixme = true;
            if(fixme) 
            { 
              
              
              int32  value = floatToRawIntBits_FloatJc(/*J2C:static method call*/(float /*J2C_cast*/)fvalue);
              nType = ((/*J2C:cast% from int32*/int16)(kScalarTypes_InspcDataExchangeAccess_Inspc + REFLECTION_float_ClassJc));
              if(bStoreTypeInAnswer) 
              { 
                
                addChildInteger_ByteDataAccessBaseJc(& ((* (answerItem)).base.super), 1, nType, _thCxt);
              }
              addChildInteger_ByteDataAccessBaseJc(& ((* (answerItem)).base.super), 4, value, _thCxt);
            }
            else 
            { 
              
              
              int64  value = doubleToLongBits_DoubleJc(/*J2C:static method call*/fvalue);
              nType = ((/*J2C:cast% from int32*/int16)(kScalarTypes_InspcDataExchangeAccess_Inspc + REFLECTION_double_ClassJc));
              if(bStoreTypeInAnswer) 
              { 
                
                addChildInteger_ByteDataAccessBaseJc(& ((* (answerItem)).base.super), 1, nType, _thCxt);
              }
              addChildInteger_ByteDataAccessBaseJc(& ((* (answerItem)).base.super), 8, value, _thCxt);
            }
            sValue = null_StringJc/*J2C:non-persistent*/;
          }
        }break;
        case 'b': switch(charAt_StringJc(sType, 1)){
          case 'o': 
          { /*:boolean*/
            
            
            bOk = restLen >= 3;
            if(bOk) 
            { 
              
              
              bool  value;/*no initvalue*/
              if(accSetValue != null) 
              { 
                
                
                int32  ivalue = getShort_InspcSetValue_InspcDataExchangeAccess_Inspc(accSetValue);
                
                bool  setValue = ivalue != 0;
                value = setBoolean_FieldJc(theField, theObject, setValue, "I", idx);
              }
              else 
              { 
                
                value = getBoolean_FieldJc(theField, theObject, "I", idx);
              }
              
              int32  value1 = value ? 1 : 0;
              nType = ((/*J2C:cast% from int32*/int16)(kScalarTypes_InspcDataExchangeAccess_Inspc + REFLECTION_int16_ClassJc));
              if(bStoreTypeInAnswer) 
              { 
                
                addChildInteger_ByteDataAccessBaseJc(& ((* (answerItem)).base.super), 1, nType, _thCxt);
              }
              addChildInteger_ByteDataAccessBaseJc(& ((* (answerItem)).base.super), 2, value1, _thCxt);
              sValue = null_StringJc/*J2C:non-persistent*/;
            }
          }break;
          case 'y': 
          { /*:byte*/
            
            
            bOk = restLen >= 3;
            if(bOk) 
            { 
              
              
              int16  value = getByte_FieldJc(theField, theObject, "I", idx);
              nType = ((/*J2C:cast% from int32*/int16)(kScalarTypes_InspcDataExchangeAccess_Inspc + REFLECTION_int16_ClassJc));
              if(bStoreTypeInAnswer) 
              { 
                
                addChildInteger_ByteDataAccessBaseJc(& ((* (answerItem)).base.super), 1, nType, _thCxt);
              }
              addChildInteger_ByteDataAccessBaseJc(& ((* (answerItem)).base.super), 2, value, _thCxt);
              sValue = null_StringJc/*J2C:non-persistent*/;
            }
          }break;
          case 'i': 
          { /*:bitfield*/
            
            
            bOk = restLen >= 3;
            if(bOk) 
            { 
              
              
              int16  value;/*no initvalue*/
              if(accSetValue != null) 
              { 
                
                
                int16  setValue = (int16)getShort_InspcSetValue_InspcDataExchangeAccess_Inspc(accSetValue);
                value = (int16)setBitfield_FieldJc(theField, theObject, setValue, "I", idx);
              }
              else 
              { 
                
                value = getBitfield_FieldJc(theField, theObject, "I", idx);
              }
              nType = ((/*J2C:cast% from int32*/int16)(kScalarTypes_InspcDataExchangeAccess_Inspc + REFLECTION_int16_ClassJc));
              if(bStoreTypeInAnswer) 
              { 
                
                addChildInteger_ByteDataAccessBaseJc(& ((* (answerItem)).base.super), 1, nType, _thCxt);
              }
              addChildInteger_ByteDataAccessBaseJc(& ((* (answerItem)).base.super), 2, value, _thCxt);
              sValue = null_StringJc/*J2C:non-persistent*/;
            }
          }break;
          default: 
          { 
            
            bOk = restLen >= 1;
            if(bOk) 
            { 
              
              nType = kTypeNoValue_InspcDataExchangeAccess_Inspc;
              if(bStoreTypeInAnswer) 
              { 
                
                addChildInteger_ByteDataAccessBaseJc(& ((* (answerItem)).base.super), 1, nType, _thCxt);
              }
              sValue = null_StringJc/*J2C:non-persistent*/;/*"?unknownPrimitiveType?";*/
              
            }
          }
        }/*switch*/;break;
        default: 
        { 
          
          bOk = restLen >= 1;
          if(bOk) 
          { 
            
            nType = kTypeNoValue_InspcDataExchangeAccess_Inspc;
            if(bStoreTypeInAnswer) 
            { 
              
              addChildInteger_ByteDataAccessBaseJc(& ((* (answerItem)).base.super), 1, nType, _thCxt);
            }
            sValue = null_StringJc/*J2C:non-persistent*/;/*"?unknownPrimType?";*/
            
          }
        }
      }/*switch*/;/*switch*/
      
    }
    else 
    { /*:it is a complex type, not a numeric.*/
      
      StringJc _persistring3_1=NULL_StringJc; //J2C: temporary persistent Strings
      
      sValue = _persistring3_1 = persist_StringJc(getString_FieldJc(theField, theObject, "I", idx))/*J2C:non-persistent*/;
      bOk = true;
      activateGC_ObjectJc(PTR_StringJc(_persistring3_1), null, _thCxt);
    }
    if(!isNull_StringJc(sValue)) 
    { 
      
      
      int32  zValue = length_StringJc(sValue);
      if(zValue > maxNrOfChars_InspcDataExchangeAccess_Inspc) 
      { 
        
        zValue = maxNrOfChars_InspcDataExchangeAccess_Inspc;
        sValue = substring_StringJc(sValue, 0, zValue, _thCxt)/*J2C:non-persistent*/;
      }
      bOk = restLen >= zValue + 1;
      if(bOk) 
      { 
        
        nType = (int16 /*J2C_cast*/)zValue;
        addChildInteger_ByteDataAccessBaseJc(& ((* (answerItem)).base.super), 1, zValue, _thCxt);/*Set the number of char-bytes in 1 byte*/
        
        addChildString_Cs_ByteDataAccessBaseJc(& ((* (answerItem)).base.super), sValue);/*Set the character String after them.*/
        
      }
    }
    /*MemSegmJc adr;*/
    { STACKTRC_LEAVE;
      return bOk ? nType : (int16)-1;
    }
  }
  STACKTRC_LEAVE;
}

int32 cmdGetAddressByPath_ClassContent_Inspc(ClassContent_Inspc_s* thiz, struct Inspcitem_InspcDataExchangeAccess_Inspc_t* cmd, struct InspcDatagram_InspcDataExchangeAccess_Inspc_t* answer, int32 maxNrofAnswerBytes, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("cmdGetAddressByPath_ClassContent_Inspc");
  
  { 
    
    
    int32  nrofBytesCmd = getLenInfo_Inspcitem_InspcDataExchangeAccess_Inspc(cmd);
    
    int32  nrofBytesPath = nrofBytesCmd - sizeofHead_Inspcitem_InspcDataExchangeAccess_Inspc;
    
    StringJc sVariablePath ; sVariablePath = getChildString_ByteDataAccessBaseJc(& ((* (cmd)).base.super), nrofBytesPath, _thCxt)/*J2C:non-persistent*/;
    
    int32  nOrderNr = getOrder_Inspcitem_InspcDataExchangeAccess_Inspc(cmd);
    
    struct FieldJc_t const*  theField = null;
    
    struct FieldJc_t const* theFieldP[1] ; theFieldP; /*J2C:modeAccess=Q*/
    
    MemSegmJc  theObject = { 0 };//J2C: constructor for embedded element
    INIT_MemSegmJc(/*J2C:static method call*/theObject);
    /***/
    TRY
    { 
      
      
      int32  idx;/*no initvalue*/
      
      int32 idxP[1] ; idxP; /*J2C:modeAccess=Q*/
      set_MemSegmJc(theObject, searchObject_SearchElement_Inspc(/*J2C:static method call*/sVariablePath, thiz->rootClass, thiz->rootAddr, &theFieldP[0], &idxP[0], _thCxt));/*Note for Java2C: set should be used because memObj is an embedded instance.*/
      
      theField = theFieldP[0];
      idx = idxP[0];
      addChild_XX_ByteDataAccessBaseJc(& ((* (answer)).base.super), & ((thiz->answerItem).base.super), _thCxt);
      //changes 2018-04-17 alignment of answer
      //setInfoHead_Inspcitem_InspcDataExchangeAccess_Inspc(& (thiz->answerItem), 0, kAnswerValue_Inspcitem_InspcDataExchangeAccess_Inspc, nOrderNr, _thCxt);
      if (obj_MemSegmJc(theObject) != null && theField != null)
      {


        int32  addr = (int32)getMemoryIdent_FieldJc(theField, theObject, "I", idxP[0]);
        addChildInteger_ByteDataAccessBaseJc(&((thiz->answerItem).base.super), 1, kReferenceAddr_InspcDataExchangeAccess_Inspc, _thCxt);/*Set the number of char-bytes in 1 byte*/

        addChildInteger_ByteDataAccessBaseJc(&((thiz->answerItem).base.super), 4, addr, _thCxt);
        addChildInteger_ByteDataAccessBaseJc(&((thiz->answerItem).base.super), 3, 0, _thCxt);   //align to 4
        int32  nBytesItem = getLength_ByteDataAccessBaseJc(&(((thiz->answerItem)).base.super), _thCxt);
        setInfoHead_Inspcitem_InspcDataExchangeAccess_Inspc(&thiz->answerItem, nBytesItem, kAnswerValue_Inspcitem_InspcDataExchangeAccess_Inspc, nOrderNr, _thCxt);
      }
      else
      {
        setInfoHead_Inspcitem_InspcDataExchangeAccess_Inspc(&thiz->answerItem, sizeofHead_Inspcitem_InspcDataExchangeAccess_Inspc, kFailedValue_Inspcitem_InspcDataExchangeAccess_Inspc, nOrderNr, _thCxt);

        //setCmd_Inspcitem_InspcDataExchangeAccess_Inspc(& (thiz->answerItem), kFailedValue_Inspcitem_InspcDataExchangeAccess_Inspc);
      }
      //setLength_Inspcitem_InspcDataExchangeAccess_Inspc(& (thiz->answerItem), getLength_ByteDataAccessBaseJc(& ((thiz->answerItem).base.super), _thCxt));/*the length of the answerItems in byte.*/
    }_TRY
    CATCH(Exception, exc)
    
      { 
        
        /**Unexpected ...*/
        println_z_PrintStreamJc(REFJc (out_SystemJc), "ClassContent-getValueByPath - unexpected:", _thCxt);
        printStackTrace_Exception_emC(exc, _thCxt);
      }
    END_TRY
    { STACKTRC_LEAVE;
      return 0;
    }
  }
  STACKTRC_LEAVE;
}

int32 cmdRegisterRepeat_ClassContent_Inspc(ClassContent_Inspc_s* thiz, struct Inspcitem_InspcDataExchangeAccess_Inspc_t* cmd, struct InspcDatagram_InspcDataExchangeAccess_Inspc_t* answer, int32 maxNrofAnswerBytes, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("cmdRegisterRepeat_ClassContent_Inspc");
  
  { 
    
    
    int32  nrofBytesCmd = getLenInfo_Inspcitem_InspcDataExchangeAccess_Inspc(cmd);
    
    int32  nrofBytesPath = nrofBytesCmd - sizeofHead_Inspcitem_InspcDataExchangeAccess_Inspc;
    
    StringJc sVariablePath ; sVariablePath = getChildString_ByteDataAccessBaseJc(& ((* (cmd)).base.super), nrofBytesPath, _thCxt)/*J2C:non-persistent*/;
    
    int32  nOrderNr = getOrder_Inspcitem_InspcDataExchangeAccess_Inspc(cmd);
    addChild_XX_ByteDataAccessBaseJc(& ((* (answer)).base.super), & ((thiz->answerItem).base.super), _thCxt);
    
    int32  handle = registerHandle_ClassContent_Inspc(thiz, sVariablePath, & (thiz->answerItem), _thCxt);
    
    int32  lengthItem = getLength_ByteDataAccessBaseJc(& ((thiz->answerItem).base.super), _thCxt);
    
    int32  answerCmd = handle != -1 ? kAnswerRegisterHandle_Inspcitem_InspcDataExchangeAccess_Inspc : kFailedRegisterRepeat_Inspcitem_InspcDataExchangeAccess_Inspc;
    setInfoHead_Inspcitem_InspcDataExchangeAccess_Inspc(& (thiz->answerItem), lengthItem, answerCmd, nOrderNr, _thCxt);
    { STACKTRC_LEAVE;
      return 0;
    }
  }
  STACKTRC_LEAVE;
}


/**Registers a path for repeated access*/
int32 registerHandle_ClassContent_Inspc(ClassContent_Inspc_s* thiz, StringJc sVariablePath, struct Inspcitem_InspcDataExchangeAccess_Inspc_t* answerItem, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("registerHandle_ClassContent_Inspc");
  
  { 
    
    
    struct FieldJc_t const*  theField = null;
    
    struct FieldJc_t const* theFieldP[1] ; theFieldP; /*J2C:modeAccess=Q*/
    
    MemSegmJc  theObject = { 0 };//J2C: constructor for embedded element
    INIT_MemSegmJc(/*J2C:static method call*/theObject);
    
    int32  handle;/*no initvalue*/
    
    int32  idx;/*no initvalue*/
    TRY
    { 
      
      
      int32 idxP[1] ; idxP; /*J2C:modeAccess=Q*/
      set_MemSegmJc(theObject, searchObject_SearchElement_Inspc(/*J2C:static method call*/sVariablePath, thiz->rootClass, thiz->rootAddr, &theFieldP[0], &idxP[0], _thCxt));/*Note for Java2C: set should be used because memObj is an embedded instance.*/
      
      theField = theFieldP[0];
      idx = idxP[0];
      if(obj_MemSegmJc(theObject) != null && theField != null) 
      { 
        
        
        struct ClassJc_t const*  type = getType_FieldJc(theField);
        
        int32  modifier = getModifiers_FieldJc(theField);
        
        int64  addr = (int64) getMemoryIdent_FieldJc(theField, theObject, "I", idxP[0]);  //TODO void* in Java?
        
        int32  ixReg = 0;
        
        struct InspcDataInfo_Inspc_t*  freeOrder = null;
        
        int32  currentTime = os_getSeconds();
        
        int32  ixRegLast = 0;
        
        int32  diffLast = 0;
        
        while(freeOrder == null && ixReg < thiz->handles.head.length)
          { 
            
            
            struct InspcDataInfo_Inspc_t*  order = & (thiz->handles.data[ixReg]);
            
            int32  lastUsed = currentTime - order->lastUsed;
            if((lastUsed) > 3600) 
            { 
              
              freeOrder = order;
            }
            else 
            { 
              
              if(lastUsed > diffLast) 
              { 
                
                diffLast = lastUsed;
                ixRegLast = ixReg;
              }
              ixReg += 1;
            }
          }
        if(freeOrder == null) 
        { /*:no registerItem found which is older than 1 our:*/
          
          
          ixReg = ixRegLast;/*get the oldest one.*/
          
          freeOrder = & (thiz->handles.data[ixReg]);
        }
        freeOrder->lastUsed = currentTime;
        freeOrder->secondOfCreation = currentTime;
        freeOrder->reflectionField = theField;
        set_MemSegmJc(freeOrder->addr, theObject);
        
        int16  typeValue = (int8 /*J2C_cast*/)getTypeFromField_ClassContent_Inspc(/*J2C:static method call*/theField, _thCxt);
        freeOrder->typeValue = (int8 /*J2C_cast*/)typeValue;
        freeOrder->sizeofValue = (int8 /*J2C_cast*/)nrofBytesForType_InspcDataExchangeAccess_Inspc(/*J2C:static method call*/typeValue, _thCxt);/*don't start by 0 on reset of the target! date-20131208*/
        
        freeOrder->check = currentTime & 0xfffff;
        handle = ixReg | (freeOrder->check << 12);
      }
      else 
      { 
        
        handle = -1;/*failure path*/
        
        idx = 0;
      }
    }_TRY
    CATCH(Exception, exc)
    
      { 
        
        /**Unexpected ...*/
        println_z_PrintStreamJc(REFJc (out_SystemJc), "ClassContent-getValueByPath - unexpected:", _thCxt);
        printStackTrace_Exception_emC(exc, _thCxt);
        handle = -1;/*failure*/
        
        idx = 0;
      }
    END_TRY
    if(handle != -1 && answerItem != null) 
    { 
      
      TRY
      { 
        
        addChildInteger_ByteDataAccessBaseJc(& ((* (answerItem)).base.super), 4, handle, _thCxt);
        getSetValue_ClassContent_Inspc(/*J2C:static method call*/theField, idx, theObject, null, answerItem, true, _thCxt);
        
        int32  length = getLength_ByteDataAccessBaseJc(& ((* (answerItem)).base.super), _thCxt);
        
        int32  nRest = 4 - (length & 0x3);
        if(nRest < 4) 
        { 
          
          addChildInteger_ByteDataAccessBaseJc(& ((* (answerItem)).base.super), nRest, 0, _thCxt);
        }
      }_TRY
      CATCH(Exception, exc)
      
        { 
          
          /**Unexpected ...*/
          println_z_PrintStreamJc(REFJc (out_SystemJc), "ClassContent-getValueByPath - unexpected:", _thCxt);
          printStackTrace_Exception_emC(exc, _thCxt);
          handle = -1;/*failure*/
          
        }
      END_TRY
    }
    { STACKTRC_LEAVE;
      return handle;
    }
  }
  STACKTRC_LEAVE;
}

void addAnswerItemValueByHandle_ClassContent_Inspc(ClassContent_Inspc_s* thiz, struct InspcDatagram_InspcDataExchangeAccess_Inspc_t* answer, struct InspcAnswerValueByHandle_InspcDataExchangeAccess_Inspc_t* answItem, int32 sizeExpected, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addAnswerItemValueByHandle_ClassContent_Inspc");
  
  { 
    
    if(!sufficingBytesForNextChild_ByteDataAccessBaseJc(& ((* (answer)).base.super), sizeHead_ByteDataAccessBaseJc(& ((* (answItem)).base.super.base.super), _thCxt) + sizeExpected, _thCxt)) 
    { 
      
      ASSERT_emC(/*J2C:static method call*/isInUse_ByteDataAccessBaseJc(& ((* (answItem)).base.super.base.super), _thCxt), "?", 0,0);
      
      int32  nrofBytesAnswerItem = getLength_ByteDataAccessBaseJc(& ((* (answItem)).base.super.base.super), _thCxt);
      setLength_Inspcitem_InspcDataExchangeAccess_Inspc(& ((* (answItem)).base.super), nrofBytesAnswerItem);/*Close this answer datagram, create a next: ////*/
      
      txAnswerAndPrepareNewTelg_ClassContent_Inspc(thiz, answer, _thCxt);
    }
    detach_ByteDataAccessBaseJc(& ((* (answItem)).base.super.base.super), _thCxt);
    if(!addChild_XX_ByteDataAccessBaseJc(& ((* (answer)).base.super), & ((* (answItem)).base.super.base.super), _thCxt)) 
    { }
  }
  STACKTRC_LEAVE;
}

void completeAnswerItemByHandle_ClassContent_Inspc(ClassContent_Inspc_s* thiz, struct InspcAnswerValueByHandle_InspcDataExchangeAccess_Inspc_t* answItem, int32 indexTo, int32 nOrderNr, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("completeAnswerItemByHandle_ClassContent_Inspc");
  
  { /*:complete this answItem:*/
    
    
    
    int32  nBytesItem = getLength_ByteDataAccessBaseJc(& ((* (answItem)).base.super.base.super), _thCxt);
    setIxHandleTo_InspcAnswerValueByHandle_InspcDataExchangeAccess_Inspc(answItem, indexTo, _thCxt);/*The start index of handle.  TODO more as one telg.*/
    
    setInfoHead_Inspcitem_InspcDataExchangeAccess_Inspc(& ((* (answItem)).base.super), nBytesItem, kAnswerValueByHandle_Inspcitem_InspcDataExchangeAccess_Inspc, nOrderNr, _thCxt);/*that information are written in the data. Because it is completed:*/
    
    detach_ByteDataAccessBaseJc(& ((* (answItem)).base.super.base.super), _thCxt);
  }
  STACKTRC_LEAVE;
}

int32 cmdGetValueByHandle_ClassContent_Inspc(ClassContent_Inspc_s* thiz, struct Inspcitem_InspcDataExchangeAccess_Inspc_t* cmd, struct InspcDatagram_InspcDataExchangeAccess_Inspc_t* answer, int32 maxNrofAnswerBytes, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("cmdGetValueByHandle_ClassContent_Inspc");
  
  { 
    
    
    InspcAnswerValueByHandle_InspcDataExchangeAccess_Inspc_s  answItem = { 0 };//J2C: constructor for embedded element-MemC
    ctorM_InspcAnswerValueByHandle_InspcDataExchangeAccess_Inspc(/*J2C:static method call*/build_MemC(&answItem, sizeof(answItem)), _thCxt);
    
    InspcAnswerValueByHandle_InspcDataExchangeAccess_Inspc_s  answFaultyItem = { 0 };//J2C: constructor for embedded element-MemC
    ctorM_InspcAnswerValueByHandle_InspcDataExchangeAccess_Inspc(/*J2C:static method call*/build_MemC(&answFaultyItem, sizeof(answFaultyItem)), _thCxt);
    
    int32  nrofHandle = (getLenInfo_Inspcitem_InspcDataExchangeAccess_Inspc(cmd) - sizeofHead_Inspcitem_InspcDataExchangeAccess_Inspc) / 4;
    
    int32  nOrderNr = getOrder_Inspcitem_InspcDataExchangeAccess_Inspc(cmd);
    
    int32  ixHandle = 0;
    
    int32  ixHandle1 = 0;
    
    bool  bCheckInvalidHandles = false;
    addAnswerItemValueByHandle_ClassContent_Inspc(thiz, answer, & (answItem), 20, _thCxt);/**/
    
    
    while(--nrofHandle >= 0)
      { /*:cmd.sufficingBytesForNextChild(4)) {  //there are 4 byte for the next handle in cmd.*/
        
        
        
        int32  handle = (int32 /*J2C_cast*/)getChildInteger_ByteDataAccessBaseJc(& ((* (cmd)).base.super), 4, _thCxt);
        
        int32  type = getValueByHandle_ClassContent_Inspc(thiz, handle, & (answItem), answer, ixHandle, nOrderNr, _thCxt);
        if(type == kInvalidHandle_InspcDataExchangeAccess_Inspc) 
        { 
          
          if(!bCheckInvalidHandles) 
          { /*:close the answItem for valid handles and add one for invalid:*/
            
            
            if(ixHandle == ixHandle1) 
            { /*:nothing found before:*/
              /*:a valid handle is found, but before it there were invalid ones or only one.*/
              /*:complete that answer item and create a new one.*/
              
              
              removeChild_XX_ByteDataAccessBaseJc(& ((* (answer)).base.super), & ((answItem).base.super.base.super), _thCxt);/*not used.*/
              
              detach_ByteDataAccessBaseJc(& ((answItem).base.super.base.super), _thCxt);
            }
            else 
            { 
              
              completeAnswerItemByHandle_ClassContent_Inspc(thiz, & (answItem), ixHandle - 1, nOrderNr, _thCxt);
            }
            addAnswerItemValueByHandle_ClassContent_Inspc(thiz, answer, & (answFaultyItem), 0, _thCxt);
            setInfoHead_Inspcitem_InspcDataExchangeAccess_Inspc(& ((answFaultyItem).base.super), getLengthHead_ByteDataAccessBaseJc(& ((answFaultyItem).base.super.base.super), _thCxt), kFailedHandle_Inspcitem_InspcDataExchangeAccess_Inspc, nOrderNr, _thCxt);
            setIxHandleFrom_InspcAnswerValueByHandle_InspcDataExchangeAccess_Inspc(& (answFaultyItem), ixHandle, _thCxt);
            addAnswerItemValueByHandle_ClassContent_Inspc(thiz, answer, & (answItem), 20, _thCxt);/*the item for proper answer after them.*/
            
            ixHandle1 = ixHandle;
            bCheckInvalidHandles = true;
          }
          setIxHandleTo_InspcAnswerValueByHandle_InspcDataExchangeAccess_Inspc(& (answFaultyItem), ixHandle, _thCxt);/*The start index of handle.  TODO more as one telg.*/
          
        }
        else if(bCheckInvalidHandles) 
        { /*:an valid handle is found after an invalid one:*/
          
          
          setIxHandleFrom_InspcAnswerValueByHandle_InspcDataExchangeAccess_Inspc(& (answItem), ixHandle, _thCxt);/*the first valid.*/
          
          bCheckInvalidHandles = false;
          ixHandle1 = ixHandle;
        }
        ixHandle += 1;/*count the handles for a next item in datagram.*/
        
      }/*while all handle.*/
      
    if(bCheckInvalidHandles) 
    { /*:*/
      
      
      removeChild_XX_ByteDataAccessBaseJc(& ((* (answer)).base.super), & ((answItem).base.super.base.super), _thCxt);/*not used.*/
      
      detach_ByteDataAccessBaseJc(& ((answItem).base.super.base.super), _thCxt);
    }
    else if(ixHandle > ixHandle1) 
    { /*:at least 1 or more values as answer stored:*/
      
      
      completeAnswerItemByHandle_ClassContent_Inspc(thiz, & (answItem), ixHandle - 1, nOrderNr, _thCxt);
    }
    detach_ByteDataAccessBaseJc(& ((answItem).base.super.base.super), _thCxt);/*detach it because it is a Stack instance in C, don't reference furthermore.*/
    
    detach_ByteDataAccessBaseJc(& ((answFaultyItem).base.super.base.super), _thCxt);/*detach it because it is a Stack instance in C, don't reference furthermore.*/
    
    { STACKTRC_LEAVE;
      return 0;
    }
  }
  STACKTRC_LEAVE;
}


/**Gets a value which is registered before by {@link #registerHandle(String, org.vishia.communication.InspcDataExchangeAccess.Inspcitem)}*/
int16 getValueByHandle_ClassContent_Inspc(ClassContent_Inspc_s* thiz, int32 handle, struct InspcAnswerValueByHandle_InspcDataExchangeAccess_Inspc_t* answItem, struct InspcDatagram_InspcDataExchangeAccess_Inspc_t* answer, int32 index, int32 nOrderNr, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getValueByHandle_ClassContent_Inspc");
  
  { 
    
    
    int16  type;/*no initvalue*/
    
    int32  idxDataAccess = handle & 0xfff;
    
    int32  check = (handle >> 12) & 0xfffff;
    if(idxDataAccess >= thiz->handles.head.length) 
    { 
      
      type = kInvalidHandle_InspcDataExchangeAccess_Inspc;
    }
    else 
    { 
      
      
      struct InspcDataInfo_Inspc_t*  datainfo = & (thiz->handles.data[idxDataAccess]);
      if(check == datainfo->check && datainfo->reflectionField != null) 
      { 
        
        TRY
        { 
          
          
          bool  bAnswerValueWithType = false;
          type = getSetValue_ClassContent_Inspc(/*J2C:static method call*/datainfo->reflectionField, 0, datainfo->addr, null, & ((* (answItem)).base.super), bAnswerValueWithType, _thCxt);
          if(type == -1) 
          { /*:has it place in answer?*/
            /*:The getSetValue has not enough place, in the answItem, */
            
            
            completeAnswerItemByHandle_ClassContent_Inspc(thiz, answItem, index, nOrderNr, _thCxt);
            addAnswerItemValueByHandle_ClassContent_Inspc(thiz, answer, answItem, 9999999, _thCxt);/*start a new datagram always.*/
            
            type = getSetValue_ClassContent_Inspc(/*J2C:static method call*/datainfo->reflectionField, 0, datainfo->addr, null, & ((* (answItem)).base.super), bAnswerValueWithType, _thCxt);
          }
          if(type <= maxNrOfChars_InspcDataExchangeAccess_Inspc) 
          { 
            
            type = kLengthAndString_InspcDataExchangeAccess_Inspc;
          }
          if((int8 /*J2C_cast*/)type != datainfo->typeValue) 
          { 
            
            println_z_PrintStreamJc(REFJc (err_SystemJc), "ClassContent - cmdGetValueByHandle; type mismatch", _thCxt);/*it should not occure because the field and the type should be consistent.*/
            
          }
        }_TRY
        CATCH(IllegalAccessException, exc)
        
          { 
            
            println_z_PrintStreamJc(REFJc (err_SystemJc), "ClassContent - cmdGetValueByHandle; Unexpected IllegalAccessException", _thCxt);
            type = kInvalidHandle_InspcDataExchangeAccess_Inspc;
          }
        END_TRY
      }
      else 
      { /*:The ident is faulty. Any ident request should have its answer.*/
        
        
        type = kInvalidHandle_InspcDataExchangeAccess_Inspc;
      }
    }
    { STACKTRC_LEAVE;
      return type;
    }
  }
  STACKTRC_LEAVE;
}


/**Gets the value described by this handle as float value. This method is offered to get a value by an internal*/
float getFloatValueByHandle_ClassContent_Inspc(ClassContent_Inspc_s* thiz, int32 handle, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getFloatValueByHandle_ClassContent_Inspc");
  
  { 
    
    
    int8 answerBuffer1[20] ; answerBuffer1; /*J2C:modeAccess=Q*/
    
    int8ARRAY  answerBuffer;/*no initvalue*/
    answerBuffer.addr = & answerBuffer1[0]; answerBuffer.val = sizeof( answerBuffer1) / sizeof(answerBuffer1[0]);/*for C: use a PtrVal as argument.*/
    
    
    InspcAnswerValueByHandle_InspcDataExchangeAccess_Inspc_s  answItem = { 0 };//J2C: constructor for embedded element-MemC
    ctorM_InspcAnswerValueByHandle_InspcDataExchangeAccess_Inspc(/*J2C:static method call*/build_MemC(&answItem, sizeof(answItem)), _thCxt);
    assignClear_ByteDataAccessBaseJc(& ((answItem).base.super.base.super), answerBuffer);
    
    int16  type = getValueByHandle_ClassContent_Inspc(thiz, handle, & (answItem), null, 0, 0, _thCxt);
    assign_iY_ByteDataAccessBaseJc(& ((answItem).base.super.base.super), answerBuffer);/*assign newly but yet to read the content.*/
    
    
    float  value = getFloatChild_InspcDataExchangeAccess_Inspc(/*J2C:static method call*/type, & ((answItem).base.super.base.super), _thCxt);
    detach_ByteDataAccessBaseJc(& ((answItem).base.super.base.super), _thCxt);/*detach it because it is a Stack instance in C, don't reference furthermore.*/
    
    { STACKTRC_LEAVE;
      return value;
    }
  }
  STACKTRC_LEAVE;
}


/**Gets the value described by this handle as int32 value. This method is offered to get a value by an internal*/
int32 getIntValueByHandle_ClassContent_Inspc(ClassContent_Inspc_s* thiz, int32 handle, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getIntValueByHandle_ClassContent_Inspc");
  
  { 
    
    
    int8 answerBuffer1[20] ; answerBuffer1; /*J2C:modeAccess=Q*/
    
    int8ARRAY  answerBuffer;/*no initvalue*/
    answerBuffer.addr = & answerBuffer1[0]; answerBuffer.val = sizeof( answerBuffer1) / sizeof(answerBuffer1[0]);/*for C: use a PtrVal as argument.*/
    
    
    InspcAnswerValueByHandle_InspcDataExchangeAccess_Inspc_s  answItem = { 0 };//J2C: constructor for embedded element-MemC
    ctorM_InspcAnswerValueByHandle_InspcDataExchangeAccess_Inspc(/*J2C:static method call*/build_MemC(&answItem, sizeof(answItem)), _thCxt);
    assignClear_ByteDataAccessBaseJc(& ((answItem).base.super.base.super), answerBuffer);
    
    int16  type = getValueByHandle_ClassContent_Inspc(thiz, handle, & (answItem), null, 0, 0, _thCxt);
    assign_iY_ByteDataAccessBaseJc(& ((answItem).base.super.base.super), answerBuffer);/*assign newly but yet to read the content.*/
    
    
    int32  value = getIntChild_InspcDataExchangeAccess_Inspc(/*J2C:static method call*/type, & ((answItem).base.super.base.super), _thCxt);
    detach_ByteDataAccessBaseJc(& ((answItem).base.super.base.super), _thCxt);/*detach it because it is a Stack instance in C, don't reference furthermore.*/
    
    { STACKTRC_LEAVE;
      return value;
    }
  }
  STACKTRC_LEAVE;
}


/**Converts the given Field of Reflection to the type byte.*/
int16 getTypeFromField_ClassContent_Inspc(/*J2C:static method*/ struct FieldJc_t const* theField, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getTypeFromField_ClassContent_Inspc");
  
  { 
    
    
    struct ClassJc_t const*  type = getType_FieldJc(theField);
    
    int16  nType;/*no initvalue*/
    if(isPrimitive_ClassJc(type)) 
    { 
      
      
      StringJc sType ; sType = z_StringJc(getName_ClassJc(type))/*J2C:non-persistent*/;
      
      char  cType = charAt_StringJc(sType, 0);
      switch(cType){
        case 'v': 
        case 'i': 
        { /*:int*/
          
          
          nType = ((/*J2C:cast% from int32*/int16)(kScalarTypes_InspcDataExchangeAccess_Inspc + REFLECTION_int32_ClassJc));
        }break;
        case 'c': 
        { /*:char*/
          
          
          nType = ((/*J2C:cast% from int32*/int16)(kScalarTypes_InspcDataExchangeAccess_Inspc + REFLECTION_int16_ClassJc));
        }break;
        case 's': 
        { /*:short*/
          
          
          nType = ((/*J2C:cast% from int32*/int16)(kScalarTypes_InspcDataExchangeAccess_Inspc + REFLECTION_int16_ClassJc));
        }break;
        case 'l': 
        { /*:long, it is int64*/
          
          
          nType = ((/*J2C:cast% from int32*/int16)(kScalarTypes_InspcDataExchangeAccess_Inspc + REFLECTION_int32_ClassJc));
        }break;
        case 'f': 
        { /*:float*/
          
          
          nType = ((/*J2C:cast% from int32*/int16)(kScalarTypes_InspcDataExchangeAccess_Inspc + REFLECTION_float_ClassJc));
        }break;
        case 'd': 
        { /*:double  TODO 'd' */
          
          
          nType = ((/*J2C:cast% from int32*/int16)(kScalarTypes_InspcDataExchangeAccess_Inspc + REFLECTION_double_ClassJc));
        }break;
        case 'b': switch(charAt_StringJc(sType, 1)){
          case 'o': 
          { /*:boolean*/
            
            
            nType = ((/*J2C:cast% from int32*/int16)(kScalarTypes_InspcDataExchangeAccess_Inspc + REFLECTION_int16_ClassJc));
          }break;
          case 'y': 
          { /*:byte*/
            
            
            nType = ((/*J2C:cast% from int32*/int16)(kScalarTypes_InspcDataExchangeAccess_Inspc + REFLECTION_int16_ClassJc));
          }break;
          case 'i': 
          { /*:bitfield*/
            
            
            nType = ((/*J2C:cast% from int32*/int16)(kScalarTypes_InspcDataExchangeAccess_Inspc + REFLECTION_int16_ClassJc));
          }break;
          default: 
          { 
            
            nType = kTypeNoValue_InspcDataExchangeAccess_Inspc;
          }
        }/*switch*/;break;
        default: 
        { 
          
          nType = kTypeNoValue_InspcDataExchangeAccess_Inspc;
        }/*default*/
        
      }/*switch*/;/*switch*/
      
    }
    else 
    { /*:it is a complex type, not a numeric.*/
      
      
      nType = kLengthAndString_InspcDataExchangeAccess_Inspc;
    }
    { STACKTRC_LEAVE;
      return nType;
    }
  }
  STACKTRC_LEAVE;
}

void stop_ClassContent_Inspc(ClassContent_Inspc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("stop_ClassContent_Inspc");
  
  { 
    
    
  }
  STACKTRC_LEAVE;
}



/**J2C: Reflections and Method-table *************************************************/
const VtblDef_ClassContent_Inspc mtblClassContent_Inspc = {
{ { sign_Vtbl_ClassContent_Inspc //J2C: Head of methodtable of ClassContent_Inspc
  , (struct Size_Vtbl_t*)((0 +2) * sizeof(void*)) //J2C:size. NOTE: all elements has the size of void*.
  }
  //J2C: The superclass's methodtable: 
, { { sign_Vtbl_ObjectJc //J2C: Head of methodtable of ObjectJc
    , (struct Size_Vtbl_t*)((5 +2) * sizeof(void*)) //J2C:size. NOTE: all elements has the size of void*.
    }
    //J2C: Dynamic methods of the class :ObjectJc:
  , clone_ObjectJc_F //clone
  , equals_ObjectJc_F //equals
  , finalize_ObjectJc_F //finalize
  , hashCode_ObjectJc_F //hashCode
  , toString_ObjectJc_F //toString
  }
  //J2C: The interface's methodtable: 
  //J2C: Vtbl-interfaces of :ClassContent_Inspc: */
, { { sign_Vtbl_CmdConsumer_ifc_Inspc //J2C: Head of methodtable of CmdConsumer_ifc_Inspc
    , (struct Size_Vtbl_t*)((2 +2) * sizeof(void*)) //J2C:size. NOTE: all elements has the size of void*.
    }
    //J2C: Dynamic methods of the class :CmdConsumer_ifc_Inspc:
  , executeMonitorCmd_XXXXi_ClassContent_Inspc //executeMonitorCmd
  , setAnswerComm_XX_ClassContent_Inspc //setAnswerComm
    //J2C: The superclass's methodtable: 
  , { { sign_Vtbl_ObjectJc //J2C: Head of methodtable of ObjectJc
      , (struct Size_Vtbl_t*)((5 +2) * sizeof(void*)) //J2C:size. NOTE: all elements has the size of void*.
      }
      //J2C: Dynamic methods of the class :ObjectJc:
    , clone_ObjectJc_F //clone
    , equals_ObjectJc_F //equals
    , finalize_ObjectJc_F //finalize
    , hashCode_ObjectJc_F //hashCode
    , toString_ObjectJc_F //toString
    }
  }
}, { signEnd_Vtbl_ObjectJc, null } }; //Vtbl


 extern_C struct ClassJc_t const refl_ObjectJc;
 static struct superClasses_ClassContent_Inspc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxVtblJc data[1];
 }superclasses_ClassContent_Inspc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxVtblJc, 1, OBJTYPE_ClassOffset_idxVtblJc, null, null)
 , { {&refl_ObjectJc, OFFSET_Vtbl(Vtbl_ClassContent_Inspc, ObjectJc) }
   }
 };

 extern_C struct ClassJc_t const refl_CmdConsumer_ifc_Inspc_s;
 static struct ifcClasses_ClassContent_Inspc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxVtblJc data[1];
 }interfaces_ClassContent_Inspc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxVtblJc, 1, OBJTYPE_ClassOffset_idxVtblJc, null, null)
, { {&refl_CmdConsumer_ifc_Inspc_s, OFFSET_Vtbl(Vtbl_ClassContent_Inspc, CmdConsumer_ifc_Inspc) }
  }
};

extern_C struct ClassJc_t const refl_ClassContent_Inspc_s;
extern_C struct ClassJc_t const refl_AnswerComm_ifc_Inspc_s;
extern_C struct ClassJc_t const refl_InspcDataInfo_Inspc_s;
extern_C struct ClassJc_t const refl_Inspcitem_InspcDataExchangeAccess_Inspc_s;
extern_C struct ClassJc_t const refl_MemAccessArrayDebugJc;
extern_C struct ClassJc_t const refl_ObjectJc;
extern_C struct ClassJc_t const refl_StringBuilderJc;
extern_C struct ClassJc_t const refl_StringJc;
const struct Reflection_Fields_ClassContent_Inspc_s_t
{ ObjectArrayJc head; FieldJc data[11];
} refl_Fields_ClassContent_Inspc_s =
{ CONST_ObjectArrayJc(FieldJc, 11, OBJTYPE_FieldJc, null, &refl_Fields_ClassContent_Inspc_s)
, {
     { "__TEST__"
    , 20 //nrofArrayElements
    , REFLECTION_int8
    , 1 << kBitPrimitiv_Modifier_reflectJc |kStaticArray_Modifier_reflectJc //bitModifiers
    , (int16)((intptr_t)(&((ClassContent_Inspc_s*)(0x1000))->__TEST__) - 0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_ClassContent_Inspc_s
    }
   , { "rootClass"
    , 0 //nrofArrayElements
    , &refl_ObjectJc
    , kReference_Modifier_reflectJc //bitModifiers
    , (int16)((intptr_t)(&((ClassContent_Inspc_s*)(0x1000))->rootClass) - 0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_ClassContent_Inspc_s
    }
   , { "answerComm"
    , 0 //nrofArrayElements
    , &refl_AnswerComm_ifc_Inspc_s
    , kReference_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((intptr_t)(&((ClassContent_Inspc_s*)(0x1000))->answerComm) - 0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_ClassContent_Inspc_s
    }
   , { "debugRemoteAccess"
    , 0 //nrofArrayElements
    , &refl_MemAccessArrayDebugJc
    , kReference_Modifier_reflectJc //bitModifiers
    , (int16)((intptr_t)(&((ClassContent_Inspc_s*)(0x1000))->debugRemoteAccess) - 0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_ClassContent_Inspc_s
    }
   , { "answerItem"
    , 0 //nrofArrayElements
    , &refl_Inspcitem_InspcDataExchangeAccess_Inspc_s
    , kEmbedded_Modifier_reflectJc //bitModifiers
    , (int16)((intptr_t)(&((ClassContent_Inspc_s*)(0x1000))->answerItem) - 0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_ClassContent_Inspc_s
    }
   , { "uArray"
    , 0 //nrofArrayElements
    , &refl_StringBuilderJc
    , kEmbedded_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((intptr_t)(&((ClassContent_Inspc_s*)(0x1000))->uArray) - 0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_ClassContent_Inspc_s
    }
   , { "uValue"
    , 0 //nrofArrayElements
    , &refl_StringBuilderJc
    , kEmbedded_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((intptr_t)(&((ClassContent_Inspc_s*)(0x1000))->uValue) - 0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_ClassContent_Inspc_s
    }
   , { "uAnswer"
    , 0 //nrofArrayElements
    , &refl_StringBuilderJc
    , kEmbedded_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((intptr_t)(&((ClassContent_Inspc_s*)(0x1000))->uAnswer) - 0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_ClassContent_Inspc_s
    }
   , { "test"
    , 0 //nrofArrayElements
    , &refl_InspcDataInfo_Inspc_s
    , kEmbedded_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((intptr_t)(&((ClassContent_Inspc_s*)(0x1000))->test) - 0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_ClassContent_Inspc_s
    }
   , { "handles"
    , 1024 //nrofArrayElements
    , &refl_InspcDataInfo_Inspc_s
    , kEmbedded_Modifier_reflectJc |mObjectJc_Modifier_reflectJc |kStaticArray_Modifier_reflectJc |kEmbeddedContainer_Modifier_reflectJc //bitModifiers
    , (int16)((intptr_t)(&((ClassContent_Inspc_s*)(0x1000))->handles) - 0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_ClassContent_Inspc_s
    }
   , { "version"
    , 0 //nrofArrayElements
    , &refl_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&version_ClassContent_Inspc) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((intptr_t)(&version_ClassContent_Inspc)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &refl_ClassContent_Inspc_s
    }
} };
const ClassJc refl_ClassContent_Inspc_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &refl_ObjectJc, &refl_ClassJc) 
, "ClassContent_Inspc_s"
, (int16)((intptr_t)(&((ClassContent_Inspc_s*)(0x1000))->base.object) - 0x1000)
, sizeof(ClassContent_Inspc_s)
, (FieldJc_Y const*)&refl_Fields_ClassContent_Inspc_s
, null //method
, &superclasses_ClassContent_Inspc_s.head.object //superclass
, (ClassOffset_idxVtblJcARRAY*)&interfaces_ClassContent_Inspc_s //interfaces
, mObjectJc_Modifier_reflectJc
, &mtblClassContent_Inspc.mtbl.head
};


#endif //def DEF_ClassJc_Vtbl
