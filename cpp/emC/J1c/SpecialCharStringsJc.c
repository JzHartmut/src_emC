/**************************************************************************
 * This file is generated by Java2C
 **copyright***************************************************************
 *************************************************************************/
#ifdef DEF_ObjectJcpp_REFLECTION  //only possible with reflection because Vtable is need


#include "emC/J1c/SpecialCharStringsJc.h"
#include <string.h>  //because using memset()
#include <emC/Jc/ReflectionJc.h>   //Reflection concept 
  //basic stacktrace concept
#include "emC/J1c/StringFunctionsJc.h"  //reference-association: StringFunctionsJc_s
#include "emC/Jc/StringJc.h"  //new object


/* J2C: Forward declaration of struct ***********************************************/
struct StringBuilderJc_t;

/**This class helps to handle with special chars in Strings.
In Java all Strings are encoded with UTF-16. But in Files the encoding is mostly implemented
with 1 byte per char. Different encodings are used, ISO-8859-1 is typical for windows systems,
but also UTF-8. To write special chars in any desired encoding, some systems are ordinary.
In programming, the backslash is used to switch to special char codes, typically \\n for new line.
In XML the system of special character codes starts with an ampersand, typically
&amp; for the &-character itself.

This class supports the backslash-philosophy to indicate special character codes.
@author JcHartmut

*/


const char sign_Vtbl_SpecialCharStringsJc[] = "SpecialCharStringsJc"; //to mark method tables of all implementations

typedef struct VtblDef_SpecialCharStringsJc_t { Vtbl_SpecialCharStringsJc mtbl; VtblHeadJc end; } VtblDef_SpecialCharStringsJc;
 extern VtblDef_SpecialCharStringsJc const mtblSpecialCharStringsJc;

/*Constructor *//**J2C: autogenerated as default constructor. */
struct SpecialCharStringsJc_t* ctorO_SpecialCharStringsJc(ObjectJc* othis, ThCxt* _thCxt)
{ SpecialCharStringsJc_s* thiz = (SpecialCharStringsJc_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_SpecialCharStringsJc");
  checkConsistence_ObjectJc(othis, sizeof(SpecialCharStringsJc_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &refl_SpecialCharStringsJc_s, sizeof(SpecialCharStringsJc_s));  
  //j2c: Initialize all class variables:
  {
  }/*J2C:No body for constructor*/

  STACKTRC_LEAVE;
  return thiz;
}



/**Resolves the given String containing some switch chars in form of backslash */
CharSeqJc resolveCircumScription_SpecialCharStringsJc(/*J2C:static method*/ CharSeqJc src, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("resolveCircumScription_SpecialCharStringsJc");
  
  { 
    
    
    char  cSwitch = '\\';
    
    int32  posSwitch = indexOf_Csci_StringFunctionsJc(/*J2C:static method call*/src, cSwitch, 0, _thCxt);
    if(posSwitch < 0) 
    { 
      
      { STACKTRC_LEAVE;
        return src;
      }
    }
    else 
    { /*:escape character is found before end*/
      
      ObjectJc *newObj3_1=null; /*J2C: temporary Objects for new operations
      */
      
      struct StringBuilderJc_t*  sbReturn = ctorO_cs_StringBuilderJc(/*J2C:static method call*/(newObj3_1 = alloc_ObjectJc(sizeof_StringBuilderJc, 0, _thCxt)), src, _thCxt);
      
      while(posSwitch >= 0)
        { 
          
          if(posSwitch < length_StringBuilderJc(sbReturn) - 1) 
          { 
            
            deleteCharAt_StringBuilderJc(sbReturn, posSwitch, _thCxt);
          }
          
          char  cNext = charAt_StringBuilderJc(sbReturn, posSwitch, _thCxt);
          
          int32  iChangedChar;/*no initvalue*/
          if((iChangedChar = /*? assignment*/indexOf_C_StringJc(zI_StringJc("snrtfb",6), cNext)) >= 0) 
          { 
            
            setCharAt_StringBuilderJc(sbReturn, posSwitch, charAt_StringJc(zI_StringJc(" \n\r\t\f\b",6), iChangedChar), _thCxt);
          }
          else if(cNext == 'a') 
          { /*: \a means end of file, coded inside with 4 = EOT (end of transmission).*/
            
            
            setCharAt_StringBuilderJc(sbReturn, posSwitch, cStartOfText_StringFunctionsJc, _thCxt);
          }
          else if(cNext == 'e') 
          { /*: \e means end of file, coded inside with 4 = EOT (end of transmission).*/
            
            
            setCharAt_StringBuilderJc(sbReturn, posSwitch, cEndOfText_StringFunctionsJc, _thCxt);
          }
          else if(cNext == 'W') 
          { /*: \W means a non-word character like in regulare expressions.*/
            
            
            setCharAt_StringBuilderJc(sbReturn, posSwitch, cNoCidentifier_StringFunctionsJc, _thCxt);
          }
          else 
          { }
          posSwitch = indexOf_Csci_StringFunctionsJc(/*J2C:static method call*/fromStringBuilderJc_CharSeqJc(sbReturn), cSwitch, posSwitch + 1, _thCxt);
        }
      { STACKTRC_LEAVE;
        activateGC_ObjectJc(newObj3_1, sbReturn, _thCxt);
        return fromStringBuilderJc_CharSeqJc(sbReturn);
      }
    }
  }
  STACKTRC_LEAVE;
}



/**J2C: Reflections and Method-table *************************************************/
const VtblDef_SpecialCharStringsJc mtblSpecialCharStringsJc = {
{ { sign_Vtbl_SpecialCharStringsJc //J2C: Head of methodtable of SpecialCharStringsJc
  , (struct Size_Vtbl_t*)((0 +2) * sizeof(void*)) //J2C:size. NOTE: all elements has the size of void*.
  }
  //J2C: The superclass's methodtable: 
, { { sign_Vtbl_ObjectJc //J2C: Head of methodtable of ObjectJc
    , (struct Size_Vtbl_t*)((5 +2) * sizeof(void*)) //J2C:size. NOTE: all elements has the size of void*.
    }
    //J2C: Dynamic methods of the class :ObjectJc:
  , clone_ObjectJc_F //clone
  , equals_ObjectJc_F //equals
  , finalize_ObjectJc_F //finalize
  , hashCode_ObjectJc_F //hashCode
  , toString_ObjectJc_F //toString
  }
}, { signEnd_Vtbl_ObjectJc, null } }; //Vtbl


 extern_C struct ClassJc_t const refl_ObjectJc;
 static struct superClasses_SpecialCharStringsJc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxVtblJc data[1];
 }superclasses_SpecialCharStringsJc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxVtblJc, 1, OBJTYPE_ClassOffset_idxVtblJc, null, null)
 , { {&refl_ObjectJc, OFFSET_Vtbl(Vtbl_SpecialCharStringsJc, ObjectJc) }
   }
 };

const ClassJc refl_SpecialCharStringsJc_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &refl_ObjectJc, &refl_ClassJc) 
, "SpecialCharStringsJc_s"
,  0 //position of ObjectJc
, sizeof(SpecialCharStringsJc_s)
, null //attributes and associations
, null //method
, &superclasses_SpecialCharStringsJc_s.head.object //superclass
, null //interfaces
, 0    //modifiers
, &mtblSpecialCharStringsJc.mtbl.head
};


#endif //#ifdef DEF_ObjectJcpp_REFLECTION  //only possible with reflection because Vtable is need
