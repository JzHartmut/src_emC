/**************************************************************************
 * This file is generated by Java2C
 **copyright***************************************************************
 *************************************************************************/
#include <applstdef_emC.h>
#if defined(DEF_ObjectJcpp_REFLECTION) && ! defined(DEF_NO_StringUSAGE)  //only possible with reflection because Vtable is need


#include "emC/J1c/StringPartJc.h"
#include <string.h>  //because using memset()
#include <emC/Jc/ReflectionJc.h>   //Reflection concept 
  //basic stacktrace concept
#include "emC/J1c/StringFunctionsJc.h"  //reference-association: StringFunctionsJc_s


/* J2C: Forward declaration of struct ***********************************************/

/**The StringPart class represents a flexible valid part of a character string which's spread is changeable. 
It may be seen as an alternative to the standard {@link java.lang.String} for the capability to build a {@link String#substring(int)}.
<ul>
<li>1. The substring or Part of the String can be build with some operations, {@link #seek(CharSequence, int)}, {@link #lento(CharSequence)} etc.
<li>2. This class represents a Part of the String which is able to change.
<li>3. The operation to build a Part does not build an independent String, but refers inside the given String.
<li>4. The Part is able to build from any CharSequence, especially from a StringBuilder or from any char[]-Array.
</ul>
<b>Calculation time and memory effect</b>:<br>
The 3. minute affects the calculation time for extensive using of parts of a String. The {@link String#substring(int)} method
of standard Java till Version 6 builds a substring using and references the stored parent String. It was a cheap operation 
in calculation time. 
<br><br>
In Java version 7 this behavior was changed. Up to version 7 a substring builds an new buffer for the substring
in the heap. The advantage is: If a long String exists firstly, then some substrings are build, and the firstly long String
is not used anymore, the memory of the long String can garbaged now. The application does not need yet memory for the originally long String,
only the typical short substrings are stored in the heap. For applications, which builds some short substrings from a
long parent String, it saves memory.
<br><br>
But if substrings are need extensively from one long String, to search somewhat etc, The creation of new memory for any substring
may be an expensive operation. This class works with the given String, builds parts of the string with indices, 
and does not need memory for any sub part.
<br><br>


<b>Multithreading, persistence of Strings</b>:<br>
A StringPart depends of its parent CharSequence. That CharSequence maybe a String, which is persistent. But that CharSequence
maybe a StringBuilder or any other volatile storage. Changing the CharSequence my disturb operations of the StringPart.
Therefore the parent CharSequence should be notice. Is it changed? 
<br><br>
If a Part should be stored persistently, one can use a {@link #toString()} method of any returned CharSequence
for example {@link #getCurrentPart()}.toString(). This builds a persistent String which can be stored and used independent of all others.
<br><br>
But if the Part of String is used in the same thread, not stored, and another thread does not disturb the content of the 
StringPart's parent CharSequence (which may be usual), the waiver to build a persistent String may save a little bit of calculation time.
A method which accepts a {@link java.lang.CharSequence} as parameter should not store that in suggestion of persistence. 
For example {@link StringBuilder#append(CharSequence)} uses a non-persistent character sequence and adds it to its own buffer.
<br><br>


<b>Access as CharSequence</b>:<br>
This class is a {@link java.lang.CharSequence}. The sequence of chars is represented by the {@link #getCurrentPart()}.
The method {@link #length()} returns the length of the current part. The method {@link #charAt(int)}
returns the characters from {@link #beginLast}. The method {@link #subSequence(int, int)} builds a {@link Part}
which refers the sub sequence inside the {@link #content}.


<br><br>


<b>Principles of operation</b>:<br>
The StringPart class is associated to any CharSequence. Additionally 4 Parameters determine the actual part of the String
and the limits of changing of the actual part. The followed image is used to explain the spread of a part:
<pre>
abcdefghijklmnopqrstuvwxyz  Sample of the whole associated String
=====================     The === indicates the maximal part
-----------             The --- indicates the valid part before some operation
+++++             The +++ indicates the valid part after some operation
</pre> 
The actual part of the string is changeable, without building a new substring. 
So some operations of seeking and scanning are offered. 
<br><br>
<b>Types of Methods</b>:<br>
<ul>
<li>assign: assigns a new parent string: {@link #assign(CharSequence)}, like constructor
<li>seek: changes the start position of the actual (current) string part, do not change the end of the actual part,
from there, seek changes the length. Seek returns this, so concatenation of method calls is possible.
<ul>
<li>{@link #seekPos(int)}, {@link #seekPosBack(int)}: Seek with given number of chars, for example seek(1) to skip over one character
<li>{@link #seek(char, int)}, {@link #seek(CharSequence, int)}: Searches a character or a CharSequence
<li>{@link #seekAnyChar(CharSequence)},  {@link #seekBackToAnyChar(CharSequence)}: Searches any of some given characters.
<li>{@link #seek(CharSequence, int)}, {@link #seekBackward(CharSequence)}: Searches any of some given characters.
<li>{@link #seekAnyString(CharSequence[], int[])}: Searches any of some given character sequences.
<li>{@link #seekNoWhitespace()}, {@link #seekNoWhitespaceOrComments()}: skip over all white spaces, maybe over comments
<li>{@link #seekNoChar(CharSequence)} skip over all given characters
<li>{@link #seekBegin()} Expands the spread starting from the most left position (the <i>maximal part</i>)
</ul>  
<li>lento: changes the end of the actual string part.
<ul>
<li>{@link #lento(int)}: set a length of the valid part
<li>{@link #lento(char)}, {@link #lento(CharSequence, int)}: length till a end character or end string
<li>{@link #lentoAnyChar(CharSequence, int)}, {@link #lentoAnyString(CharSequence[], int)}: length till one of some given end characters or Strings
<li>{@link #lentoAnyCharOutsideQuotion(CharSequence, int)}: regards CharSequence in quotation as non-applying.
<li>#lentoAnyNonEscapedChar(CharSequence, int): regards characters after a special char as non-applying.
<li>#lentoAnyStringWithIndent(CharSequence[], CharSequence, int, StringBuilder): regards indentation typically for source files.
<li>#lentoIdentifier(), #lentoIdentifier(CharSequence, CharSequence): accepts identifier
</ul>
<li>{@link #firstlineMaxpart()}, {@link #nextlineMaxpart()}: line processing. Each line can be individually evaluated or scanned.   
<li>get: Gets an content without changing.
<ul>
<li>#getCurrentPart(): The valid part as CharSequence, use toString() to transform to a persistent String.
<li>#getCurrent(int): Requested number of chars from start of the current part, for tests and debugging.
<li>#getLastPart(): Last valid part before the last seek or scan.
</ul>
<li>indexOf: search any one in the valid part.
<ul>
<li>{@link #indexEndOfQuotation(char, char, int, int)} etc.
</ul>
<li>See {@link StringPartScan}  for further scan functions.
<li>See {@link StringPartAppend}, {@link StringPartFromFileLines} for complete processing.
<li>See {@link StringFunctions} for basic operations.  
</ul>            
*/


const char sign_Vtbl_StringPartJc[] = "StringPartJc"; //to mark method tables of all implementations

#ifdef DEF_ClassJc_Vtbl
typedef struct VtblDef_StringPartJc_t { Vtbl_StringPartJc mtbl; VtblHeadJc end; } VtblDef_StringPartJc;
 extern VtblDef_StringPartJc const mtblStringPartJc;
#endif //#ifdef DEF_ClassJc_Vtbl

StringJc sVersion_StringPartJc = CONST_z_StringJc("2016-09-04"); //J2C:static StringJc
const int32 seekToLeft_StringPartJc = mSeekToLeft__StringPartJc + mSeekBackward__StringPartJc;
const int32 seekBack_StringPartJc = 0x20 + mSeekBackward__StringPartJc;

/*Constructor */
struct StringPartJc_t* ctorO_StringPartJc(ObjectJc* othis, ThCxt* _thCxt)
{ StringPartJc_s* thiz = (StringPartJc_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_StringPartJc");
  checkConsistence_ObjectJc(othis, sizeof(StringPartJc_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &refl_StringPartJc_s, sizeof(StringPartJc_s));  
  //j2c: Initialize all class variables:
  {
    thiz->bCurrentOk = true;
    thiz->bStartScan = true;
    thiz->bFound = true;
    thiz->bitMode = 0;
    set_s_StringJc(&(thiz->sCommentStart), z_StringJc("/*"));
    set_s_StringJc(&(thiz->sCommentEnd), z_StringJc("*/"));
    set_s_StringJc(&(thiz->sCommentToEol), z_StringJc("//"));
  }
  { 
    
    thiz->content = null_CharSeqJc /*J2C: mem assignment*/;
    thiz->begiMin = thiz->begin = /*? assignment*/thiz->beginLast = /*? assignment*/0;
    thiz->endLast = thiz->endMax = /*? assignment*/thiz->end = /*? assignment*/0;
  }
  STACKTRC_LEAVE;
  return thiz;
}



/*Constructor */
struct StringPartJc_t* ctorO_Cs_StringPartJc(ObjectJc* othis, CharSeqJc src, ThCxt* _thCxt)
{ StringPartJc_s* thiz = (StringPartJc_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_StringPartJc");
  checkConsistence_ObjectJc(othis, sizeof(StringPartJc_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &refl_StringPartJc_s, sizeof(StringPartJc_s));  
  //j2c: Initialize all class variables:
  {
    thiz->bCurrentOk = true;
    thiz->bStartScan = true;
    thiz->bFound = true;
    thiz->bitMode = 0;
    set_s_StringJc(&(thiz->sCommentStart), z_StringJc("/*"));
    set_s_StringJc(&(thiz->sCommentEnd), z_StringJc("*/"));
    set_s_StringJc(&(thiz->sCommentToEol), z_StringJc("//"));
  }
  { 
    
    ctorO_Csii_StringPartJc(othis, src, 0, length_CharSeqJc(src/*J1cT2*/, _thCxt), _thCxt);
  }
  STACKTRC_LEAVE;
  return thiz;
}



/*Constructor */
struct StringPartJc_t* ctorO_Csii_StringPartJc(ObjectJc* othis, CharSeqJc src, int32 start, int32 end, ThCxt* _thCxt)
{ StringPartJc_s* thiz = (StringPartJc_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_StringPartJc");
  checkConsistence_ObjectJc(othis, sizeof(StringPartJc_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &refl_StringPartJc_s, sizeof(StringPartJc_s));  
  //j2c: Initialize all class variables:
  {
    thiz->bCurrentOk = true;
    thiz->bStartScan = true;
    thiz->bFound = true;
    thiz->bitMode = 0;
    set_s_StringJc(&(thiz->sCommentStart), z_StringJc("/*"));
    set_s_StringJc(&(thiz->sCommentEnd), z_StringJc("*/"));
    set_s_StringJc(&(thiz->sCommentToEol), z_StringJc("//"));
  }
  { 
    
    thiz->begiMin = thiz->begin = /*? assignment*/start;
    thiz->endMax = thiz->end = /*? assignment*/end;
    thiz->content = src;
    ASSERT(/*J2C:static method call*/end <= length_CharSeqJc(thiz->content/*J1cT2*/, _thCxt));
  }
  STACKTRC_LEAVE;
  return thiz;
}



/**Sets the input file for information {@link #getInputfile()}*/
void setInputfile_StringPartJc(StringPartJc_s* thiz, StringJc file, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setInputfile_StringPartJc");
  
  { 
    
    set_s_StringJc(&(thiz->sFile), file);
  }
  STACKTRC_LEAVE;
}


/**Sets the content to the given string, forgets the old content. Initialy the whole string is valid.*/
struct StringPartJc_t* assign_Cs_StringPartJc(StringPartJc_s* thiz, CharSeqJc ref, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("assign_Cs_StringPartJc");
  
  { 
    
    thiz->content = ref;
    setParttoMax_StringPartJc(thiz, _thCxt);
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}

#if 0 //only one depenency to SystemJc, move in a derived class in Java.
/**Sets the content to the given string, forgets the old content. */
struct StringPartJc_t* assignReplaceEnv_StringPartJc(StringPartJc_s* thiz, struct StringBuilderJc_t* input, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("assignReplaceEnv_StringPartJc");
  
  { 
    
    
    int32  pos1 = 0;
    
    int32  zInput = length_StringBuilderJc(input);
    
    while((pos1 = /*? assignment*/indexOf_zI_StringBuilderJc(input, "$", pos1, _thCxt)) >= 0)
      { 
        
        
        int32  posident;/*no initvalue*/
        
        int32  posidentend;/*no initvalue*/
        
        int32  pos9;/*no initvalue*/
        if(charAt_StringBuilderJc(input, pos1 + 1, _thCxt) == '(') 
        { 
          
          posident = pos1 + 2;
          posidentend = indexOf_zI_StringBuilderJc(input, ")", posident, _thCxt);
          pos9 = posidentend + 1;/*after )*/
          
        }
        else 
        { 
          
          posident = pos1 + 1;
          posidentend = pos9 = /*? assignment*/posAfterIdentifier_Csii_StringFunctionsJc(/*J2C:static method call*/fromStringBuilderJc_CharSeqJc(input), posident, zInput, _thCxt);
        }
        
        StringJc sEnv ; sEnv = getenv_SystemJc(/*J2C:static method call*/substring_StringBuilderJc(input, posident, posidentend, _thCxt), _thCxt)/*J2C:non-persistent*/;
        if(sEnv.ref== null) 
        { 
          
          sEnv = z_StringJc("")/*J2C:non-persistent*/;
        }
        replace_StringBuilderJc(input, pos1, pos9, sEnv, _thCxt);
        zInput = length_StringBuilderJc(input);
      }
    thiz->content = fromStringBuilderJc_CharSeqJc(input);
    thiz->begiMin = thiz->beginLast = /*? assignment*/thiz->begin = /*? assignment*/0;
    thiz->endMax = thiz->end = /*? assignment*/thiz->endLast = /*? assignment*/length_CharSeqJc(thiz->content/*J1cT2*/, _thCxt);
    thiz->bStartScan = thiz->bCurrentOk = /*? assignment*/true;
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}
#endif //0

/**Sets the StringPart with the same String object as the given StringPart, forgets the old content.*/
struct StringPartJc_t* assign_XX_StringPartJc(StringPartJc_s* thiz, struct StringPartJc_t* src, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("assign_XX_StringPartJc");
  
  { 
    
    if(src == thiz) 
    { /*:set from the own instance: the maxPart is the actual one.*/
      
      
      thiz->begiMin = thiz->beginLast = /*? assignment*/thiz->begin;
      thiz->endMax = thiz->endLast = /*? assignment*/thiz->end;
    }
    else 
    { /*:set from a other instance, inherit the content.*/
      
      
      thiz->content = src->content;
      thiz->begiMin = thiz->beginLast = /*? assignment*/thiz->begin = /*? assignment*/src->begin;
      thiz->endMax = thiz->end = /*? assignment*/thiz->endLast = /*? assignment*/src->end;
      ASSERT(/*J2C:static method call*/thiz->endMax <= length_CharSeqJc(thiz->content/*J1cT2*/, _thCxt));
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the content of the StringPart , forgets the old content. The same string like in src is associated.*/
struct StringPartJc_t* assignFromEnd_StringPartJc(StringPartJc_s* thiz, struct StringPartJc_t* src, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("assignFromEnd_StringPartJc");
  
  { 
    
    thiz->content = src->content;
    thiz->beginLast = thiz->begin;
    thiz->begiMin = thiz->begin = /*? assignment*/src->end;/*from actual end*/
    
    thiz->endLast = thiz->endMax = /*? assignment*/thiz->end = /*? assignment*/src->endMax;/*from maximal end*/
    
    ASSERT(/*J2C:static method call*/thiz->endMax <= length_CharSeqJc(thiz->content/*J1cT2*/, _thCxt));
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Set the mode of ignoring comments.*/
bool setIgnoreComment_b_StringPartJc(StringPartJc_s* thiz, bool bSet, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setIgnoreComment_b_StringPartJc");
  
  { 
    
    
    bool  bRet = (thiz->bitMode & mSkipOverCommentInsideText_mode_StringPartJc) != 0;
    if(bSet) thiz->bitMode |= mSkipOverCommentInsideText_mode_StringPartJc;
    else thiz->bitMode &= ~mSkipOverCommentInsideText_mode_StringPartJc;
    { STACKTRC_LEAVE;
      return bRet;
    }
  }
  STACKTRC_LEAVE;
}


/**Set the character string of inline commentmode of ignoring comments.*/
bool setIgnoreComment_SS_StringPartJc(StringPartJc_s* thiz, StringJc sStart, StringJc sEnd, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setIgnoreComment_SS_StringPartJc");
  
  { 
    
    
    bool  bRet = (thiz->bitMode & mSkipOverCommentInsideText_mode_StringPartJc) != 0;
    thiz->bitMode |= mSkipOverCommentInsideText_mode_StringPartJc;
    set_s_StringJc(&(thiz->sCommentStart), sStart);
    set_s_StringJc(&(thiz->sCommentEnd), sEnd);
    { STACKTRC_LEAVE;
      return bRet;
    }
  }
  STACKTRC_LEAVE;
}


/**Set the mode of ignoring comments to end of line.*/
bool setIgnoreEndlineComment_b_StringPartJc(StringPartJc_s* thiz, bool bSet, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setIgnoreEndlineComment_b_StringPartJc");
  
  { 
    
    
    bool  bRet = (thiz->bitMode & mSkipOverCommentToEol_mode_StringPartJc) != 0;
    if(bSet) thiz->bitMode |= mSkipOverCommentToEol_mode_StringPartJc;
    else thiz->bitMode &= ~mSkipOverCommentToEol_mode_StringPartJc;
    { STACKTRC_LEAVE;
      return bRet;
    }
  }
  STACKTRC_LEAVE;
}


/**Set the character string introducing the comments to end of line.*/
bool setIgnoreEndlineComment_S_StringPartJc(StringPartJc_s* thiz, StringJc sStart, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setIgnoreEndlineComment_S_StringPartJc");
  
  { 
    
    
    bool  bRet = (thiz->bitMode & mSkipOverCommentToEol_mode_StringPartJc) != 0;
    thiz->bitMode |= mSkipOverCommentToEol_mode_StringPartJc;
    set_s_StringJc(&(thiz->sCommentToEol), sStart);
    { STACKTRC_LEAVE;
      return bRet;
    }
  }
  STACKTRC_LEAVE;
}


/**Set the mode of ignoring whitespaces.*/
bool setIgnoreWhitespaces_StringPartJc(StringPartJc_s* thiz, bool bSet, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setIgnoreWhitespaces_StringPartJc");
  
  { 
    
    
    bool  bRet = (thiz->bitMode & mSkipOverWhitespace_mode_StringPartJc) != 0;
    if(bSet) thiz->bitMode |= mSkipOverWhitespace_mode_StringPartJc;
    else thiz->bitMode &= ~mSkipOverWhitespace_mode_StringPartJc;
    { STACKTRC_LEAVE;
      return bRet;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the start of the maximal part to the actual start of the valid part.*/
struct StringPartJc_t* setBeginMaxPart_StringPartJc(StringPartJc_s* thiz)
{ 
  
  { 
    
    thiz->begiMin = thiz->begin;
    
      return thiz;
  }
}


/**Sets the full range of available text.*/
struct StringPartJc_t* setParttoMax_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setParttoMax_StringPartJc");
  
  { 
    
    thiz->begiMin = thiz->beginLast = /*? assignment*/thiz->begin = /*? assignment*/0;
    thiz->endMax = thiz->end = /*? assignment*/thiz->endLast = /*? assignment*/length_CharSeqJc(thiz->content/*J1cT2*/, _thCxt);
    thiz->bStartScan = thiz->bCurrentOk = /*? assignment*/true;
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the start of the part to the exclusively end, set the end to the end of the content.*/
struct StringPartJc_t* fromEnd_StringPartJc(StringPartJc_s* thiz)
{ 
  
  { 
    
    thiz->beginLast = thiz->begin;
    thiz->endLast = thiz->end;
    thiz->begin = thiz->end;
    thiz->end = thiz->endMax;
    
      return thiz;
  }
}


/**This method returns the characters of the current part.*/
char charAt_i_StringPartJc(CharSeqObjJc const* ithis, int32 index, ThCxt* _thCxt)
{ StringPartJc_s const* thiz = (StringPartJc_s const*)ithis;
  
  STACKTRC_TENTRY("charAt_i_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return absCharAt_StringPartJc(thiz, thiz->begin + index, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

bool checkCharAt_StringPartJc(StringPartJc_s* thiz, int32 pos, StringJc chars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("checkCharAt_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return (thiz->begin + pos >= thiz->end) ? false : indexOf_C_StringJc(chars, charAt_i_StringPartJc((&(* (thiz)).base.CharSeqObjJc_ifc)/*J2cT1*/, pos, _thCxt)) >= 0;
    }/*char found.*/
    
  }
  STACKTRC_LEAVE;
}


#if defined( DEF_ClassJc_Vtbl)
/**Returns a volatile CharSequence from the range inside the current part.*/
CharSeqJc subSequence_ii_StringPartJc(CharSeqObjJc const* ithis, int32 from, int32 to, ThCxt* _thCxt)
{ StringPartJc_s* thiz = (StringPartJc_s*)ithis;
  
  STACKTRC_TENTRY("subSequence_ii_StringPartJc");
  
  { 
    
    if(from < 0 || to > (thiz->end - thiz->begin)) 
    { 
      
      throwSubSeqFaulty_StringPartJc(thiz, from, to, _thCxt);
      { STACKTRC_LEAVE;
        return null_CharSeqJc /*J2C: mem assignment*/;
      }/*It is used for Java2C without throw mechanism.*/
      
    }
    #ifdef DEF_ThreadContext_HEAP_emC
    struct Part_StringPartJc_t*  ret = ctorO_Part_StringPartJc(thiz, allocInThreadCxt_ObjectJc(sizeof(Part_StringPartJc_s), "StringPart.subSequence", _thCxt), thiz->begin + from, thiz->begin + to, _thCxt);
    { STACKTRC_LEAVE;
      return fromObjectJc_CharSeqJc(&(* (ret)).base.object);
    }
    #else
      THROW_s0(IllegalArgumentException, "only possible if Heap on thread exists", 0,0);
      return null_StringJc;
    #endif
  }
  STACKTRC_LEAVE;
}
#endif //#ifdef DEF_ClassJc_Vtbl



void throwSubSeqFaulty_StringPartJc(StringPartJc_s* thiz, int32 from, int32 to, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("throwSubSeqFaulty_StringPartJc");
  
  { 
     /*J2C: temporary Stringbuffer for String concatenation*/
    StringBuilderJc_s* _tempString2_1=null; 
    
    { THROW(IllegalArgumentException, 
      ( _tempString2_1 = new_StringBuilderJc(-1, _thCxt)
      , setStringConcatBuffer_StringBuilderJc(_tempString2_1)
      , append_z_StringBuilderJc(_tempString2_1, "StringPartBase.subString - faulty;", _thCxt)
      , append_I_StringBuilderJc(_tempString2_1, from, _thCxt)
      , toStringMarkPersist_StringBuilderJc(&(_tempString2_1)->base.object, _thCxt)
      ), 0, 0); };
    activateGC_ObjectJc(&_tempString2_1->base.object, null, _thCxt);
  }
  STACKTRC_LEAVE;
}



/**Returns the lenght of the maximal part from current position. Returns also 0 if no string is valid.*/
int32 lengthMaxPart_StringPartJc(StringPartJc_s* thiz)
{ 
  
  { 
    
    if(thiz->endMax > thiz->begin) 
      return thiz->endMax - thiz->begin;
    else 
      return 0;
  }
}




int32 copyCurrentChars_StringPartJc(StringPartJc_s* thiz, char* dst, int lenDst) {
  char* dst1 = dst;
  int zz = thiz->end - thiz->begin;
  int z1 = zz;
  bool bTerminate;
  if(z1 >= lenDst) {
    z1 = lenDst;             // truncate
    bTerminate = false;
  } else { 
    bTerminate = true;       // appends \0 on end because space given.  
  }
  int ix = thiz->begin;
  while(--z1 >=0) {          // copy char by char, thiz->current may be only able to read by chars.
    *dst1++ = charAt_CharSeqJc(thiz->content, ix++, null);
  }
  if(bTerminate) {
    *dst1 = 0;
  }
  return zz;                //number of chars should be copied, maybe >= lenDst
}




/**Sets the endposition of the part of string to the given chars after start.*/
struct StringPartJc_t* lentoPos_StringPartJc(StringPartJc_s* thiz, int32 len, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lentoPos_StringPartJc");
  
  { 
     /*J2C: temporary Stringbuffer for String concatenation*/
    StringBuilderJc_s* _tempString2_1=null; 
    StringBuilderJc_s* _tempString2_2=null; 
    
    thiz->endLast = thiz->end;
    
    int32  endNew = thiz->begin + len;
    if(endNew < thiz->begin) /***/
    throwIndexOutOfBoundsException_StringPartJc(thiz, 
      ( _tempString2_1 = new_StringBuilderJc(-1, _thCxt)
      , setStringConcatBuffer_StringBuilderJc(_tempString2_1)
      , append_z_StringBuilderJc(_tempString2_1, "lento(int) negative:", _thCxt)
      , append_I_StringBuilderJc(_tempString2_1, (endNew - thiz->begin), _thCxt)
      , toStringMarkPersist_StringBuilderJc(&(_tempString2_1)->base.object, _thCxt)
      ), _thCxt);
    if(endNew > thiz->endMax) /***/
    throwIndexOutOfBoundsException_StringPartJc(thiz, 
      ( _tempString2_2 = new_StringBuilderJc(-1, _thCxt)
      , setStringConcatBuffer_StringBuilderJc(_tempString2_2)
      , append_z_StringBuilderJc(_tempString2_2, "lento(int) after endMax:", _thCxt)
      , append_I_StringBuilderJc(_tempString2_2, (endNew - thiz->endMax), _thCxt)
      , toStringMarkPersist_StringBuilderJc(&(_tempString2_2)->base.object, _thCxt)
      ), _thCxt);
    thiz->end = endNew;
    { STACKTRC_LEAVE;
      activateGC_ObjectJc(&_tempString2_1->base.object, null, _thCxt);
      activateGC_ObjectJc(&_tempString2_2->base.object, null, _thCxt);
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the end position of the part of string to exclusively the char cc.*/
struct StringPartJc_t* lento_c_StringPartJc(StringPartJc_s* thiz, char cc, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lento_c_StringPartJc");
  
  { 
    
    thiz->endLast = thiz->end;
    thiz->end = thiz->begin - 1;
    
    while(++thiz->end < thiz->endLast)
      { 
        
        if(charAt_CharSeqJc(thiz->content/*J1cT2*/, thiz->end, _thCxt) == cc) 
        { 
          
          thiz->bFound = true;
          { STACKTRC_LEAVE;
          return thiz;
        }
        }
      }
    thiz->end = thiz->begin;/*not found*/
    
    thiz->bFound = false;
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the end position of the part of string to exclusively the char cc.*/
struct StringPartJc_t* lento_cMode_StringPartJc(StringPartJc_s* thiz, char cc, int mode) { 
  STACKTRC_ENTRY("lento_cMode_StringPartJc");
  int end1, end9;
  thiz->endLast = thiz->end;
  if(mode & lentoFromEnd_StringPartJc) {
    end1 = thiz->end -1;                       // end1: current end         
    end9 = thiz->endMax;                       // end9: max end
  } else {
    end1 = thiz->begin -1;                     // from begin
    end9 = thiz->end;                          // till current end only (!), usual endMax.  
  }
  while(++end1 < end9) { 
    if(charAt_CharSeqJc(thiz->content/*J1cT2*/, end1, _thCxt) == cc) { 
      thiz->end = (mode & lentoBehind_StringPartJc) ? end1 +1 : end1;
      thiz->bFound = true;
      STACKTRC_RETURN thiz;
    }
  }
  //entry here if not found.
  if( (mode & lentoFromEnd_StringPartJc) ==0) {// not found
    thiz->end = thiz->begin;                   // then set len to 0 if not from end.
  } else {                                     // from end : let thiz->end is unchanged.
  }
  thiz->bFound = false;
  STACKTRC_RETURN thiz;
}


/**Sets the endposition of the part of string to exclusively the given string.*/
struct StringPartJc_t* lento_Cs_StringPartJc(StringPartJc_s* thiz, CharSeqJc ss, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lento_Cs_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return lento_Csi_StringPartJc(thiz, ss, seekNormal_StringPartJc, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the endposition of the part of string to exclusively the given string.*/
struct StringPartJc_t* lento_Csi_StringPartJc(StringPartJc_s* thiz, CharSeqJc ss, int32 mode, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lento_Csi_StringPartJc");
  
  { 
    
    thiz->endLast = thiz->end;
    
    int32  pos = indexOf_CsiiCs_StringFunctionsJc(/*J2C:static method call*/thiz->content, thiz->begin, thiz->end, ss, _thCxt);
    thiz->bFound = (pos >= 0);
    if(pos >= 0) 
    { 
      
      thiz->end = pos;
      if((mode & seekEnd_StringPartJc) != 0) 
      { 
        
        thiz->end += length_CharSeqJc(ss/*J1cT2*/, _thCxt);
      }
    }
    else 
    { 
      
      thiz->end = thiz->begin;
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the endposition of the part of string to the end of the identifier which is beginning on start.*/
struct StringPartJc_t* lentoIdentifier_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lentoIdentifier_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return lentoIdentifier_CsCs_StringPartJc(thiz, null_CharSeqJc /*J2C: mem assignment*/, null_CharSeqJc /*J2C: mem assignment*/, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the endposition of the part of string to the end of the identifier which is beginning on start.*/
struct StringPartJc_t* lentoIdentifier_CsCs_StringPartJc(StringPartJc_s* thiz, CharSeqJc additionalStartChars, CharSeqJc additionalChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lentoIdentifier_CsCs_StringPartJc");
  
  { 
    
    thiz->endLast = thiz->end;
    thiz->end = thiz->begin;
    if(thiz->end >= thiz->endMax) 
    { 
      
      thiz->bFound = false;
    }
    else 
    { /*:TODO use StringFunctions.lenIdentifier*/
      
      
      
      char  cc = charAt_CharSeqJc(thiz->content/*J1cT2*/, thiz->end, _thCxt);
      if(cc == '_' || (cc >= 'A' && cc <= 'Z') || (cc >= 'a' && cc <= 'z') || (additionalStartChars.addr.str != null && indexOf_Csc_StringFunctionsJc(/*J2C:static method call*/additionalStartChars, cc, _thCxt) >= 0)) 
      { 
        
        thiz->end += 1;
        
        while(thiz->end < thiz->endMax && ((cc = /*? assignment*/charAt_CharSeqJc(thiz->content/*J1cT2*/, thiz->end, _thCxt)) == '_' || (cc >= '0' && cc <= '9') || (cc >= 'A' && cc <= 'Z') || (cc >= 'a' && cc <= 'z') || (additionalChars.addr.str!= null && indexOf_Csc_StringFunctionsJc(/*J2C:static method call*/additionalChars, cc, _thCxt) >= 0)))
          { 
            
            thiz->end += 1;
          }
      }
      thiz->bFound = (thiz->end > thiz->begin);
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}



StringPartJc_s* lentoNumber_StringPartJc(StringPartJc_s* thiz, bool bHex, int* dst, StringJc separatorChars) {
  STACKTRC_ENTRY("lentoNumber_StringPartJc");
  thiz->endLast = thiz->end;
  thiz->end = thiz->begin;
  int nr = 0;
  int mult = bHex? 16 : 10;
  while(thiz->end < thiz->endMax){ 
    char cc = charAt_CharSeqJc(thiz->content, thiz->end, _thCxt);
    if(!isNull_StringJc(separatorChars) && indexOf_C_StringJc(separatorChars,cc) >=0) {
      thiz->end +=1;                            //admissible additional character
    }
    else if(cc >='0' && cc <='9') {
      nr = nr * mult + (cc - '0');             // add 0..9
      thiz->end +=1;
    }
    else if(bHex) {
      if( cc >='a' && cc <='f') {
        cc -= 'a';
      }
      else if( cc >='A' && cc <='F') {
        cc -= 'A';
      }
      else {
        break;                                 // non number character, break the loop
      }
      nr = nr * mult + (cc + 10);              //add a..f or A..F
      thiz->end +=1;
    }
    else { 
      break;                                   // non number character, break the loop
    }
  }
  thiz->bFound = (thiz->end > thiz->begin);
  if(dst !=null) { 
    dst[0] = nr;                               //store parsed number, dst should be initialized
  }
  return thiz;
}






/**Sets the len to the first position of any given char, but not if the char is escaped.*/
struct StringPartJc_t* lentoAnyNonEscapedChar_StringPartJc(StringPartJc_s* thiz, CharSeqJc sCharsEnd, int32 maxToTest, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lentoAnyNonEscapedChar_StringPartJc");
  
  { 
    
    if(thiz->bCurrentOk) 
    { 
      
      
      char  cEscape = '\\';
      thiz->endLast = thiz->end;
      
      int32  pos = indexOfAnyChar_Csii_StringPartJc(thiz, sCharsEnd, 0, maxToTest, _thCxt);
      
      while(pos > thiz->begin + 1 && charAt_CharSeqJc(thiz->content/*J1cT2*/, pos - 1, _thCxt) == cEscape)
        { /*:the escape char is before immediately. It means, the end char is not matched.*/
          
          
          pos = indexOfAnyChar_Csii_StringPartJc(thiz, sCharsEnd, pos + 1 - thiz->begin, maxToTest, _thCxt);
        }
      if(pos < 0) 
      { 
        
        thiz->end = thiz->begin;
        thiz->bFound = false;
      }
      else 
      { 
        
        thiz->end = thiz->begin + pos;
        thiz->bFound = true;
      }
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the length of the valid part to the first position of the given String, */
struct StringPartJc_t* lentoNonEscapedString_StringPartJc(StringPartJc_s* thiz, CharSeqJc sEnd, int32 maxToTest, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lentoNonEscapedString_StringPartJc");
  
  { 
    
    if(thiz->bCurrentOk) 
    { 
      
      
      char  cEscape = '\\';
      thiz->endLast = thiz->end;
      
      int32  pos = indexOf_Csii_StringPartJc(thiz, sEnd, 0, maxToTest, _thCxt);
      
      while(pos > thiz->begin + 1 && charAt_CharSeqJc(thiz->content/*J1cT2*/, pos - 1, _thCxt) == cEscape)
        { /*:the escape char is before immediately. It means, the end char is not matched.*/
          
          
          pos = indexOf_Csii_StringPartJc(thiz, sEnd, pos + 1 - thiz->begin, maxToTest, _thCxt);
        }
      if(pos < 0) 
      { 
        
        thiz->end = thiz->begin;
        thiz->bFound = false;
      }
      else 
      { 
        
        thiz->end = thiz->begin + pos;
        thiz->bFound = true;
      }
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the current Part from the current position to exactly one line.*/
struct StringPartJc_t* line_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("line_StringPartJc");
  
  { 
    
    
    int32  posStart = lastIndexOfAnyChar_StringFunctionsJc(/*J2C:static method call*/thiz->content, thiz->begiMin, thiz->begin, z_StringJc("\r\n"), _thCxt);
    if(posStart < 0) 
    { 
      
      posStart = thiz->begiMin;
    }
    
    int32  posEnd = indexOfAnyChar_StringFunctionsJc(/*J2C:static method call*/thiz->content, thiz->begin, thiz->endMax, z_StringJc("\r\n"), _thCxt);
    if(posEnd < 0) 
    { 
      
      posEnd = thiz->endMax;
    }
    thiz->begin = posStart;
    thiz->end = posEnd;
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the current and the maximal part from position 0 to the first end line character.*/
struct StringPartJc_t* firstlineMaxpart_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("firstlineMaxpart_StringPartJc");
  
  { 
    
    thiz->begiMin = thiz->begin = /*? assignment*/0;
    thiz->endMax = thiz->end = /*? assignment*/length_CharSeqJc(thiz->content/*J1cT2*/, _thCxt);
    lentoAnyChar_Cs_StringPartJc(thiz, z_StringJc("\r\n"), _thCxt);
    if(!found_StringPartJc(thiz, _thCxt)) 
    { 
      
      len0end_StringPartJc(thiz, _thCxt);
    }/*last line without end-line character*/
    
    thiz->endMax = thiz->end;
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the current and the maximal part from the current end to the next line end character.*/
struct StringPartJc_t* nextlineMaxpart_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("nextlineMaxpart_StringPartJc");
  
  { 
    
    thiz->begiMin = thiz->begin = /*? assignment*/thiz->endMax;/*char test111 = charAt(0);*/
    
    thiz->endMax = thiz->end = /*? assignment*/length_CharSeqJc(thiz->content/*J1cT2*/, _thCxt);
    if(thiz->begiMin == thiz->endMax) 
    { 
      
      thiz->bFound = false;
    }
    else 
    { 
      
      if(checkCharAt_StringPartJc(thiz, 0, s0_StringJc("\n"), _thCxt)) 
      { 
        
        seekPos_StringPartJc(thiz, 1, _thCxt);
        if(found_StringPartJc(thiz, _thCxt) && checkCharAt_StringPartJc(thiz, 0, s0_StringJc("\r"), _thCxt)) 
        { 
          
          seekPos_StringPartJc(thiz, 1, _thCxt);
        }
      }
      if(checkCharAt_StringPartJc(thiz, 0, s0_StringJc("\r"), _thCxt)) 
      { 
        
        seekPos_StringPartJc(thiz, 1, _thCxt);
        if(found_StringPartJc(thiz, _thCxt) && checkCharAt_StringPartJc(thiz, 0, s0_StringJc("\n"), _thCxt)) 
        { 
          
          seekPos_StringPartJc(thiz, 1, _thCxt);
        }
      }/*refers next line.*/
      
      lentoAnyChar_Cs_StringPartJc(thiz, z_StringJc("\r\n"), _thCxt);
      if(!found_StringPartJc(thiz, _thCxt) && thiz->begin < thiz->endMax) 
      { 
        
        len0end_StringPartJc(thiz, _thCxt);
      }/*last line without end-line character*/
      
      thiz->begiMin = thiz->begin;
      thiz->endMax = thiz->end;
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Displaces the start of the part for some chars to left or to right.*/
struct StringPartJc_t* seek_i_StringPartJc(StringPartJc_s* thiz, int32 nr, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("seek_i_StringPartJc");
  
  { 
     /*J2C: temporary Stringbuffer for String concatenation*/
    StringBuilderJc_s* _tempString2_1=null; 
    StringBuilderJc_s* _tempString2_2=null; 
    
    thiz->beginLast = thiz->begin;
    thiz->begin += nr;
    if(thiz->begin > thiz->end) /***/
    throwIndexOutOfBoundsException_StringPartJc(thiz, 
      ( _tempString2_1 = new_StringBuilderJc(-1, _thCxt)
      , setStringConcatBuffer_StringBuilderJc(_tempString2_1)
      , append_z_StringBuilderJc(_tempString2_1, "seek=", _thCxt)
      , append_I_StringBuilderJc(_tempString2_1, nr, _thCxt)
      , append_z_StringBuilderJc(_tempString2_1, " begin=", _thCxt)
      , append_I_StringBuilderJc(_tempString2_1, (thiz->begin - nr), _thCxt)
      , append_z_StringBuilderJc(_tempString2_1, " end=", _thCxt)
      , append_I_StringBuilderJc(_tempString2_1, thiz->end, _thCxt)
      , toStringMarkPersist_StringBuilderJc(&(_tempString2_1)->base.object, _thCxt)
      ), _thCxt);
    else if(thiz->begin < thiz->begiMin) /***/
    throwIndexOutOfBoundsException_StringPartJc(thiz, 
      ( _tempString2_2 = new_StringBuilderJc(-1, _thCxt)
      , setStringConcatBuffer_StringBuilderJc(_tempString2_2)
      , append_z_StringBuilderJc(_tempString2_2, "seek=", _thCxt)
      , append_I_StringBuilderJc(_tempString2_2, nr, _thCxt)
      , append_z_StringBuilderJc(_tempString2_2, " begin=", _thCxt)
      , append_I_StringBuilderJc(_tempString2_2, (thiz->begin - nr), _thCxt)
      , append_z_StringBuilderJc(_tempString2_2, " begin-min=", _thCxt)
      , append_I_StringBuilderJc(_tempString2_2, thiz->begiMin, _thCxt)
      , toStringMarkPersist_StringBuilderJc(&(_tempString2_2)->base.object, _thCxt)
      ), _thCxt);
    thiz->bFound = true;
    { STACKTRC_LEAVE;
      activateGC_ObjectJc(&_tempString2_1->base.object, null, _thCxt);
      activateGC_ObjectJc(&_tempString2_2->base.object, null, _thCxt);
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the begin of the current part relative to the given number of character. */
struct StringPartJc_t* seekPos_StringPartJc(StringPartJc_s* thiz, int32 nr, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("seekPos_StringPartJc");
  
  { 
    
    
    int32  begin1 = thiz->begin + nr;
    if(begin1 > thiz->end || begin1 < thiz->begiMin) 
    { 
      
      thiz->bFound = false;
    }
    else 
    { 
      
      thiz->begin = begin1;
      thiz->bFound = true;
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the begin of the current part backward from end. */
struct StringPartJc_t* seekPosBack_StringPartJc(StringPartJc_s* thiz, int32 nr, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("seekPosBack_StringPartJc");
  
  { 
    
    
    int32  begin1 = thiz->end - nr;
    if(begin1 > thiz->end || begin1 < thiz->begiMin) 
    { 
      
      thiz->bFound = false;
    }
    else 
    { 
      
      thiz->begin = begin1;
      thiz->bFound = true;
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Displaces the start of the part to the first char it is no whitespace.*/
struct StringPartJc_t* seekNoWhitespace_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("seekNoWhitespace_StringPartJc");
  
  { 
    
    thiz->beginLast = thiz->begin;
    
    while(thiz->begin < thiz->end && indexOf_C_StringJc(zI_StringJc(" \t\r\n\f",5), charAt_CharSeqJc(thiz->content/*J1cT2*/, thiz->begin, _thCxt)) >= 0)
      { 
        
        thiz->begin += 1;
      }
    thiz->bFound = (thiz->begin > thiz->beginLast);
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**skip over comment and whitespaces*/
struct StringPartJc_t* skipWhitespaceAndComment_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("skipWhitespaceAndComment_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return seekNoWhitespaceOrComments_StringPartJc(thiz, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Displaces the begin of the part to the first char it is no whitespace or comment.*/
struct StringPartJc_t* seekNoWhitespaceOrComments_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("seekNoWhitespaceOrComments_StringPartJc");
  
  { 
    
    
    int32  start00 = thiz->begin;
    
    int32  start0;/*no initvalue*/
    do 
      { 
        
        start0 = thiz->begin;
        if((thiz->bitMode & mSkipOverWhitespace_mode_StringPartJc) != 0) 
        { 
          
          seekNoWhitespace_StringPartJc(thiz, _thCxt);
        }
        if((thiz->bitMode & mSkipOverCommentInsideText_mode_StringPartJc) != 0) 
        { 
          
          if(compare_CsiCsii_StringFunctionsJc(/*J2C:static method call*/thiz->content, thiz->begin, thiz->sCommentStart, 0, length_StringJc(thiz->sCommentStart), _thCxt) == 0) 
          { 
            
            seek_Csi_StringPartJc(thiz, thiz->sCommentEnd, seekEnd_StringPartJc, _thCxt);
          }
        }
        if((thiz->bitMode & mSkipOverCommentToEol_mode_StringPartJc) != 0) 
        { 
          
          if(compare_CsiCsii_StringFunctionsJc(/*J2C:static method call*/thiz->content, thiz->begin, thiz->sCommentToEol, 0, length_StringJc(thiz->sCommentToEol), _thCxt) == 0) 
          { 
            
            seek_ci_StringPartJc(thiz, '\n', seekEnd_StringPartJc, _thCxt);
          }
        }
      }while(thiz->begin != start0);/*:TRICKY: if something is done, repeat all conditions.*/
    
    thiz->bFound = (thiz->begin > start00);
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns true, if the last called seek__(), lento__() or skipWhitespaceAndComment()*/
bool found_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("found_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->bFound;
    }
  }
  STACKTRC_LEAVE;
}


/**Displaces the begin of the part to the leftest possible begin.*/
struct StringPartJc_t* seekBegin_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("seekBegin_StringPartJc");
  
  { 
    
    thiz->begin = thiz->beginLast = /*? assignment*/thiz->begiMin;
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Searchs the given String inside the valid part, posits the begin of the part to the begin of the searched string.*/
struct StringPartJc_t* seek_Csi_StringPartJc(StringPartJc_s* thiz, CharSeqJc sSeek, int32 mode, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("seek_Csi_StringPartJc");
  
  { 
    
    thiz->beginLast = thiz->begin;/*if(StringFunctions.startsWith(sSeek, "timestamp:"))*/
    
    dbgstop_emC(/*J2C:static method call*/);
    
    int32  seekArea1;/*no initvalue*/
    
    int32  seekArea9;/*no initvalue*/
    
    int32  posNotFound;/*no initvalue*/
    if((mode & mSeekToLeft__StringPartJc) == mSeekToLeft__StringPartJc) 
    { 
      
      
      int32  posAreaEnd = thiz->begin + length_CharSeqJc(sSeek/*J1cT2*/, _thCxt) - 1;
      if(posAreaEnd > thiz->endMax) posAreaEnd = thiz->endMax;/*but not over the end.*/
      
      seekArea1 = thiz->begiMin;
      seekArea9 = posAreaEnd;/*sSeekArea = content.substring(startMin, posAreaEnd );*/
      
      posNotFound = thiz->begin;/*if not found, the rightest position of area*/
      
    }
    else 
    { 
      
      seekArea1 = thiz->begin;
      seekArea9 = thiz->end;/*sSeekArea = content.substring(begin, end );*/
      
      posNotFound = thiz->end;/*if not found, the rightest position of area*/
      
    }
    
    int32  pos;/*no initvalue*/
    if((mode & mSeekBackward__StringPartJc) == mSeekBackward__StringPartJc) 
    { 
      
      pos = lastIndexOf_CsiiCs_StringFunctionsJc(/*J2C:static method call*/thiz->content, seekArea1, seekArea9, sSeek, _thCxt);/*sSeekArea.lastIndexOf(sSeek);*/
      
    }
    else 
    { 
      
      pos = indexOf_CsiiCs_StringFunctionsJc(/*J2C:static method call*/thiz->content, seekArea1, seekArea9, sSeek, _thCxt);
    }
    if(pos < 0) 
    { 
      
      thiz->begin = posNotFound;
      thiz->bFound = false;
    }
    else 
    { 
      
      thiz->bFound = true;
      thiz->begin = pos;
      if((mode & seekEnd_StringPartJc) == seekEnd_StringPartJc) 
      { 
        
        thiz->begin += length_CharSeqJc(sSeek/*J1cT2*/, _thCxt);
      }
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Seeks back form the current end to the end of the given String starting from the end of the current part.*/
struct StringPartJc_t* seekBackward_StringPartJc(StringPartJc_s* thiz, CharSeqJc sSeek, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("seekBackward_StringPartJc");
  
  { 
    
    
    int32  pos = lastIndexOf_CsiiCs_StringFunctionsJc(/*J2C:static method call*/thiz->content, thiz->begin, thiz->end, sSeek, _thCxt);
    if(pos < 0) thiz->bFound = false;
    else 
    { 
      
      thiz->begin = pos + length_CharSeqJc(sSeek/*J1cT2*/, _thCxt);
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Seeks to one of the characters contained in chars, starting from the begin of the current part.*/
struct StringPartJc_t* seekAnyChar_StringPartJc(StringPartJc_s* thiz, CharSeqJc chars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("seekAnyChar_StringPartJc");
  
  { 
    
    
    int32  pos = indexOfAnyChar_StringFunctionsJc(/*J2C:static method call*/thiz->content, thiz->begin, thiz->end, chars, _thCxt);
    if(pos < 0) thiz->bFound = false;
    else 
    { 
      
      thiz->begin = pos;
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Seeks back from the current end to one of the characters contained in chars, starting from the end of the current part.*/
struct StringPartJc_t* seekBackToAnyChar_StringPartJc(StringPartJc_s* thiz, CharSeqJc chars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("seekBackToAnyChar_StringPartJc");
  
  { 
    
    
    int32  pos = lastIndexOfAnyChar_StringFunctionsJc(/*J2C:static method call*/thiz->content, thiz->begin, thiz->end, chars, _thCxt);
    if(pos < 0) thiz->bFound = false;
    else 
    { 
      
      thiz->begin = pos;
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Searchs the given CharSequence inside the valid part, posits the begin of the part to the begin of the searched string.*/
struct StringPartJc_t* seekAnyString_StringPartJc(StringPartJc_s* thiz, CharSeqJc_Y* strings, int32* nrofFoundString, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("seekAnyString_StringPartJc");
  
  { 
    
    thiz->beginLast = thiz->begin;
    
    int32  pos;/*no initvalue*/
    pos = indexOfAnyString_StringPartJc(thiz, strings, 0, MAX_VALUE_IntegerJc, nrofFoundString, null, _thCxt);
    if(pos < 0) 
    { 
      
      thiz->bFound = false;
      thiz->begin = thiz->end;
    }
    else 
    { 
      
      thiz->bFound = true;
      thiz->begin = thiz->begin + pos;
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Searchs the given character inside the valid part, posits the begin of the part to the begin of the searched char.*/
struct StringPartJc_t* seek_ci_StringPartJc(StringPartJc_s* thiz, char cSeek, int32 mode, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("seek_ci_StringPartJc");
  
  { 
    
    thiz->beginLast = thiz->begin;
    
    int32  seekArea1;/*no initvalue*/
    
    int32  seekArea9;/*no initvalue*/
    
    int32  posNotFound;/*no initvalue*/
    if((mode & mSeekToLeft__StringPartJc) == mSeekToLeft__StringPartJc) 
    { 
      
      
      int32  posAreaEnd = thiz->begin;
      if(posAreaEnd > thiz->endMax) posAreaEnd = thiz->endMax;/*but not over the end.*/
      
      seekArea1 = thiz->begiMin;
      seekArea9 = posAreaEnd;/*sSeekArea = content.substring(startMin, posAreaEnd );*/
      
      posNotFound = thiz->begin;/*if not found, the rightest position of area*/
      
    }
    else 
    { 
      
      seekArea1 = thiz->begin;
      seekArea9 = thiz->end;/*sSeekArea = content.substring(begin, end );*/
      
      posNotFound = thiz->end;/*if not found, the rightest position of area*/
      
    }
    
    int32  pos;/*no initvalue*/
    if((mode & mSeekBackward__StringPartJc) == mSeekBackward__StringPartJc) 
    { 
      
      pos = lastIndexOf_Csiic_StringFunctionsJc(/*J2C:static method call*/thiz->content, seekArea1, seekArea9, cSeek, _thCxt);
    }
    else 
    { 
      
      pos = indexOf_Csiic_StringFunctionsJc(/*J2C:static method call*/thiz->content, seekArea1, seekArea9, cSeek, _thCxt);
    }
    if(pos < 0) 
    { 
      
      thiz->begin = posNotFound;
      thiz->bFound = false;
    }
    else 
    { 
      
      thiz->bFound = true;
      thiz->begin = pos;
      if((mode & seekEnd_StringPartJc) == seekEnd_StringPartJc) 
      { 
        
        thiz->begin += 1;
      }
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Posits the start of the part after all of the chars given in the parameter string.*/
struct StringPartJc_t* seekNoChar_StringPartJc(StringPartJc_s* thiz, CharSeqJc sChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("seekNoChar_StringPartJc");
  
  { 
    
    thiz->beginLast = thiz->begin;
    
    while(thiz->begin < thiz->end && indexOf_Csc_StringFunctionsJc(/*J2C:static method call*/sChars, charAt_CharSeqJc(thiz->content/*J1cT2*/, thiz->begin, _thCxt), _thCxt) >= 0)thiz->begin += 1;
    if(thiz->begin < thiz->end) thiz->bFound = true;
    else thiz->bFound = false;
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Seeks to the next non-empty line.*/
struct StringPartJc_t* seekNextLine_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("seekNextLine_StringPartJc");
  
  { 
    
    thiz->beginLast = thiz->begin;
    
    while(thiz->begin < thiz->end && indexOf_C_StringJc(zI_StringJc("\n\r",2), charAt_CharSeqJc(thiz->content/*J1cT2*/, thiz->begin, _thCxt)) < 0)
      { 
        
        thiz->begin += 1;
      }/*search the first \r or \n*/
      
    
    while(thiz->begin < thiz->end && indexOf_C_StringJc(zI_StringJc("\n\r",2), charAt_CharSeqJc(thiz->content/*J1cT2*/, thiz->begin, _thCxt)) >= 0)
      { 
        
        thiz->begin += 1;
      }/*skip over all \r\n one after another*/
      
    if(thiz->begin < thiz->end) 
    { 
      
      thiz->bFound = true;
    }
    else thiz->bFound = false;
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Searches any char contained in sChars in the current part*/
int32 indexOfAnyChar_Csii_StringPartJc(StringPartJc_s* thiz, CharSeqJc sChars, int32 fromWhere, int32 maxToTest, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOfAnyChar_Csii_StringPartJc");
  
  { 
    
    
    int32  pos = thiz->begin + fromWhere;
    
    int32  max = (thiz->end - pos) < maxToTest ? thiz->end : pos + maxToTest;
    
    int32  found = indexOfAnyChar_StringFunctionsJc(/*J2C:static method call*/thiz->content, pos, max, sChars, _thCxt);
    if(found < 0) { STACKTRC_LEAVE;
      return found;
    }
    else { STACKTRC_LEAVE;
      return found - thiz->begin;
    }/**/
    
  }
  STACKTRC_LEAVE;
}


/**Returns the position of one of the chars in sChars within the part, started inside the part with fromIndex,*/
int32 indexOfAnyChar_Csiiccc_StringPartJc(StringPartJc_s* thiz, CharSeqJc sChars, int32 fromWhere, int32 maxToTest, char transcriptChar, char quotationStartChar, char quotationEndChar, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOfAnyChar_Csiiccc_StringPartJc");
  
  { 
    
    
    int32  pos = thiz->begin + fromWhere;
    
    int32  max = (thiz->end - pos) < maxToTest ? thiz->end : thiz->begin + maxToTest;
    
    bool  bNotFound = true;
    
    while(pos < max && bNotFound)
      { 
        
        
        char  cc = charAt_CharSeqJc(thiz->content/*J1cT2*/, pos, _thCxt);
        if(cc == quotationStartChar && cc != 0) 
        { 
          
          
          int32  endQuotion = indexEndOfQuotation_StringPartJc(thiz, quotationEndChar, transcriptChar, pos - thiz->begin, max - thiz->begin, _thCxt);
          if(endQuotion < 0) 
          { 
            
            pos = max;
          }
          else 
          { 
            
            pos = endQuotion + thiz->begin;
          }
        }
        else if(cc == transcriptChar && cc != 0 && pos < (max - 1)) 
        { 
          
          pos += 2;
        }
        else 
        { 
          
          if(indexOf_Csc_StringFunctionsJc(/*J2C:static method call*/sChars, cc, _thCxt) >= 0) 
          { 
            
            bNotFound = false;
          }
          else 
          { 
            
            pos += 1;
          }
        }
      }
    if(bNotFound) 
    { 
      
      if(indexOf_Csc_StringFunctionsJc(/*J2C:static method call*/sChars, cEndOfText_StringFunctionsJc, _thCxt) >= 0) { STACKTRC_LEAVE;
        return pos - thiz->begin;
      }/* it is found because cEndOfText is searched too.*/
      
      else { STACKTRC_LEAVE;
        return -1;
      }
    }
    else { STACKTRC_LEAVE;
      return (pos - thiz->begin);
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the last position of one of the chars in sChars */
int32 lastIndexOfAnyChar_StringPartJc(StringPartJc_s* thiz, CharSeqJc sChars, int32 fromWhere, int32 maxToTest, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lastIndexOfAnyChar_StringPartJc");
  
  { 
    
    
    int32  pos = (thiz->end - thiz->begin) < maxToTest ? thiz->end - 1 : thiz->begin + maxToTest - 1;
    
    int32  min = thiz->begin + fromWhere;
    
    while(pos >= min && indexOf_Csc_StringFunctionsJc(/*J2C:static method call*/sChars, charAt_CharSeqJc(thiz->content/*J1cT2*/, pos, _thCxt), _thCxt) < 0)
      { 
        
        pos -= 1;
      }
    
    int32  index = pos >= min ? pos - thiz->begin : -1;
    { STACKTRC_LEAVE;
      return index;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the position of one of the chars in sChars within the part, started inside the part with fromIndex,*/
int32 indexOfAnyString_StringPartJc(StringPartJc_s* thiz, CharSeqJc_Y* listStrings, int32 fromWhere, int32 maxToTest, int32* nrofFoundString, StringJc* foundString, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOfAnyString_StringPartJc");
  
  { 
    
    ASSERT(/*J2C:static method call*/fromWhere >= 0);
    
    int32  start = thiz->begin + fromWhere;
    
    int32  max = (thiz->end - start) < maxToTest ? thiz->end : start + maxToTest;
    
    int32  pos = indexOfAnyString_StringFunctionsJc(/*J2C:static method call*/thiz->content, start, max, listStrings, nrofFoundString, foundString, _thCxt);
    if(pos >= 0) 
    { 
      
      pos -= thiz->begin;/*the position counts in the current part, starting and begin.*/
      
      ASSERT(/*J2C:static method call*/pos >= 0);/*searched from begin + fromWhere*/
      
    }
    { STACKTRC_LEAVE;
      return pos;
    }
  }
  STACKTRC_LEAVE;
}


/**Searches any char contained in sChars in the current part*/
int32 indexOfAnyCharOutsideQuotion_StringPartJc(StringPartJc_s* thiz, CharSeqJc sChars, int32 fromWhere, int32 maxToTest, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOfAnyCharOutsideQuotion_StringPartJc");
  
  { 
    
    
    int32  pos = thiz->begin + fromWhere;
    
    int32  max = (thiz->end - pos) < maxToTest ? thiz->end : thiz->begin + maxToTest;
    
    bool  bNotFound = true;
    
    while(pos < max && bNotFound)
      { 
        
        
        char  cc = charAt_CharSeqJc(thiz->content/*J1cT2*/, pos, _thCxt);
        if(cc == '\"') 
        { 
          
          
          int32  endQuotion = indexEndOfQuotion_StringPartJc(thiz, '\"', pos - thiz->begin, max - thiz->begin, _thCxt);
          if(endQuotion < 0) 
          { 
            
            pos = max;
          }
          else 
          { 
            
            pos = endQuotion + thiz->begin;
          }
        }
        else 
        { 
          
          if(indexOf_Csc_StringFunctionsJc(/*J2C:static method call*/sChars, cc, _thCxt) >= 0) 
          { 
            
            bNotFound = false;
          }
          else 
          { 
            
            pos += 1;
          }
        }
      }
    { STACKTRC_LEAVE;
      return (bNotFound) ? -1 : (pos - thiz->begin);
    }
  }
  STACKTRC_LEAVE;
}


/**Searches the end of a quoted string. In Generally, a backslash skips over the next char*/
int32 indexEndOfQuotion_StringPartJc(StringPartJc_s* thiz, char cEndQuotion, int32 fromWhere, int32 maxToTest, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexEndOfQuotion_StringPartJc");
  
  { 
    
    
    int32  pos = thiz->begin + fromWhere + 1;
    
    int32  max = (thiz->end - pos) < maxToTest ? thiz->end : pos + maxToTest;
    
    bool  bNotFound = true;
    
    while(pos < max && bNotFound)
      { 
        
        
        char  cc = charAt_CharSeqJc(thiz->content/*J1cT2*/, pos++, _thCxt);
        if(cc == '\\' && (pos + 1) < max) 
        { 
          
          pos += 1;/*on \ overread the next char, test char after them!*/
          
        }
        else if(cc == cEndQuotion) 
        { 
          
          bNotFound = false;
        }
      }
    { STACKTRC_LEAVE;
      return (bNotFound ? -1 : (pos - thiz->begin));
    }
  }
  STACKTRC_LEAVE;
}


/**Searches the end of a quoted string. In Generally, a backslash skips over the next char*/
int32 indexEndOfQuotation_StringPartJc(StringPartJc_s* thiz, char cEndQuotion, char transcriptChar, int32 fromWhere, int32 maxToTest, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexEndOfQuotation_StringPartJc");
  
  { 
    
    
    int32  pos = thiz->begin + fromWhere + 1;
    
    int32  max = (thiz->end - pos) < maxToTest ? thiz->end : pos + maxToTest;
    
    bool  bNotFound = true;
    
    while(pos < max && bNotFound)
      { 
        
        
        char  cc = charAt_CharSeqJc(thiz->content/*J1cT2*/, pos++, _thCxt);
        if(cc == transcriptChar && cc != 0 && (pos + 1) < max) 
        { 
          
          pos += 1;/*on \ overread the next char, test char after them!*/
          
        }
        else if(cc == cEndQuotion) 
        { 
          
          bNotFound = false;
        }
      }
    { STACKTRC_LEAVE;
      return (bNotFound ? -1 : (pos - thiz->begin));
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the position of one of the chars in sChars within the part,*/
int32 indexOfAnyChar_Cs_StringPartJc(StringPartJc_s* thiz, CharSeqJc sChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOfAnyChar_Cs_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return indexOfAnyChar_Csii_StringPartJc(thiz, sChars, 0, MAX_VALUE_IntegerJc, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the position of the first char other than the chars in sChars within the part, started inside the part with fromIndex,*/
int32 indexOfNoChar_Csi_StringPartJc(StringPartJc_s* thiz, CharSeqJc sChars, int32 fromWhere, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOfNoChar_Csi_StringPartJc");
  
  { 
    
    
    int32  pos = thiz->begin + fromWhere;
    
    while(pos < thiz->end && indexOf_Csc_StringFunctionsJc(/*J2C:static method call*/sChars, charAt_CharSeqJc(thiz->content/*J1cT2*/, pos, _thCxt), _thCxt) >= 0)pos += 1;
    { STACKTRC_LEAVE;
      return (pos >= thiz->end) ? -1 : (pos - thiz->begin);
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the position of the first char other than the chars in sChars within the part,*/
int32 indexOfNoChar_Cs_StringPartJc(StringPartJc_s* thiz, CharSeqJc sChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOfNoChar_Cs_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return indexOfNoChar_Csi_StringPartJc(thiz, sChars, 0, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the length of the current part to any char content in sChars (terminate chars). */
struct StringPartJc_t* lentoAnyChar_Csi_StringPartJc(StringPartJc_s* thiz, CharSeqJc sChars, int32 maxToTest, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lentoAnyChar_Csi_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return lentoAnyChar_Csii_StringPartJc(thiz, sChars, maxToTest, seekNormal_StringPartJc, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the length of the current part to any char content in sChars (terminate chars). */
struct StringPartJc_t* lentoAnyChar_Csii_StringPartJc(StringPartJc_s* thiz, CharSeqJc sChars, int32 maxToTest, int32 mode, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lentoAnyChar_Csii_StringPartJc");
  
  { 
    
    thiz->endLast = thiz->end;
    
    int32  pos;/*no initvalue*/
    if((mode & mSeekBackward__StringPartJc) != 0) 
    { 
      
      pos = lastIndexOfAnyChar_StringPartJc(thiz, sChars, 0, maxToTest, _thCxt);
    }
    else 
    { 
      
      pos = indexOfAnyChar_Csii_StringPartJc(thiz, sChars, 0, maxToTest, _thCxt);
    }
    if(pos < 0) 
    { 
      
      thiz->end = thiz->begin;
      thiz->bFound = false;
    }
    else 
    { 
      
      thiz->end = thiz->begin + pos;
      thiz->bFound = true;
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the length of the current part to any terminate string given in sString. */
struct StringPartJc_t* lentoAnyString_CsYi_StringPartJc(StringPartJc_s* thiz, CharSeqJc_Y* strings, int32 maxToTest, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lentoAnyString_CsYi_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return lentoAnyString_CsYii_StringPartJc(thiz, strings, maxToTest, seekNormal_StringPartJc, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the length of the current part to any terminate string given in sString. */
struct StringPartJc_t* lentoAnyString_CsYii_StringPartJc(StringPartJc_s* thiz, CharSeqJc_Y* strings, int32 maxToTest, int32 mode, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lentoAnyString_CsYii_StringPartJc");
  
  { 
    
    thiz->endLast = thiz->end;
    
    StringJc foundString[1] ; foundString; /*J2C:modeAccess=Q*/
    
    int32  pos = indexOfAnyString_StringPartJc(thiz, strings, 0, maxToTest, null, &foundString[0], _thCxt);
    if(pos < 0) 
    { 
      
      thiz->end = thiz->begin;
      thiz->bFound = false;
    }
    else 
    { 
      
      if((mode & seekEnd_StringPartJc) != 0) 
      { 
        
        pos += length_StringJc(foundString[0]);
      }
      thiz->end = thiz->begin + pos;
      thiz->bFound = true;
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the length of the current part to any terminate string given in sString. */
void lentoAnyStringWithIndent_StringPartJc(StringPartJc_s* thiz, CharSeqJc_Y* strings, CharSeqJc sIndentChars, int32 maxToTest, struct StringBuilderJc_t* buffer, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lentoAnyStringWithIndent_StringPartJc");
  
  { 
    
    ASSERT(/*J2C:static method call*/thiz->end <= length_CharSeqJc(thiz->content/*J1cT2*/, _thCxt));
    thiz->endLast = thiz->end;/*String sRet; sRet = "";*/
    
    setLength_StringBuilderJc(buffer, 0, _thCxt);
    
    int32  indentColumn = getCurrentColumn_StringPartJc(thiz, _thCxt);
    
    int32  startLine = thiz->begin;
    
    bool  bAlsoWhiteSpaces = (charAt_CharSeqJc(sIndentChars/*J1cT2*/, length_CharSeqJc(sIndentChars/*J1cT2*/, _thCxt) - 1, _thCxt) == ' ');
    
    int32  pos = indexOfAnyString_StringPartJc(thiz, strings, 0, maxToTest, null, null, _thCxt);
    if(pos < 0) 
    { 
      
      thiz->end = thiz->begin;
      thiz->bFound = false;
    }
    else 
    { 
      
      thiz->bFound = true;
      thiz->end = thiz->begin + pos;
      
      bool  bFinish = false;
      
      while(!bFinish)
        { 
          
          pos = indexOf_Csci_StringFunctionsJc(/*J2C:static method call*/thiz->content, '\n', startLine, _thCxt);
          if(pos < 0) pos = thiz->end;
          if(pos > thiz->end) 
          { /*:next newline after terminated string, that is the last line.*/
            
            
            pos = thiz->end;
            bFinish = true;
          }
          else 
          { 
            
            pos += 1;
          }/* '\n' including*/
          /*append the line to output string:*/
          
          append_c_StringBuilderJc(buffer, subSequence_CharSeqJc(thiz->content/*J1cT2*/, startLine, pos, _thCxt), _thCxt);
          if(!bFinish) 
          { /*:skip over indent.*/
            
            
            startLine = pos;
            
            int32  posIndent = startLine + indentColumn;
            if(posIndent > thiz->end) posIndent = thiz->end;
            
            while(startLine < posIndent && indexOf_Csc_StringFunctionsJc(/*J2C:static method call*/sIndentChars, charAt_CharSeqJc(thiz->content/*J1cT2*/, startLine, _thCxt), _thCxt) >= 0)
              { 
                
                startLine += 1;
              }
            if(bAlsoWhiteSpaces) 
            { 
              
              
              while(indexOf_C_StringJc(zI_StringJc(" \t",2), charAt_CharSeqJc(thiz->content/*J1cT2*/, startLine, _thCxt)) >= 0)
                { 
                  
                  startLine += 1;
                }
            }
          }
        }
    }
    { STACKTRC_LEAVE;
      return;
    }/*buffer.toString();*/
    
  }
  STACKTRC_LEAVE;
}


/**Sets the length of the current part to any char content in sChars (terminate chars),*/
struct StringPartJc_t* lentoAnyCharOutsideQuotion_StringPartJc(StringPartJc_s* thiz, CharSeqJc sChars, int32 maxToTest, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lentoAnyCharOutsideQuotion_StringPartJc");
  
  { 
    
    thiz->endLast = thiz->end;
    
    int32  pos = indexOfAnyCharOutsideQuotion_StringPartJc(thiz, sChars, 0, maxToTest, _thCxt);
    if(pos < 0) 
    { 
      
      thiz->end = thiz->begin;
      thiz->bFound = false;
    }
    else 
    { 
      
      thiz->end = thiz->begin + pos;
      thiz->bFound = true;
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the length of the current part to the end of the quotion. It is not tested here,*/
struct StringPartJc_t* lentoQuotionEnd_StringPartJc(StringPartJc_s* thiz, char sEndQuotion, int32 maxToTest, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lentoQuotionEnd_StringPartJc");
  
  { 
    
    thiz->endLast = thiz->end;
    
    int32  pos = indexEndOfQuotion_StringPartJc(thiz, sEndQuotion, 0, maxToTest, _thCxt);
    if(pos < 0) 
    { 
      
      thiz->end = thiz->begin;
      thiz->bFound = false;
    }
    else 
    { 
      
      thiz->end = thiz->begin + pos;
      thiz->bFound = true;
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the length of the current part to the end of the current line.*/
struct StringPartJc_t* lentoLineEnd_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lentoLineEnd_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return lentoAnyChar_Cs_StringPartJc(thiz, z_StringJc("\n\r\f"), _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Increments the begin of the current part over maybe found whitespaces*/
struct StringPartJc_t* trimWhiteSpaces_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("trimWhiteSpaces_StringPartJc");
  
  { 
    
    seekNoWhitespace_StringPartJc(thiz, _thCxt);
    lenBacktoNoChar_StringPartJc(thiz, z_StringJc(" \t\r\n\f"), _thCxt);
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the length of the current part to any char content in sChars (terminate chars). */
struct StringPartJc_t* lentoAnyChar_Cs_StringPartJc(StringPartJc_s* thiz, CharSeqJc sChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lentoAnyChar_Cs_StringPartJc");
  
  { 
    
    lentoAnyChar_Csi_StringPartJc(thiz, sChars, MAX_VALUE_IntegerJc, _thCxt);
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the length to the end of the maximal part if the length is 0. This method could be called at example*/
struct StringPartJc_t* len0end_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("len0end_StringPartJc");
  
  { 
    
    if(thiz->end <= thiz->begin) thiz->end = thiz->endMax;
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the length to the end of the maximal part.*/
struct StringPartJc_t* setLengthMax_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setLengthMax_StringPartJc");
  
  { 
    
    thiz->end = thiz->endMax;
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Posits the end of the part before all of the chars given in the parameter string.*/
struct StringPartJc_t* lenBacktoNoChar_StringPartJc(StringPartJc_s* thiz, CharSeqJc sChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lenBacktoNoChar_StringPartJc");
  
  { 
    
    thiz->endLast = thiz->end;
    
    while(thiz->end > thiz->begin && indexOf_Csc_StringFunctionsJc(/*J2C:static method call*/sChars, charAt_CharSeqJc(thiz->content/*J1cT2*/, thiz->end - 1, _thCxt), _thCxt) >= 0)
      { 
        
        thiz->end = thiz->end - 1;
      }
    if(thiz->end <= thiz->begin) 
    { 
      
      thiz->end = thiz->begin;
      thiz->bFound = false;/*all chars skipped to left.*/
      
    }
    else thiz->bFound = true;
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Trims all leading and trailing whitespaces within the part.*/
struct StringPartJc_t* trim_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("trim_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return 
      ( seekNoChar_StringPartJc(thiz, z_StringJc(" \t\n\r"), _thCxt)
      , lenBacktoNoChar_StringPartJc(thiz, z_StringJc(" \t\n\r"), _thCxt)
      );
    }/*end position decreased*/
    
  }
  STACKTRC_LEAVE;
}


/**Trims a java- or C-style line-comment from end of part and all leading and trailing whitespaces.*/
struct StringPartJc_t* trimComment_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("trimComment_StringPartJc");
  
  { 
    
    thiz->beginLast = thiz->begin;
    thiz->endLast = thiz->end;
    
    int32  posComment = indexOf_Cs_StringPartJc(thiz, z_StringJc("//"), _thCxt);
    if(posComment >= 0) thiz->end = thiz->begin + posComment;
    thiz->bFound = (thiz->begin > thiz->beginLast);
    { STACKTRC_LEAVE;
      return trim_StringPartJc(thiz, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

#ifdef DEF_ClassJc_Vtbl
int32 compareTo_StringPartJc(StringPartJc_s* thiz, CharSeqJc str2, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("compareTo_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return compare_CsiCsii_StringFunctionsJc(/*J2C:static method call*/fromObjectJc_CharSeqJc(&(* (thiz)).base.object), 0, str2, 0, MAX_VALUE_IntegerJc, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}
#endif //#ifdef DEF_ClassJc_Vtbl


/**Returns the position of the char within the part,*/
int32 indexOf_c_StringPartJc(StringPartJc_s* thiz, char ch, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOf_c_StringPartJc");
  
  { 
    
    
    int32  pos = indexOf_Csiic_StringFunctionsJc(/*J2C:static method call*/thiz->content, thiz->begin, thiz->end, ch, _thCxt);
    
    ;
    if(pos < 0) { STACKTRC_LEAVE;
      return -1;
    }
    else { STACKTRC_LEAVE;
      return pos - thiz->begin;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the position of the char within the part, started inside the part with fromIndex,*/
int32 indexOf_ci_StringPartJc(StringPartJc_s* thiz, char ch, int32 fromIndex, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOf_ci_StringPartJc");
  
  { 
    
    if(fromIndex >= (thiz->end - thiz->begin) || fromIndex < 0) { STACKTRC_LEAVE;
      return -1;
    }
    else 
    { 
      
      
      int32  pos = indexOf_Csiic_StringFunctionsJc(/*J2C:static method call*/thiz->content, thiz->begin + fromIndex, thiz->end, ch, _thCxt);
      
      ;
      if(pos < 0) { STACKTRC_LEAVE;
        return -1;
      }
      else { STACKTRC_LEAVE;
        return pos - thiz->begin + fromIndex;
      }
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the position of the string within the part. Returns -1 if the string is not found in the part.*/
int32 indexOf_Cs_StringPartJc(StringPartJc_s* thiz, CharSeqJc sCmp, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOf_Cs_StringPartJc");
  
  { 
    
    
    int32  pos = indexOf_CsiiCs_StringFunctionsJc(/*J2C:static method call*/thiz->content, thiz->begin, thiz->end, sCmp, _thCxt);
    if(pos < 0) { STACKTRC_LEAVE;
      return -1;
    }
    else { STACKTRC_LEAVE;
      return pos - thiz->begin;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the position of the string within the part. Returns -1 if the string is not found in the part.*/
int32 XXXindexOf_StringPartJc(StringPartJc_s* thiz, CharSeqJc sCmp, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("XXXindexOf_StringPartJc");
  
  { 
    
    
    int32  pos = indexOf_CsiiCs_StringFunctionsJc(/*J2C:static method call*/thiz->content, thiz->begin, thiz->end, sCmp, _thCxt);
    if(pos < 0) { STACKTRC_LEAVE;
      return -1;
    }
    else { STACKTRC_LEAVE;
      return pos - thiz->begin;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the position of the string within the part. Returns -1 if the string is not found in the part.*/
int32 indexOf_Csii_StringPartJc(StringPartJc_s* thiz, CharSeqJc sCmp, int32 fromIndex, int32 maxToTest, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOf_Csii_StringPartJc");
  
  { 
    
    
    int32  max = (thiz->end - thiz->begin) < maxToTest ? thiz->end : thiz->begin + maxToTest;
    if(fromIndex >= (max - thiz->begin) || fromIndex < 0) { STACKTRC_LEAVE;
      return -1;
    }
    else 
    { 
      
      
      int32  pos = indexOf_CsiiCs_StringFunctionsJc(/*J2C:static method call*/thiz->content, thiz->begin + fromIndex, max, sCmp, _thCxt);
      if(pos < 0) { STACKTRC_LEAVE;
        return -1;
      }
      else { STACKTRC_LEAVE;
        return pos - thiz->begin + fromIndex;
      }
    }
  }
  STACKTRC_LEAVE;
}


/**Compares the Part of string with the given string*/
bool equals_Cs_StringPartJc(StringPartJc_s* thiz, CharSeqJc sCmp, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("equals_Cs_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return equals_CsiiCs_StringFunctionsJc(/*J2C:static method call*/thiz->content, thiz->begin, thiz->end, sCmp, _thCxt);
    }/*content.substring(start, end).equals(sCmp);*/
    
  }
  STACKTRC_LEAVE;
}


/**compares the Part of string with the given string.*/
bool startsWith_StringPartJc(StringPartJc_s* thiz, CharSeqJc sCmp, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("startsWith_StringPartJc");
  
  { 
    
    
    int32  pos_cEndOfText = indexOf_Csci_StringFunctionsJc(/*J2C:static method call*/sCmp, cEndOfText_StringFunctionsJc, 0, _thCxt);
    if(pos_cEndOfText >= 0) 
    { 
      
      if(pos_cEndOfText == 0) 
      { 
        
        { STACKTRC_LEAVE;
          return thiz->begin == thiz->end;
        }
      }
      else 
      { 
        
        { STACKTRC_LEAVE;
          return equals_CsiiCs_StringFunctionsJc(/*J2C:static method call*/thiz->content, thiz->begin, thiz->end, sCmp, _thCxt);
        }/*content.substring(start, end).equals(sCmp);*/
        
      }
    }
    else 
    { 
      
      { STACKTRC_LEAVE;
        return startsWith_CsiiCs_StringFunctionsJc(/*J2C:static method call*/thiz->content, thiz->begin, thiz->end, sCmp, _thCxt);
      }/*content.substring(start, end).startsWith(sCmp);*/
      
    }
  }
  STACKTRC_LEAVE;
}


/**Gets the current position, useable for rewind. This method is overwritten*/
int32 getCurrentPosition_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getCurrentPosition_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->begin;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the current position at a fix position inside the maxPart.*/
void setCurrentPosition_StringPartJc(StringPartJc_s* thiz, int32 pos, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setCurrentPosition_StringPartJc");
  
  { 
    
    thiz->begin = (int32 /*J2C_cast*/)pos;
  }
  STACKTRC_LEAVE;
}

#ifdef DEF_ThreadContext_HEAP_emC

/**Gets a substring inside the maximal part*/
struct Part_StringPartJc_t* substring_StringPartJc(StringPartJc_s* thiz, int32 pos, int32 posendP, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("substring_StringPartJc");
  
  { 
    
    
    int32  posend;/*no initvalue*/
    if(posendP <= 0) 
    { 
      
      posend = thiz->endMax - posendP;/*if posendP is fault, an exception is thrown.*/
      
    }
    else 
    { 
      
      posend = posendP;
    }
    
    struct Part_StringPartJc_t*  ret = ctorO_Part_StringPartJc(thiz, allocInThreadCxt_ObjectJc(sizeof(Part_StringPartJc_s), "StringPart.subString", _thCxt), pos + thiz->begiMin, posend, _thCxt);
    { STACKTRC_LEAVE;
      return ret;
    }
  }
  STACKTRC_LEAVE;
}
#endif  //DEF_ThreadContext_HEAP_emC


#ifdef DEF_ClassJc_Vtbl
/**Gets the next chars from current Position.*/
CharSeqJc getCurrent_StringPartJc(StringPartJc_s* thiz, int32 nChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getCurrent_StringPartJc");
  
  { 
    ObjectJc *newObj2_1=null; /*J2C: temporary Objects for new operations
    */
    
    int32  nChars1 = (thiz->endMax - thiz->begin) < nChars ? thiz->endMax - thiz->begin : nChars;
    if(nChars1 == 0) { STACKTRC_LEAVE;
      return z_StringJc("");
    }
    else { STACKTRC_LEAVE;
      activateGC_ObjectJc(newObj2_1, (ctorO_Part_StringPartJc(thiz, (newObj2_1 = alloc_ObjectJc(sizeof_Part_StringPartJc_s, 0, _thCxt)), thiz->begin, thiz->begin + nChars1, _thCxt)), _thCxt);
      return fromObjectJc_CharSeqJc(&(* ((ctorO_Part_StringPartJc(thiz, (newObj2_1 = alloc_ObjectJc(sizeof_Part_StringPartJc_s, 0, _thCxt)), thiz->begin, thiz->begin + nChars1, _thCxt)))).base.object);
    }
  }
  STACKTRC_LEAVE;
}
#endif //#ifdef DEF_ClassJc_Vtbl


/**Gets the next char at current Position.*/
char getCurrentChar_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getCurrentChar_StringPartJc");
  
  { 
    
    if(thiz->begin < thiz->endMax) 
    { 
      
      { STACKTRC_LEAVE;
        return charAt_CharSeqJc(thiz->content/*J1cT2*/, thiz->begin, _thCxt);
      }
    }
    else { STACKTRC_LEAVE;
      return '\0';
    }
  }
  STACKTRC_LEAVE;
}


/**Gets the next char at current Position.*/
char getCurrentEndChar_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getCurrentChar_StringPartJc");
  
  { 
    
    if(thiz->end < thiz->endMax) 
    { 
      
      { STACKTRC_LEAVE;
        return charAt_CharSeqJc(thiz->content/*J1cT2*/, thiz->end, _thCxt);
      }
    }
    else { STACKTRC_LEAVE;
      return '\0';
    }
  }
  STACKTRC_LEAVE;
}


/**Get the Line number and the column of the begin position. */
int32 getLineAndColumn_StringPartJc_F(StringPartJc_s* thiz, int32_Y* column, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getLineAndColumn_StringPartJc_F");
  
  { 
    
    { STACKTRC_LEAVE;
      return 0;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
#ifdef DEF_ClassJc_Vtbl
int32 getLineAndColumn_StringPartJc(StringPartJc_s* thiz, int32_Y* column, ThCxt* _thCxt)
{ Vtbl_StringPartJc const* mtbl = (Vtbl_StringPartJc const*)getVtbl_ObjectJc(&thiz->base.object, sign_Vtbl_StringPartJc);
  return mtbl->getLineAndColumn(thiz, column, _thCxt);
}
#endif //#ifdef DEF_ClassJc_Vtbl


/**Gets the current position in line (column of the text).*/
int32 getCurrentColumn_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getCurrentColumn_StringPartJc");
  
  { /*:if((bitMode & mGetColumn_mode)==0){ return -1; }*/
    /*:else {*/
    
    
    
    int32  pos = lastIndexOf_Csiic_StringFunctionsJc(/*J2C:static method call*/thiz->content, 0, thiz->begin, '\n', _thCxt);
    if(pos < 0) { STACKTRC_LEAVE;
      return thiz->begin;
    }/*first line, no \n before*/
    
    else { STACKTRC_LEAVE;
      return thiz->begin - pos - 1;
    }/*}*/
    
  }
  STACKTRC_LEAVE;
}


/**This method may be overridden to return the file which is used to build this Stringpart.*/
StringJc getInputfile_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getInputfile_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->sFile;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the actual part of the string.*/
struct Part_StringPartJc_t* getCurrentPart_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getCurrentPart_StringPartJc");
  
  { 
    
    
    struct Part_StringPartJc_t*  ret_1;/*no initvalue*/
    #ifdef DEF_ThreadContext_HEAP_emC
      if(thiz->end > thiz->begin) ret_1 = ctorO_Part_StringPartJc(thiz, allocInThreadCxt_ObjectJc(sizeof(Part_StringPartJc_s), null, _thCxt), thiz->begin, thiz->end, _thCxt);
      else ret_1 = ctorO_Part_StringPartJc(thiz, allocInThreadCxt_ObjectJc(sizeof(Part_StringPartJc_s), null, _thCxt), thiz->begin, thiz->begin, _thCxt);
    #else
      THROW_s0(IllegalArgumentException, "not possible without Heap in Thread", 0,0);
      ret_1 = null;
    #endif
    STACKTRC_RETURN ret_1;
  }
  STACKTRC_LEAVE;
}




/**Sets the actual part of the string.
* 
*/
void setCurrentPart_StringPartJc  ( StringPartJc_s* thiz, struct Part_StringPartJc_t* dst, ThCxt* _thCxt)
{ if(thiz->end > thiz->begin) setPart_Part_StringPartJc(dst, thiz->begin, thiz->end, _thCxt);
  else                        setPart_Part_StringPartJc(dst, thiz->begin, thiz->begin, _thCxt);
}





#if defined(DEF_ClassJc_Vtbl) && defined(DEF_ThreadContext_HEAP_emC)
/**Returns the last part of the string before any seek or scan operation.*/
CharSeqJc getLastPart_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getLastPart_StringPartJc");
  
  { 
    
    if(thiz->begin > thiz->beginLast) 
    { 
      
      
      struct Part_StringPartJc_t*  ret = ctorO_Part_StringPartJc(thiz, allocInThreadCxt_ObjectJc(sizeof(Part_StringPartJc_s), "StringPart.getLastPart", _thCxt), thiz->beginLast, thiz->begin, _thCxt);
      { STACKTRC_LEAVE;
        return fromObjectJc_CharSeqJc(&(* (ret)).base.object);
      }
    }
    else { STACKTRC_LEAVE;
      return z_StringJc("");
    }
  }
  STACKTRC_LEAVE;
}
#endif //#ifdef DEF_ClassJc_Vtbl


#if defined(DEF_ClassJc_Vtbl) && defined(DEF_ThreadContext_HEAP_emC) 
/**Returns the actual part of the string.*/
CharSeqJc getCurrentPart_i_StringPartJc(StringPartJc_s* thiz, int32 maxLength, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getCurrentPart_i_StringPartJc");
  
  { 
    
    
    int32  max = (thiz->end - thiz->begin) < maxLength ? thiz->end : thiz->begin + maxLength;
    if(thiz->end > thiz->begin) 
    { 
      
      
      struct Part_StringPartJc_t*  ret = ctorO_Part_StringPartJc(thiz, allocInThreadCxt_ObjectJc(sizeof(Part_StringPartJc_s), "StringPart.getCurrentPart", _thCxt), thiz->begin, max, _thCxt);
      { STACKTRC_LEAVE;
        return fromObjectJc_CharSeqJc(&(* (ret)).base.object);
      }
    }
    else { STACKTRC_LEAVE;
      return z_StringJc("");
    }
  }
  STACKTRC_LEAVE;
}
#endif //#ifdef DEF_ClassJc_Vtbl

#ifdef DEF_ThreadContext_HEAP_emC

/**Retrurn the part from start to end independent of the current positions. */
struct Part_StringPartJc_t* getPart_StringPartJc(StringPartJc_s* thiz, int32 fromPos, int32 nrofChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getPart_StringPartJc");
  
  { 
    
    
    int32  nChars1 = (thiz->endMax - fromPos) < nrofChars ? thiz->endMax - fromPos : nrofChars;
    
    struct Part_StringPartJc_t*  ret = ctorO_Part_StringPartJc(thiz, allocInThreadCxt_ObjectJc(sizeof(Part_StringPartJc_s), "StringPart.Part.getPart", _thCxt), fromPos, fromPos + nChars1, _thCxt);
    { STACKTRC_LEAVE;
      return ret;
    }
  }
  STACKTRC_LEAVE;
}
#endif
char absCharAt_StringPartJc(StringPartJc_s const* thiz, int32 index, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("absCharAt_StringPartJc");
  
  { 
    
    
    int32  pos = index;
    if(pos >= 0 && pos < thiz->endMax) { STACKTRC_LEAVE;
      return charAt_CharSeqJc(thiz->content/*J1cT2*/, pos, _thCxt);
    }
    else 
    { 
      
      throwIllegalArgumentException_StringPartJc(/*J2C:static method call*/s0_StringJc("StringPartBase.charAt - faulty; "), index, _thCxt);
      { STACKTRC_LEAVE;
        return ((char)(0));
      }
    }
  }
  STACKTRC_LEAVE;
}


/**Returns a String from absolute range.*/
StringJc absSubString_StringPartJc(StringPartJc_s* thiz, int32 from, int32 to, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("absSubString_StringPartJc");
  
  { 
    
    
    int32  pos = from;
    
    int32  len = to - from;
    
    int32  end1 = pos + len;
    if(thiz->content.addr.str == null) 
    { 
      
      { STACKTRC_LEAVE;
        return s0_StringJc(" ??null?? ");
      }
    }
    if(pos >= 0 && end1 <= thiz->endMax) 
    { /*:@Java4C.ReturnNew  */
      
      
      
      CharSeqJc cs1 ; cs1 = subSequence_CharSeqJc(thiz->content/*J1cT2*/, pos, pos + len, _thCxt);
      { STACKTRC_LEAVE;
        return toString_CharSeqJc(cs1/*J1cT2*/);
      }
    }
    else 
    { 
      
      throwIllegalArgumentException_StringPartJc(/*J2C:static method call*/s0_StringJc("StringPartBase.subSequence - faulty; "), from, _thCxt);
      { STACKTRC_LEAVE;
        return s0_StringJc("");
      }
    }
  }
  STACKTRC_LEAVE;
}

#ifdef DEF_ClassJc_Vtbl
StringJc toString_StringPartJc_F(ObjectJc const* ithis, ThCxt* _thCxt)
{ StringPartJc_s* thiz = (StringPartJc_s*)ithis;
  
  STACKTRC_TENTRY("toString_StringPartJc_F");
  
  { 
    
    
    CharSeqJc currentPart ; currentPart = fromObjectJc_CharSeqJc(&(* (getCurrentPart_StringPartJc(thiz, _thCxt)/*J2C:returnInThreadCxt*/)).base.object);
    
    StringJc ret ; ret = toString_CharSeqJc(currentPart/*J1cT2*/)/*J2C:non-persistent*/;
    { STACKTRC_LEAVE;
      #ifdef DEF_ThreadContext_HEAP_emC
      releaseUserBuffer_ThreadContext_emC(PTR_CharSeqJc(currentPart), _thCxt);
      #endif
      return ret;
    }
  }
  STACKTRC_LEAVE;
}
#endif //#ifdef DEF_ClassJc_Vtbl

#ifdef DEF_ClassJc_Vtbl
/*J2C: dynamic call variant of the override-able method: */
StringJc toString_StringPartJc(ObjectJc const* ithis, ThCxt* _thCxt)
{ Vtbl_ObjectJc const* mtbl = (Vtbl_ObjectJc const*)getVtbl_ObjectJc(ithis, sign_Vtbl_ObjectJc);
  return mtbl->toString(ithis, _thCxt);
}
#endif //#ifdef DEF_ClassJc_Vtbl


/**Returns a debug information of the content of the StringPart. This information is structured in the followed way:*/
StringJc debugString_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("debugString_StringPartJc");
  
  { 
     /*J2C: temporary Stringbuffer for String concatenation*/
    StringBuilderJc_s* _tempString2_1=null; 
    
    
    int32  len = thiz->endMax;
    
    StringJc ret ; ret = 
      ( _tempString2_1 = new_StringBuilderJc(-1, _thCxt)
      , setStringConcatBuffer_StringBuilderJc(_tempString2_1)
      , append_s_StringBuilderJc(_tempString2_1, subSequence_CharSeqJc(thiz->content/*J1cT2*/, 0, len > 20 ? 20 : len, _thCxt), _thCxt)
      , append_z_StringBuilderJc(_tempString2_1, "<<<", _thCxt)
      , append_I_StringBuilderJc(_tempString2_1, thiz->begin, _thCxt)
      , append_z_StringBuilderJc(_tempString2_1, ",", _thCxt)
      , append_I_StringBuilderJc(_tempString2_1, thiz->end, _thCxt)
      , append_z_StringBuilderJc(_tempString2_1, ">>>", _thCxt)
      , toStringNonPersist_StringBuilderJc(&(_tempString2_1)->base.object, _thCxt)
      )/*J2C:non-persistent*/;
    if(thiz->begin < len) 
    { 
      
      /***/
      ret = 
        ( append_s_StringBuilderJc(_tempString2_1, subSequence_CharSeqJc(thiz->content/*J1cT2*/, thiz->begin, len > (thiz->begin + 20) ? thiz->begin + 20 : len, _thCxt), _thCxt)
        , toStringNonPersist_StringBuilderJc(&(_tempString2_1)->base.object, _thCxt)
        )/*J2C:non-persistent*/;
    }
    /***/
    ret = 
      ( append_z_StringBuilderJc(_tempString2_1, "<<<", _thCxt)
      , toStringNonPersist_StringBuilderJc(&(_tempString2_1)->base.object, _thCxt)
      )/*J2C:non-persistent*/;
    { STACKTRC_LEAVE;
      activateGC_ObjectJc(&_tempString2_1->base.object, PTR_StringJc(ret), _thCxt);
      return ret;
    }/*java2c: buffer in threadContext*/
    
    activateGC_ObjectJc(&_tempString2_1->base.object, null, _thCxt);
  }
  STACKTRC_LEAVE;
}


/**Central mehtod to invoke excpetion, usefull to set a breakpoint in debug*/
void throwIndexOutOfBoundsException_StringPartJc(StringPartJc_s* thiz, StringJc sMsg, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("throwIndexOutOfBoundsException_StringPartJc");
  
  { 
    
    { THROW(IndexOutOfBoundsException, sMsg, 0, 0); };
  }
  STACKTRC_LEAVE;
}

void throwIllegalArgumentException_StringPartJc(/*J2C:static method*/ StringJc msg, int32 value, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("throwIllegalArgumentException_StringPartJc");
  
  { 
    
    { THROW(IllegalArgumentException, msg, value, 0); };
  }
  STACKTRC_LEAVE;
}


/**Closes the work. This routine should be called if the StringPart is never used, */
void close_StringPartJc_F(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("close_StringPartJc_F");
  
  { 
    
    thiz->content = null_CharSeqJc /*J2C: mem assignment*/;
    thiz->begiMin = thiz->beginLast = /*? assignment*/thiz->begin = /*? assignment*/0;
    thiz->endMax = thiz->end = /*? assignment*/thiz->endLast = /*? assignment*/0;
    thiz->bCurrentOk = thiz->bFound = /*? assignment*/false;
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void close_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt) { 
#ifdef DEF_ClassJc_Vtbl
  Vtbl_StringPartJc const* mtbl = (Vtbl_StringPartJc const*)getVtbl_ObjectJc(&thiz->base.object, sign_Vtbl_StringPartJc);
  mtbl->close(thiz, _thCxt);
#endif //#ifdef DEF_ClassJc_Vtbl
}


/**Replaces up to 20 placeholder with a given content.*/
CharSeqJc replace_StringPartJc(/*J2C:static method*/ CharSeqJc src, CharSeqJc_Y* placeholder, CharSeqJc_Y* value, struct StringBuilderJc_t* dst, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("replace_StringPartJc");
  
  { 
    
    
    int32  len = length_CharSeqJc(src/*J1cT2*/, _thCxt);
    
    int32  ixPos = 0;
    
    int32  nrofToken = placeholder->head.length;
    if(nrofToken != value->head.length) 
    { 
      
      throwIllegalArgumentException_StringPartJc(/*J2C:static method call*/s0_StringJc("token and value should have same size, lesser 20"), nrofToken, _thCxt);
      { STACKTRC_LEAVE;
        return src;
      }
    }
    if(dst == null) 
    { 
      ObjectJc *newObj3_1=null; /*J2C: temporary Objects for new operations
      */
      dst = ctorO_I_StringBuilderJc(/*J2C:static method call*/(newObj3_1 = alloc_ObjectJc(sizeof_StringBuilderJc, 0, _thCxt)), len + 100, _thCxt);
      activateGC_ObjectJc(newObj3_1, null, _thCxt);
    }/*calculate about 53 chars for identifier*/
    /*@Java4C.StackInstance final StringPart spPattern = new StringPart(src);*/
    
    
    int32  posPatternStart = 0;
    
    int32  posPattern;/*no initvalue*/
    do 
      { 
        
        
        int32 type[1] ; type; /*J2C:modeAccess=Q*/
        posPattern = indexOfAnyString_StringFunctionsJc(/*J2C:static method call*/src, posPatternStart, length_CharSeqJc(src/*J1cT2*/, _thCxt), placeholder, &type[0], null, _thCxt);
        if(posPattern >= 0) 
        { 
          
          append_c_StringBuilderJc(dst, subSequence_CharSeqJc(src/*J1cT2*/, posPatternStart, posPattern, _thCxt), _thCxt);/*characters from previous placeholder-end till next placeholder*/
          
          
          int32  ixValue = type[0];
          append_c_StringBuilderJc(dst, value->data[ixValue], _thCxt);
          posPatternStart = posPattern + length_CharSeqJc(placeholder->data[ixValue]/*J1cT2*/, _thCxt);
        }
        else 
        { /*:last pattern constant part:*/
          
          
          append_c_StringBuilderJc(dst, subSequence_CharSeqJc(src/*J1cT2*/, posPatternStart, len, _thCxt), _thCxt);
          posPatternStart = -1;/*mark end*/
          
        }
      }while(posPatternStart >= 0);
    { STACKTRC_LEAVE;
      return fromStringBuilderJc_CharSeqJc(dst);
    }
  }
  STACKTRC_LEAVE;
}



//casting admissible because static operation only used in folllowing Vtbl in this compilation unit.
static int32 length_StringPartJc_i_CharSeqObjJc(CharSeqObjJc const* ithiz, ThCxt* _thCxt){ 
  return length_StringPartJc((StringPartJc_s*)ithiz, _thCxt); 
}



#ifdef DEF_ClassJc_Vtbl
/**J2C: Reflections and Method-table *************************************************/
const VtblDef_StringPartJc mtblStringPartJc = {
{ { sign_Vtbl_StringPartJc //J2C: Head of methodtable of StringPartJc
  , (struct Size_Vtbl_t*)((2 +2) * sizeof(void*)) //J2C:size. NOTE: all elements has the size of void*.
  }
  //J2C: Dynamic methods of the class :StringPartJc:
, getLineAndColumn_StringPartJc_F //getLineAndColumn
, close_StringPartJc_F //close
  //J2C: The superclass's methodtable: 
, { { sign_Vtbl_ObjectJc //J2C: Head of methodtable of ObjectJc
    , (struct Size_Vtbl_t*)((5 +2) * sizeof(void*)) //J2C:size. NOTE: all elements has the size of void*.
    }
    //J2C: Dynamic methods of the class :ObjectJc:
  , clone_ObjectJc_F //clone
  , equals_ObjectJc_F //equals
  , finalize_ObjectJc_F //finalize
  , hashCode_ObjectJc_F //hashCode
  , toString_StringPartJc_F //toString
  }
  //J2C: The interface's methodtable: 
  //J2C: Vtbl-interfaces of :StringPartJc: */
, { { sign_Vtbl_CharSeqJc //J2C: Head of methodtable of CharSeqJc
    , (struct Size_Vtbl_t*)((3 +2) * sizeof(void*)) //J2C:size. NOTE: all elements has the size of void*.
    }
    //J2C: Dynamic methods of the class :CharSeqJc:
  , length_StringPartJc_i_CharSeqObjJc //length
  , charAt_i_StringPartJc //charAt
  , subSequence_ii_StringPartJc //subSequence
  }
, { { sign_Vtbl_ComparableJc //J2C: Head of methodtable of ComparableJc
    , (struct Size_Vtbl_t*)((0 +2) * sizeof(void*)) //J2C:size. NOTE: all elements has the size of void*.
    }
  }
}, { signEnd_Vtbl_ObjectJc, null } }; //Vtbl
#endif //#ifdef DEF_ClassJc_Vtbl


#ifdef DEF_REFLECTION_NO

#define REFLECTION_Fields_StringPartJc null
#define REFLECTION_Methods_StringPartJc null
#define REFLECTION_Superclass_StringPartJc null
#define REFLECTION_Interfaces_StringPartJc null

#elif defined(DEF_REFLECTION_SIMPLE)

ClassJc const refl_StringPartJc_s = INIZ_ClassJc(refl_StringPartJc_s, "StringPartJc");

#elif defined(DEF_REFLECTION_FULL)

 extern_C struct ClassJc_t const refl_ObjectJc;
 static struct superClasses_StringPartJc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxVtblJc data[1];
 }superclasses_StringPartJc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxVtblJc, 1, OBJTYPE_ClassOffset_idxVtblJc, null, null)
 , { { &refl_ObjectJc
     #ifdef DEF_ClassJc_Vtbl
     , OFFSET_Vtbl(Vtbl_StringPartJc, ObjectJc) 
     #endif
     }
   }
 };

 extern_C struct ClassJc_t const refl_CharSeqJc;
 extern_C struct ClassJc_t const refl_ComparableJc;
 static struct ifcClasses_StringPartJc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxVtblJc data[2];
 }interfaces_StringPartJc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxVtblJc, 1, OBJTYPE_ClassOffset_idxVtblJc, null, null)
, { { &refl_CharSeqJc
    #ifdef DEF_ClassJc_Vtbl
    , OFFSET_Vtbl(Vtbl_StringPartJc, CharSeqJc)
    #endif 
    }
  #ifdef DEF_ClassJc_Vtbl
  , { &refl_ComparableJc
    #ifdef DEF_ClassJc_Vtbl
    , OFFSET_Vtbl(Vtbl_StringPartJc, ComparableJc) 
    #endif
    }
  #endif
  }
};

extern_C struct ClassJc_t const refl_StringPartJc_s;
extern_C struct ClassJc_t const refl_CharSeqJc;
extern_C struct ClassJc_t const refl_StringJc;
const struct Reflection_Fields_StringPartJc_s_t
{ ObjectArrayJc head; FieldJc data[18];
} refl_Fields_StringPartJc_s =
{ CONST_ObjectArrayJc(FieldJc, 18, OBJTYPE_FieldJc, null, &refl_Fields_StringPartJc_s)
, {
     { "begin"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((intptr_t)(&((StringPartJc_s*)(0x1000))->begin) - (intptr_t)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_StringPartJc_s
    }
   , { "end"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((intptr_t)(&((StringPartJc_s*)(0x1000))->end) - (intptr_t)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_StringPartJc_s
    }
   , { "begiMin"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((intptr_t)(&((StringPartJc_s*)(0x1000))->begiMin) - (intptr_t)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_StringPartJc_s
    }
   , { "endMax"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((intptr_t)(&((StringPartJc_s*)(0x1000))->endMax) - (intptr_t)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_StringPartJc_s
    }
   , { "content"
    , 0 //nrofArrayElements
    , &refl_CharSeqJc
    , kEnhancedReference_Modifier_reflectJc /*c*/ //bitModifiers
    , (int16)((intptr_t)(&((StringPartJc_s*)(0x1000))->content) - (intptr_t)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_StringPartJc_s
    }
   , { "bCurrentOk"
    , 0 //nrofArrayElements
    , REFLECTION_bool
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((intptr_t)(&((StringPartJc_s*)(0x1000))->bCurrentOk) - (intptr_t)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_StringPartJc_s
    }
   , { "bStartScan"
    , 0 //nrofArrayElements
    , REFLECTION_bool
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((intptr_t)(&((StringPartJc_s*)(0x1000))->bStartScan) - (intptr_t)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_StringPartJc_s
    }
   , { "beginLast"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((intptr_t)(&((StringPartJc_s*)(0x1000))->beginLast) - (intptr_t)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_StringPartJc_s
    }
   , { "endLast"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((intptr_t)(&((StringPartJc_s*)(0x1000))->endLast) - (intptr_t)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_StringPartJc_s
    }
   , { "bFound"
    , 0 //nrofArrayElements
    , REFLECTION_bool
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((intptr_t)(&((StringPartJc_s*)(0x1000))->bFound) - (intptr_t)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_StringPartJc_s
    }
   , { "bitMode"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((intptr_t)(&((StringPartJc_s*)(0x1000))->bitMode) - (intptr_t)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_StringPartJc_s
    }
   , { "sFile"
    , 0 //nrofArrayElements
    , &refl_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ //bitModifiers
    , (int16)((intptr_t)(&((StringPartJc_s*)(0x1000))->sFile) - (intptr_t)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_StringPartJc_s
    }
   , { "sCommentStart"
    , 0 //nrofArrayElements
    , &refl_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ //bitModifiers
    , (int16)((intptr_t)(&((StringPartJc_s*)(0x1000))->sCommentStart) - (intptr_t)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_StringPartJc_s
    }
   , { "sCommentEnd"
    , 0 //nrofArrayElements
    , &refl_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ //bitModifiers
    , (int16)((intptr_t)(&((StringPartJc_s*)(0x1000))->sCommentEnd) - (intptr_t)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_StringPartJc_s
    }
   , { "sCommentToEol"
    , 0 //nrofArrayElements
    , &refl_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ //bitModifiers
    , (int16)((intptr_t)(&((StringPartJc_s*)(0x1000))->sCommentToEol) - (intptr_t)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_StringPartJc_s
    }
   , { "sVersion"
    , 0 //nrofArrayElements
    , &refl_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&sVersion_StringPartJc) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&sVersion_StringPartJc)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &refl_StringPartJc_s
    }
   , { "seekToLeft"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&seekToLeft_StringPartJc) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&seekToLeft_StringPartJc)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &refl_StringPartJc_s
    }
   , { "seekBack"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&seekBack_StringPartJc) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&seekBack_StringPartJc)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &refl_StringPartJc_s
    }
} };


#define REFLECTION_Fields_StringPartJc (FieldJc_Y const*)&refl_Fields_StringPartJc_s
#define REFLECTION_Methods_StringPartJc null //method
#define REFLECTION_Superclass_StringPartJc &superclasses_StringPartJc_s.head.object //superclass
#define REFLECTION_Interfaces_StringPartJc (ClassOffset_idxVtblJcARRAY*)&interfaces_StringPartJc_s //interfaces




const ClassJc refl_StringPartJc_s = 
{ INIZ_ObjectJc(refl_StringPartJc_s, refl_ClassJc, ID_refl_ClassJc)
, "StringPartJc_s"
, OFFSET_IN_STRUCT(StringPartJc_s, base.object)
, sizeof(StringPartJc_s)
, REFLECTION_Fields_StringPartJc
, REFLECTION_Methods_StringPartJc
, REFLECTION_Superclass_StringPartJc //superclass
, REFLECTION_Interfaces_StringPartJc
, mObjectJc_Modifier_reflectJc
#ifdef DEF_ClassJc_Vtbl
, &mtblStringPartJc.mtbl.head
#endif
};

#endif //

/**This class presents a part of the parent CharSequence of this class.
The constructor is protected because instances of this class are only created in this class
or its derived, not by user.
The CharSequence methods get the characters from the parent CharSequence of the environment class
StringPartBase. 
*/


const char sign_Vtbl_Part_StringPartJc[] = "Part_StringPartJc"; //to mark method tables of all implementations

#ifdef DEF_ClassJc_Vtbl
typedef struct VtblDef_Part_StringPartJc_t { Vtbl_Part_StringPartJc mtbl; VtblHeadJc end; } VtblDef_Part_StringPartJc;
 extern VtblDef_Part_StringPartJc const mtblPart_StringPartJc;
#endif //#ifdef DEF_ClassJc_Vtbl


/*Constructor */
struct Part_StringPartJc_t* ctorO_Part_StringPartJc(struct StringPartJc_t* outer, ObjectJc* othis, int32 from, int32 to, ThCxt* _thCxt)
{ Part_StringPartJc_s* thiz = (Part_StringPartJc_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_Part_StringPartJc");
  checkConsistence_ObjectJc(othis, sizeof(Part_StringPartJc_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &refl_Part_StringPartJc_s, sizeof(Part_StringPartJc_s));  
  thiz->outer = outer;
  //j2c: Initialize all class variables:
  {
  }
  { 
    setPart_Part_StringPartJc(thiz, from, to, _thCxt);
  }
  STACKTRC_LEAVE;
  return thiz;
}



//manual:
void setPart_Part_StringPartJc(struct Part_StringPartJc_t* thiz, int32 from, int32 to, ThCxt* _thCxt) {
  STACKTRC_TENTRY("setPart_Part_StringPartJc");
  ASSERT(/*J2C:static method call*/from >= 0 && from <= thiz->outer->endMax);
  ASSERT(/*J2C:static method call*/to >= 0 && to <= thiz->outer->endMax);
  ASSERT(/*J2C:static method call*/from <= to);
  thiz->b1 = from;
  thiz->e1 = to;
  STACKTRC_RETURN;
}




char charAt_i_Part_StringPartJc(CharSeqObjJc const* ithis, int32 index, ThCxt* _thCxt)
{ Part_StringPartJc_s* thiz = (Part_StringPartJc_s*)ithis;
  
  STACKTRC_TENTRY("charAt_i_Part_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return absCharAt_StringPartJc((struct StringPartJc_t * /*J2C chg access*/)(thiz)->outer, thiz->b1 + index, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

int32 length_Part_StringPartJc(Part_StringPartJc_s const* thiz, ThCxt* _thCxt)
{ STACKTRC_TENTRY("length_Part_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->e1 - thiz->b1;
    }
  }
  STACKTRC_LEAVE;
}

#if defined(DEF_ClassJc_Vtbl) && defined(DEF_ThreadContext_HEAP_emC)
CharSeqJc subSequence_ii_Part_StringPartJc(CharSeqObjJc const* ithis, int32 from, int32 end, ThCxt* _thCxt)
{ Part_StringPartJc_s* thiz = (Part_StringPartJc_s*)ithis;
  
  STACKTRC_TENTRY("subSequence_ii_Part_StringPartJc");
  
  { 
    
    
    struct Part_StringPartJc_t*  ret = ctorO_Part_StringPartJc((struct StringPartJc_t * /*J2C chg access*/)(thiz)->outer, allocInThreadCxt_ObjectJc(sizeof(Part_StringPartJc_s), "StringPart.Part.subSequence", _thCxt), thiz->b1 + from, thiz->b1 + thiz->outer->end, _thCxt);
    { STACKTRC_LEAVE;
      return fromObjectJc_CharSeqJc(&(* (ret)).base.object);
    }
  }
  STACKTRC_LEAVE;
}
#else 
CharSeqJc subSequence_ii_Part_StringPartJc(CharSeqObjJc const* ithis, int32 from, int32 end, ThCxt* _thCxt)
{ Part_StringPartJc_s* thiz = (Part_StringPartJc_s*)ithis;
  STACKTRC_TENTRY("subSequence_ii_Part_StringPartJc");
  CharSeqJc ret = empty_StringJc;
  THROW1_s0(IllegalArgumentException, "not available without Heap management", 0);
  STACKTRC_RETURN ret;
}
#endif //#ifdef DEF_ClassJc_Vtbl


StringJc toString_Part_StringPartJc(ObjectJc const* ithis, ThCxt* _thCxt)
{ Part_StringPartJc_s* thiz = (Part_StringPartJc_s*)ithis;
  
  STACKTRC_TENTRY("toString_Part_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return absSubString_StringPartJc((struct StringPartJc_t * /*J2C chg access*/)(thiz)->outer, thiz->b1, thiz->e1, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}




int copyToBuffer_Part_StringPartJc(struct Part_StringPartJc_t* thiz, char* dst, int from, int to, ThCxt* _thCxt) {
  //int max = MIN_emC(to - from, dst.length - thiz->from);
  int max = to - from;
  if (max > thiz->e1 - thiz->b1) { max = thiz->e1 - thiz->b1; }
  for(int ix = thiz->absPos0 - thiz->outer->absPos0 + thiz->b1; ix < thiz->absPos0 - thiz->outer->absPos0 + thiz->b1 + max ; ++ix ) {
    dst[from++] = charAt_CharSeqJc(thiz->outer->content, ix, _thCxt);
  }
  return max;

}



/**Builds a new Part without leading and trailing white spaces.*/
void trim_Part_StringPartJc(Part_StringPartJc_s* thiz, struct Part_StringPartJc_t* dst, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("trim_Part_StringPartJc");
  
  { 
    
    
    int32  b2 = thiz->b1;
    
    int32  e2 = thiz->e1;
    
    while(b2 < e2 && indexOf_C_StringJc(zI_StringJc(" \r\n\t",4), charAt_CharSeqJc(thiz->outer->content/*J1cT2*/, b2, _thCxt)) >= 0)
      { 
        
        b2 += 1;
      }
    
    while(e2 > b2 && indexOf_C_StringJc(zI_StringJc(" \r\n",3), charAt_CharSeqJc(thiz->outer->content/*J1cT2*/, e2 - 1, _thCxt)) >= 0)
      { 
        
        e2 -= 1;
      }
  dst->outer = thiz->outer;
  setPart_Part_StringPartJc(dst, b2, e2, _thCxt);  
//    struct Part_StringPartJc_t*  ret = ctorO_Part_StringPartJc((struct StringPartJc_t * /*J2C chg access*/)(thiz)->outer, allocInThreadCxt_ObjectJc(sizeof(Part_StringPartJc_s), "StringPart.Part.subSequence", _thCxt), b2, e2, _thCxt);
//    { STACKTRC_LEAVE;
//      return ret;
//    }
  }
  STACKTRC_LEAVE;
}



//casting admissible because static operation only used in folllowing Vtbl in this compilation unit.
static int32 length_Part_StringPartJc_i_CharSeqObjJc(CharSeqObjJc const* ithiz, ThCxt* _thCxt){ 
  return length_Part_StringPartJc((Part_StringPartJc_s*)ithiz, _thCxt); 
}




#ifdef DEF_ClassJc_Vtbl
/**J2C: Reflections and Method-table *************************************************/
const VtblDef_Part_StringPartJc mtblPart_StringPartJc = {
{ { sign_Vtbl_Part_StringPartJc //J2C: Head of methodtable of Part_StringPartJc
  , (struct Size_Vtbl_t*)((0 +2) * sizeof(void*)) //J2C:size. NOTE: all elements has the size of void*.
  }
  //J2C: The superclass's methodtable: 
, { { sign_Vtbl_ObjectJc //J2C: Head of methodtable of ObjectJc
    , (struct Size_Vtbl_t*)((5 +2) * sizeof(void*)) //J2C:size. NOTE: all elements has the size of void*.
    }
    //J2C: Dynamic methods of the class :ObjectJc:
  , clone_ObjectJc_F //clone
  , equals_ObjectJc_F //equals
  , finalize_ObjectJc_F //finalize
  , hashCode_ObjectJc_F //hashCode
  , toString_Part_StringPartJc //toString
  }
  //J2C: The interface's methodtable: 
  //J2C: Vtbl-interfaces of :Part_StringPartJc: */
, { { sign_Vtbl_CharSeqJc //J2C: Head of methodtable of CharSeqJc
    , (struct Size_Vtbl_t*)((3 +2) * sizeof(void*)) //J2C:size. NOTE: all elements has the size of void*.
    }
    //J2C: Dynamic methods of the class :CharSeqJc:
  , length_Part_StringPartJc_i_CharSeqObjJc //length
  , charAt_i_Part_StringPartJc //charAt
  , subSequence_ii_Part_StringPartJc //subSequence
  }
}, { signEnd_Vtbl_ObjectJc, null } }; //Vtbl
#endif //#ifdef DEF_ClassJc_Vtbl


#ifdef DEF_REFLECTION_SIMPLE

ClassJc const refl_Part_StringPartJc_s = INIZ_ClassJc(refl_Part_StringPartJc_s, "Part_StringPartJc");

#elif defined(DEF_REFLECTION_FULL)

 extern_C struct ClassJc_t const refl_ObjectJc;
 static struct superClasses_Part_StringPartJc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxVtblJc data[1];
 }superclasses_Part_StringPartJc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxVtblJc, 1, OBJTYPE_ClassOffset_idxVtblJc, null, null)
 , { { &refl_ObjectJc
     #ifdef DEF_ClassJc_Vtbl
     , OFFSET_Vtbl(Vtbl_Part_StringPartJc, ObjectJc) 
     #endif
     }
   }
 };

 extern_C struct ClassJc_t const refl_CharSeqJc;
 static struct ifcClasses_Part_StringPartJc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxVtblJc data[1];
 }interfaces_Part_StringPartJc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxVtblJc, 1, OBJTYPE_ClassOffset_idxVtblJc, null, null)
, { { &refl_CharSeqJc
    #ifdef DEF_ClassJc_Vtbl
    , OFFSET_Vtbl(Vtbl_Part_StringPartJc, CharSeqJc) 
    #endif
    }
  }
};

extern_C struct ClassJc_t const refl_Part_StringPartJc_s;
extern_C struct ClassJc_t const refl_CharSeqJc;
extern_C struct ClassJc_t const refl_StringJc;
const struct Reflection_Fields_Part_StringPartJc_s_t
{ ObjectArrayJc head; FieldJc data[2];
} refl_Fields_Part_StringPartJc_s =
{ CONST_ObjectArrayJc(FieldJc, 2, OBJTYPE_FieldJc, null, &refl_Fields_Part_StringPartJc_s)
, {
     { "b1"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((intptr_t)(&((Part_StringPartJc_s*)(0x1000))->b1) - (intptr_t)(Part_StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_Part_StringPartJc_s
    }
   , { "e1"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((intptr_t)(&((Part_StringPartJc_s*)(0x1000))->e1) - (intptr_t)(Part_StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_Part_StringPartJc_s
    }
} };


const ClassJc refl_Part_StringPartJc_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &refl_ObjectJc, &refl_ClassJc) 
, "Part_StringPartJc_s"
, (int16)((intptr_t)(&((Part_StringPartJc_s*)(0x1000))->base.object) - (intptr_t)(Part_StringPartJc_s*)0x1000)
, sizeof(Part_StringPartJc_s)
, (FieldJc_Y const*)&refl_Fields_Part_StringPartJc_s
, null //method
, &superclasses_Part_StringPartJc_s.head.object //superclass
, (ClassOffset_idxVtblJcARRAY*)&interfaces_Part_StringPartJc_s //interfaces
, mObjectJc_Modifier_reflectJc
#ifdef DEF_ClassJc_Vtbl
, &mtblPart_StringPartJc.mtbl.head
#endif
};
#endif //DEF_REFLECTION_FULL

#endif //#ifdef DEF_ObjectJcpp_REFLECTION  //only possible with reflection because Vtable is need
