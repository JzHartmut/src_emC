/**************************************************************************
 * This file is generated by Java2C
 **copyright***************************************************************
 *************************************************************************/
#include "emC/J1c/ByteDataAccessBaseJc.h"
#include <string.h>  //because using memset()
#include <emC/Jc/ReflectionJc.h>   //Reflection concept 
  //basic stacktrace concept
#include "emC/Jc/ArraysJc.h"  //reference-association: ArraysJc
#include "emC/Jc/CharsetJc.h"  //reference-association: CharsetJc
#include "emC/Jc/StringJc.h"  //embedded type in class data
#include "emC/Jc/SystemJc.h"  //reference-association: FloatJc
#include <emC/Base/SimpleC_emC.h>

/* J2C: Forward declaration of struct ***********************************************/

/**This class is a base class to control the access to binary data.
The binary data may typically used or produced from a part of software written in C or C++.
Therewith the binary data are struct-constructs. Another example - build of datagram structures.
<br>
This class is a base class which should be derived for user's necessities. 
The methods {@link #getInt16(int)} etc. are protected. That should prevent erratic free accesses to data 
on application level. A derived class of this class structures the software for byte data access.
<br><br> 
It is able to support several kinds of structured data access:<ul>
<li>Simple C-like <code>struct</code> are adequate mapped with a simple derived class of this class, 
using the protected commonly access methods like {@link #_getLong(int, int)} with predefined indexes 
in special methods like getValueXyz().
<li>Complex <code>struct</code> with nested <code>struct</code> inside are mapped 
with one derived class per <code>struct</code>, define one reference per nested struct 
<li>Base <code>struct</code> inside a <code>struct</code> (inheritance in C) can be mapped with 
extra derived classes for the base struct and usind the
{@link #assignCasted(ByteDataAccessBase, int, int)}-method.
<li>A pack of data with several struct may be mapped using the {@link #addChild(ByteDataAccessBase)}-method.
Thereby a parent should be defined, and the structs of the pack are children of this parent. 
That structures need not be from the same type.
<li>packs of struct with parent are able to nesting, it is able to construct as a tree of pack of structures. 
The parent of the pack is the tree node. It is likewise a XML tree. 
The data may be also transformed to a XML data representation
or the data structure may be explained with a XML tree, but they are not
XML data straight.
</ul>
This application possibilities show a capable of development system to access binary data. 
The other, hand made way was calculate with indices of the byte[idx] specially user programmed. 
This class helps to make such complex index calculation needlessly. 
One struct at C level corresponds with one derivated class of ByteDataAccessBase. 
But last also a generation of the java code from C/C++-header files containing the structs is able to.
So the definition of byte positions are made only on one source. The C/C++ is primary thereby. 

<br>
The UML structure of such an class in a environment may be shown with the
followed object model diagram, <br>
<code> <+>---> </code>is a composition,
<code> <>---> </code>is a aggregation, <code> <|---- </code>is a inherition.
<pre>
+-------------------------------+                 +----------+
| ByteDataAccessBase(sizeHead)  |----data-------->| byte[]   |
|-------------------------------|                 |          |
|- idxBegin:int                 |                 | d a t a  |
|- idxNextChild:int             |                 +----------+
+-------------+     |- idxEnd:int                   |
| derivated   |     |-------------------------------|<---------------+ a known parent
| user        |---|>|+ addChild(child)              |---parent-------+ set in addChild()                
| classes     |     |+ addChildFloat()              |
+-------------+     |% getInt32()                   |----currChild---+
|                               |<---------------+
+-------------------------------+
</pre>

This class is the base class for ByteDataAccess. It works without dynamic methods proper for C usage.
All variables are package private because they should be changed only with methods of this class.
<br><br>
<h2>Initialization and instances</h2>
The root instance to access to data should be initialized with
<pre>
MyByteDataAccessRoot accessRoot = new MyByteDataAccessRoot(); 
//... invokes super.ByteDataAccessBase(lengthHead);
accessRoot.assign(myData, dataLength);
</pre>  
Any instances which represents a sub structure in data can be created as re-useable instances, which can be added
as child of the root instance or as child of any already added child on demand:
<pre>
MySubStruct subStruct = new SubStruct();  //an instance for accessing 
....
accessRoot.addChild(subStruct);         //adds on current position.
int value = subStruct.getValuexyz();    //now can access the data.
....  //later on code:
accessOther.addChild(subStruct);        //reuse the instance for access
int value = subStruct.getValueAbc();    //access other data.
</pre>
The instances of this derived class are helper to access to the data, they are not container for the data. 
The data are stored in a <code>byte[]</code>-array 


<br>  
<h2>children, currentChild, addChild</h2>
Children are used to evaluate or write different data structures after a known structure. 
The children may be from several derived types of this class. 
With children and children inside children a tree of different data can be built or evaluated.
<ul>
<li>{@link #addChild(ByteDataAccessBase)}: adds a child with its head size
<li>{@link #addChild(ByteDataAccessBase, int)}: adds a child with a given length
<li>{@link #addChildEmpty(ByteDataAccessBase)}: adds a child with its head size for writing, set all data to 0.
<li>{@link #addChildEmpty(ByteDataAccessBase, int)}: same with given size of child.
<li>{@link #addChildFloat(float)}, {@link #addChildInteger(int, long)}: writes the value and increments the #ixChildEnd after it.
<li>{@link #addChildString(CharSequence)}, {@link #addChildString(CharSequence, String)}: writes the String.
<li>{@link #getChildFloat()}, {@link #getChildDouble()}, {@link #getChildInteger(int)}: reads the value at {@link #ixNextChild}
and increments the {@link #ixNextChild}.
<li>{@link #getChildString(int)} reads a String and increments the {@link #ixNextChild}
<li>{@link #addChildAt(int, ByteDataAccessBase)}, {@link #addChildAt(int, ByteDataAccessBase, int)}: Used if the byte structure
is known. Adds a child not at #ixNextChild but at the given position. 
</ul>
Mechanism and indices see {@link #addChild(ByteDataAccessBase, int)}.   


<h2>Expand, check</h2>
If an instance is set for read or change, a given number of valid data bytes are known. The instance is marked as 'non expandable', see
The data should be assigned with
<ul>
<li>{@link #assign(byte[], int)} with given length, not expandable
<li>{@link #assign(byte[], int, int)} at a defined position in the data usefull for special cases.
With the given length >= the sizehead of the {@link ByteDataAccessBase#ByteDataAccessBase(int)} 
the internal flag {@link #bExpand} is set to false.
</ul>
If an instance is set for write, the maximal number of bytes is limited by the size of data (byte[]).
The data should be assigned with:
<ul>
<li>{@link #assignClear(byte[])} as empty instance, the data are cleared in its whole length.
<li>{@link #assign(byte[], int)} with 0 as length argument as instance which only knows the head data, but the data are not cleared.
</ul>
In both cases the internal flag {@link #bExpand} is set to true. It means that the {@link #ixEnd()} which is set initially to the {@link #sizeHead}
is increased if a child is added.
<br><br>
If an instance of this is set to non expandable,
an exception is thrown if a children is added after the given length. If an instance is designated as 'expandable' the end index
#ixEnd is increased by adding children till the length of data as its maximal value.
<br><br>
With the operations {@link #sufficingBytesForNextChild(int)} or {@link #getMaxNrofBytes()} it can be tested whether a child can be added
with its known length.   
<br>

<h2>Examples</h2>
See 
<ul>
<li>{@link org.vishia.byteData.test.TestByteDataAccessBase}
<li>{@link org.vishia.byteData.test.ExampleStringOrInt}
</ul> 
*/


const char sign_Vtbl_ByteDataAccessBaseJc[] = "ByteDataAccessBaseJc"; //to mark method tables of all implementations

StringJc version_ByteDataAccessBaseJc = CONST_z_StringJc("2016-01-24"); //J2C:static StringJc

/*Constructor */
struct ByteDataAccessBaseJc_t* ctorM_i_ByteDataAccessBaseJc(MemC mthis, int32 sizeHead, ThCxt* _thCxt)
{ ByteDataAccessBaseJc_s* thiz = PTR_MemC(mthis, ByteDataAccessBaseJc_s);  //reference casting to the real class.
  int sizeObj = size_MemC(mthis);
  STACKTRC_TENTRY("ctor_ByteDataAccessBaseJc");
  if(sizeof(ByteDataAccessBaseJc_s) > sizeObj) THROW1_s0(IllegalArgumentException, "faut size", sizeObj);
  //j2c: Initialize all class variables:
  {
    thiz->bExc = true;
    thiz->charset = forNamez_CharsetJc(/*J2C:static method call*/"ISO-8859-1", _thCxt);
  }
  { 
    
    thiz->sizeHead = sizeHead;
  }
  STACKTRC_LEAVE;
  return thiz;
}



/*Constructor */
struct ByteDataAccessBaseJc_t* ctorM_ii_ByteDataAccessBaseJc(MemC mthis, int32 sizeHead, int32 sizeData, ThCxt* _thCxt)
{ ByteDataAccessBaseJc_s* thiz = PTR_MemC(mthis, ByteDataAccessBaseJc_s);  //reference casting to the real class.
  int sizeObj = size_MemC(mthis);
  STACKTRC_TENTRY("ctor_ByteDataAccessBaseJc");
  if(sizeof(ByteDataAccessBaseJc_s) > sizeObj) THROW1_s0(IllegalArgumentException, "faut size", sizeObj);
  //j2c: Initialize all class variables:
  {
    thiz->bExc = true;
    thiz->charset = forNamez_CharsetJc(/*J2C:static method call*/"ISO-8859-1", _thCxt);
  }
  { 
    
    ASSERT_emC(/*J2C:static method call*/sizeHead >= 0, "", sizeHead, 0);
    ASSERT_emC(/*J2C:static method call*/sizeData >= 1, "", sizeData, 0);
    thiz->sizeHead = sizeHead;
    thiz->ixBegin = 0;
    thiz->ixEnd = sizeData;
    thiz->bExpand = false;
    thiz->ixNextChild = sizeHead;
    CLEAR_REFJc(thiz->parent);
  }
  STACKTRC_LEAVE;
  return thiz;
}



/**Returns the content of 1 to 8 bytes inside the actual element as a long number,*/
int64 _getLong_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idxInChild, int32 nrofBytesAndSign)
{ 
  
  { 
    
    
    int64  val = 0;
    
    int32  idxStep;/*no initvalue*/
    
    int32  idx;/*no initvalue*/
    
    int32  nrofBytes;/*no initvalue*/
    
    bool  bSigned;/*no initvalue*/
    if(nrofBytesAndSign >= 0) 
    { 
      
      nrofBytes = nrofBytesAndSign;
      bSigned = false;
    }
    else 
    { 
      
      nrofBytes = -nrofBytesAndSign;
      bSigned = true;
    }
    if(thiz->bBigEndian) 
    { 
      
      idx = thiz->ixBegin + idxInChild;
      idxStep = 1;
    }
    else 
    { 
      
      idx = thiz->ixBegin + idxInChild + nrofBytes - 1;
      idxStep = -1;
    }
    
    int32  nByteCnt = nrofBytes;
    do 
      { 
        
        val |= thiz->data.addr[idx] & 0xff;
        if(--nByteCnt <= 0) break;/*TRICKY: break in mid of loop, no shift operation.*/
        
        val <<= 8;
        idx += idxStep;
      }while(true);/*see break;*/
    
    if(bSigned) 
    { 
      
      
      int32  posSign = (nrofBytes * 8) - 1;
      
      int64  maskSign = ((int64)1) << posSign;
      if((val & maskSign) != 0) 
      { 
        
        
        int64  bitsSign = 0xffffffffffffffff << (posSign);
        val |= bitsSign;/*supplement the rest bits of long with the sign value,it's negativ.   */
        
      }
    }
    
      return val;
  }
}


/**Returns the content of 1 to 4 bytes inside the actual element as a int number,*/
int32 _getInt_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idxInChild, int32 nrofBytesAndSign)
{ 
  
  { 
    
    
    int32  val = 0;
    
    int32  idxStep;/*no initvalue*/
    
    int32  idx;/*no initvalue*/
    
    int32  nrofBytes;/*no initvalue*/
    
    bool  bSigned;/*no initvalue*/
    if(nrofBytesAndSign >= 0) 
    { 
      
      nrofBytes = nrofBytesAndSign;
      bSigned = false;
    }
    else 
    { 
      
      nrofBytes = -nrofBytesAndSign;
      bSigned = true;
    }
    if(thiz->bBigEndian) 
    { 
      
      idx = thiz->ixBegin + idxInChild;
      idxStep = 1;
    }
    else 
    { 
      
      idx = thiz->ixBegin + idxInChild + nrofBytes - 1;
      idxStep = -1;
    }
    
    int32  nByteCnt = nrofBytes;
    do 
      { 
        
        val |= thiz->data.addr[idx] & 0xff;
        if(--nByteCnt <= 0) break;/*TRICKY: break in mid of loop, no shift operation.*/
        
        val <<= 8;
        idx += idxStep;
      }while(true);/*see break;*/
    
    if(bSigned) 
    { 
      
      
      int32  posSign = (nrofBytes * 8) - 1;
      
      int64  maskSign = ((int64)1) << posSign;
      if((val & maskSign) != 0) 
      { 
        
        
        int64  bitsSign = 0xffffffffffffffff << (posSign);
        val |= ((/*J2C:cast% from int64*/int32)(bitsSign));/*supplement the rest bits of long with the sign value,it's negativ.   */
        
      }
    }
    
      return val;
  }
}


/**sets the content of 1 to 8 bytes inside the actual element as a long number,*/
void _setLong_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx, int32 nrofBytes, int64 val)
{ 
  
  { 
    
    
    int32  idx1;/*no initvalue*/
    
    int32  nrofBytes1 = nrofBytes;
    
    int64  val1 = val;
    
    int32  idxStep;/*no initvalue*/
    if(thiz->bBigEndian) 
    { 
      
      idx1 = thiz->ixBegin + idx + nrofBytes - 1;
      idxStep = -1;
    }
    else 
    { 
      
      idx1 = thiz->ixBegin + idx;
      idxStep = 1;
    }
    do 
      { 
        
        thiz->data.addr[idx1] = (int8 /*J2C_cast*/)(val1);
        if(--nrofBytes1 <= 0) break;
        val1 >>= 8;
        idx1 += idxStep;
      }while(true);/*see break;*/
    
  }
}


/**sets the content of 1 to 4 bytes inside the actual element as a long number,*/
void _setInt_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx, int32 nrofBytes, int32 val)
{ 
  
  { 
    
    
    int32  idx1;/*no initvalue*/
    
    int32  nrofBytes1 = nrofBytes;
    
    int32  val1 = val;
    
    int32  idxStep;/*no initvalue*/
    if(thiz->bBigEndian) 
    { 
      
      idx1 = thiz->ixBegin + idx + nrofBytes - 1;
      idxStep = -1;
    }
    else 
    { 
      
      idx1 = thiz->ixBegin + idx;
      idxStep = 1;
    }
    do 
      { 
        
        thiz->data.addr[idx1] = (int8 /*J2C_cast*/)(val1);
        if(--nrofBytes1 <= 0) break;
        val1 >>= 8;
        idx1 += idxStep;
      }while(true);/*see break;*/
    
  }
}


/**Increments the {@link #ixNextChild} and/or increments the ixEnd of this and all parents.*/
void _expand_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 ixNextChildNew, int32 ixEndNew, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("_expand_ByteDataAccessBaseJc");
  
  { 
    
    ASSERT(/*J2C:static method call*/ixEndNew < 0 || ixEndNew >= thiz->ixBegin + thiz->sizeHead);
    if(ixEndNew > thiz->data.val) {
      THROW_s0(IllegalArgumentException, "child long as data, data.length=%d, ixChildEndNew=%d", thiz->data.val, ixEndNew);
    }
    if(thiz->bExpand) 
    { 
      
      if(thiz->ixEnd < ixEndNew) 
      { /*:do it only in expand mode*/
        
        
        thiz->ixEnd = ixEndNew;
      }
      if(thiz->ixEnd < ixNextChildNew) 
      { /*:If ixEnd is less because it is the old one.*/
        /*:do it only in expand mode*/
        
        
        thiz->ixEnd = ixNextChildNew;
      }
      if(REFJc(thiz->parent)!= null) 
      { 
        
        _expand_ByteDataAccessBaseJc(REFJc (thiz->parent), thiz->ixEnd, thiz->ixEnd, _thCxt);/*all parents nextChild set to end of child, expand the parent if necessary.*/
        
      }
    }
    else 
    { /*:not in expand mode*/
      
      
      if(ixEndNew >= 0) 
      { /*:-1: don't use! */
        
        
        thiz->ixEnd = ixEndNew;/*it is valid.     */
        
      }
      if(REFJc(thiz->parent)!= null) 
      { 
        
        _expand_ByteDataAccessBaseJc(REFJc (thiz->parent), ixEndNew, -1, _thCxt);/*all parents nextChild set to end of child, don't change the parent's ixEnd!*/
        
      }
    }
    if(thiz->ixNextChild < ixNextChildNew) 
    { 
      
      if(ixNextChildNew > thiz->ixEnd) {
        THROW_s0(IllegalArgumentException, "next child pos after ixend=%d ixNextChilNew=%d", thiz->data.val, ixEndNew);
      }
      thiz->ixNextChild = ixNextChildNew;
    }
  }
  STACKTRC_LEAVE;
}


/**Assigns new data to this element at given index in data. This method should be used only for an root element.  */
void assign_iYii_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int8ARRAY dataP, int32 lengthData, int32 index, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("assign_iYii_ByteDataAccessBaseJc");
  
  { 
    
    ASSERT(/*J2C:static method call*/index >= 0 && thiz->sizeHead >= 0);
    detach_ByteDataAccessBaseJc(thiz, _thCxt);
    thiz->data = dataP;
    thiz->ixBegin = index;
    CLEAR_REFJc(thiz->parent);
    CLEAR_REFJc(thiz->currChild);
    thiz->bExpand = lengthData < thiz->sizeHead;/*expand if the data have no head.*/
    
    thiz->ixNextChild = thiz->ixBegin + thiz->sizeHead;/*lengthData is inclusively head. maybe checl lengthData, >=sizeHead or 0.*/
    
    thiz->ixEnd = thiz->bExpand ? thiz->ixBegin + thiz->sizeHead : thiz->ixBegin + lengthData;
    
    { /*:@Java4C.Exclude*/
      
      
      if(thiz->ixEnd > thiz->data.val) { 
        THROW_s0(IllegalArgumentException, "not enough data bytes, requested=%d, buffer-length=%d", thiz->data.val, ixEndNew);
      }
    }
    
    { }
  }
  STACKTRC_LEAVE;
}


/**Returns true if the instance is set as expandable, see {@link #assign(byte[], int)}*/
bool isExpandable_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("isExpandable_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->bExpand;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the given head size, which is set on constructor respectively which is a determined value of an derived instance of this.*/
int32 sizeHead_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("sizeHead_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->sizeHead;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the data buffer itself. The actual total length is getted with getLengthTotal().*/
int8ARRAY getData_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getData_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->data;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the length of the head. This method returns the size of the head given on construction*/
int32 getLengthHead_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getLengthHead_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->sizeHead;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the length of the element with all yet added children. */
int32 getLengthCurrent_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getLengthCurrent_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->ixNextChild - thiz->ixBegin;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the length of the existing actual element.*/
int32 getLength_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getLength_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->ixEnd - thiz->ixBegin;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the length of the data.*/
int32 getLengthTotal_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getLengthTotal_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->ixEnd;
    }
  }
  STACKTRC_LEAVE;
}


/**returns the number number of bytes there are max available from position of the current child. */
int32 getMaxNrofBytes_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getMaxNrofBytes_ByteDataAccessBaseJc");
  
  { 
    
    if(thiz->bExpand) { STACKTRC_LEAVE;
      return thiz->data.val - thiz->ixBegin;
    }
    else { STACKTRC_LEAVE;
      return thiz->ixEnd - thiz->ixBegin;
    }
  }
  STACKTRC_LEAVE;
}


/**Checks whether a given size is possible as {@link #setLengthElement(int)} for the given instance.*/
bool checkLengthElement_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 size, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("checkLengthElement_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return size >= thiz->sizeHead && getMaxNrofBytes_ByteDataAccessBaseJc(thiz, _thCxt) >= size;
    }
  }
  STACKTRC_LEAVE;
}

bool getBigEndian_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getBigEndian_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->bBigEndian;
    }
  }
  STACKTRC_LEAVE;
}

bool isInUse_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("isInUse_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->data.addr!= null;
    }
  }
  STACKTRC_LEAVE;
}


/**returns true if the given number of bytes is sufficing in the data from position of next child. */
bool sufficingBytesForNextChild_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 nrofBytes, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("sufficingBytesForNextChild_ByteDataAccessBaseJc");
  
  { 
    
    
    int32  maxNrofBytesChild = getMaxNrofBytesForNextChild_ByteDataAccessBaseJc(thiz, _thCxt);
    { STACKTRC_LEAVE;
      return nrofBytes < 0 ? false : maxNrofBytesChild >= nrofBytes;
    }
  }
  STACKTRC_LEAVE;
}


/**returns the maximal number of bytes which are available from position of a next current child. */
int32 getMaxNrofBytesForNextChild_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getMaxNrofBytesForNextChild_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return (thiz->bExpand ? thiz->data.val : thiz->ixEnd) - thiz->ixNextChild;
    }
  }
  STACKTRC_LEAVE;
}


/**Adds a child Element after the current child or as first child after head.*/
bool addChild_XXi_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, struct ByteDataAccessBaseJc_t* child, int32 sizeChild, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addChild_XXi_ByteDataAccessBaseJc");
  
  { 
    
    detach_ByteDataAccessBaseJc(child, _thCxt);/*detatch the child from further usage.*/
    
    ASSERT(/*J2C:static method call*/sizeChild == 0 || sizeChild >= child->sizeHead);
    ASSERT(/*J2C:static method call*/child->sizeHead >= 0);
    
    int32  ixChild1 = setIdxtoNextCurrentChild_ByteDataAccessBaseJc(thiz, sizeChild == 0 ? child->sizeHead : sizeChild, _thCxt);
    if(ixChild1 < 0) { STACKTRC_LEAVE;
      return false;
    }
    child->ixBegin = ixChild1;
    child->bBigEndian = thiz->bBigEndian;
    child->bExc = thiz->bExc;
    child->bExpand = thiz->bExpand;
    child->data = thiz->data;
    SETREFJc(child->parent, thiz, ByteDataAccessBaseJc_s);
    child->charset = thiz->charset;
    child->ixNextChild = child->ixBegin + child->sizeHead;/*the child does not contain grand children.*/
    
    child->ixEnd = thiz->ixEnd;/*bExpand ? child.ixNextChild : this.ixEnd;  //use the full data range maybe for child.*/
    
    SETREFJc(thiz->currChild, child, ByteDataAccessBaseJc_s);
    { STACKTRC_LEAVE;
      return true;
    }
  }
  STACKTRC_LEAVE;
}


/**Adds a child with its given head size without additional data space.*/
bool addChild_XX_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, struct ByteDataAccessBaseJc_t* child, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addChild_XX_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return addChild_XXi_ByteDataAccessBaseJc(thiz, child, child->sizeHead, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

bool addChildEmpty_XX_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, struct ByteDataAccessBaseJc_t* child, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addChildEmpty_XX_ByteDataAccessBaseJc");
  
  { 
    
    if(addChild_XX_ByteDataAccessBaseJc(thiz, child, _thCxt)) 
    { /*:first add the child*/
      
      
      clearHead_ByteDataAccessBaseJc(child);/*then clears its data.*/
      
      { STACKTRC_LEAVE;
        return true;
      }
    }
    else { STACKTRC_LEAVE;
      return false;
    }
  }
  STACKTRC_LEAVE;
}

bool addChildEmpty_XXi_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, struct ByteDataAccessBaseJc_t* child, int32 sizeChild, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addChildEmpty_XXi_ByteDataAccessBaseJc");
  
  { 
    
    if(addChild_XXi_ByteDataAccessBaseJc(thiz, child, sizeChild, _thCxt)) 
    { /*:first add the child*/
      
      
      clearData_ByteDataAccessBaseJc(child);/*then clears its data.*/
      
      { STACKTRC_LEAVE;
        return true;
      }
    }
    else { STACKTRC_LEAVE;
      return false;
    }
  }
  STACKTRC_LEAVE;
}


/**Adds a child at any position. This method is usefully if the data structure is known and specific elements should be accessed.*/
void addChildAt_iXXi_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idxChild, struct ByteDataAccessBaseJc_t* child, int32 sizeChild, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addChildAt_iXXi_ByteDataAccessBaseJc");
  
  { 
    
    ASSERT(/*J2C:static method call*/child->sizeHead >= 0);
    ASSERT(/*J2C:static method call*/sizeChild >= child->sizeHead);
    if(REFJc(child->parent)!= null && REFJc(REFJc    (child->parent)->currChild)== child) 
    { 
      
      CLEAR_REFJc(REFJc    (child->parent)->currChild);
    }/*detatch*/
    
    child->data = thiz->data;
    
    int32  idxBegin = thiz->ixBegin + idxChild;
    child->ixBegin = idxBegin;
    child->ixEnd = idxBegin + sizeChild;
    child->ixNextChild = idxBegin + child->sizeHead;
    child->bBigEndian = thiz->bBigEndian;
    child->bExc = thiz->bExc;
    child->bExpand = thiz->bExpand;
    SETREFJc(child->parent, thiz, ByteDataAccessBaseJc_s);
    _expand_ByteDataAccessBaseJc(thiz, child->ixNextChild, child->ixEnd, _thCxt);/*return bExpand;*/
    
  }
  STACKTRC_LEAVE;
}


/**Adds a child at any position with its head size. */
void addChildAt_iXX_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idxChild, struct ByteDataAccessBaseJc_t* child, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addChildAt_iXX_ByteDataAccessBaseJc");
  
  { 
    
    addChildAt_iXXi_ByteDataAccessBaseJc(thiz, idxChild, child, child->sizeHead, _thCxt);
  }
  STACKTRC_LEAVE;
}


/**Adds a child for 1 integer value without a child instance, and sets the value as integer.*/
bool addChildInt_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 nrofBytes, int32 value, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addChildInt_ByteDataAccessBaseJc");
  
  { 
    
    ASSERT(/*J2C:static method call*/nrofBytes > 0);
    
    int32  ixChild1 = setIdxtoNextCurrentChild_ByteDataAccessBaseJc(thiz, nrofBytes, _thCxt);
    if(ixChild1 < 0) { STACKTRC_LEAVE;
      return false;
    }/*NOTE: there is no instance for this child, but it is the current child anyway.*/
    /*NOTE: to read from idxInChild = 0, build the difference as shown:*/
    
    _setInt_ByteDataAccessBaseJc(thiz, ixChild1 - thiz->ixBegin, nrofBytes, value);
    { STACKTRC_LEAVE;
      return true;
    }
  }
  STACKTRC_LEAVE;
}


/**Adds a child for 1 integer value without a child instance, and sets the value as integer.*/
bool addChildInteger_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 nrofBytes, int64 value, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addChildInteger_ByteDataAccessBaseJc");
  
  { 
    
    ASSERT(/*J2C:static method call*/nrofBytes > 0);
    
    int32  ixChild1 = setIdxtoNextCurrentChild_ByteDataAccessBaseJc(thiz, nrofBytes, _thCxt);
    if(ixChild1 < 0) { STACKTRC_LEAVE;
      return false;
    }/*NOTE: there is no instance for this child, but it is the current child anyway.*/
    /*NOTE: to read from idxInChild = 0, build the difference as shown:*/
    
    _setLong_ByteDataAccessBaseJc(thiz, ixChild1 - thiz->ixBegin, nrofBytes, value);
    { STACKTRC_LEAVE;
      return true;
    }
  }
  STACKTRC_LEAVE;
}


/**Adds a child for 1 float value without a child instance, and sets the value as float.*/
bool addChildFloat_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, float value, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addChildFloat_ByteDataAccessBaseJc");
  
  { 
    
    
    int32  ixChild1 = setIdxtoNextCurrentChild_ByteDataAccessBaseJc(thiz, 4, _thCxt);
    if(ixChild1 < 0) { STACKTRC_LEAVE;
      return false;
    }/*NOTE: there is no instance for this child, but it is the current child anyway.*/
    /*NOTE: to read from idxInChild = 0, build the difference as shown:*/
    
    setFloat_if_ByteDataAccessBaseJc(thiz, ixChild1 - thiz->ixBegin, value);
    { STACKTRC_LEAVE;
      return true;
    }
  }
  STACKTRC_LEAVE;
}


#ifndef DEF_NO_StringUSAGE
/**Adds a child with String value.*/
bool addChildString_SSb_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, StringJc value, StringJc sEncoding, bool preventCtrlChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addChildString_SSb_ByteDataAccessBaseJc");
  
  { 
    
    
    int32  nrofBytes = length_StringJc(value);
    
    int32  ixChild1 = setIdxtoNextCurrentChild_ByteDataAccessBaseJc(thiz, nrofBytes, _thCxt);
    if(ixChild1 < 0) { STACKTRC_LEAVE;
      return false;
    }/*NOTE: there is no instance for this child, but it is the current child anyway.*/
    /*NOTE: to read from idxInChild = 0, build the difference as shown:*/
    
    _setString_ByteDataAccessBaseJc(thiz, ixChild1 - thiz->ixBegin, nrofBytes, value, sEncoding, preventCtrlChars, _thCxt);
    { STACKTRC_LEAVE;
      return true;
    }
  }
  STACKTRC_LEAVE;
}
#endif 


#ifndef DEF_NO_StringUSAGE

/**Adds a child with String value.*/
bool addChildString_CsS_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, CharSeqJc valueCs, StringJc sEncoding, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addChildString_CsS_ByteDataAccessBaseJc");
  
  { 
    
    
    int32  nrofBytes = length_CharSeqJc(valueCs/*J1cT2*/, _thCxt);
    
    int32  ixChild1 = setIdxtoNextCurrentChild_ByteDataAccessBaseJc(thiz, nrofBytes, _thCxt);
    if(ixChild1 < 0) { STACKTRC_LEAVE;
      return false;
    }/*NOTE: there is no instance for this child, but it is the current child anyway.*/
    /*NOTE: to read from idxInChild = 0, build the difference as shown:*/
    
    { int32 ii; 
      for(ii = 0; ii < nrofBytes; ++ii)
        { 
          
          
          int8  charByte = (int8 /*J2C_cast*/)(charAt_CharSeqJc(valueCs/*J1cT2*/, ii, _thCxt));
          thiz->data.addr[ixChild1 + ii] = charByte;
        }
    }
    { STACKTRC_LEAVE;
      return true;
    }
  }
  STACKTRC_LEAVE;
}

#endif //DEF_NO_StringUSAGE


/**Adds a child for 1 short value without a child instance, returns the value as short.*/
int16 getChildInt16_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getChildInt16_ByteDataAccessBaseJc");
  
  { 
    
    
    int32  ixChild1 = setIdxtoNextCurrentChild_ByteDataAccessBaseJc(thiz, 2, _thCxt);
    if(ixChild1 < 0) { STACKTRC_LEAVE;
      return 0;
    }
    { STACKTRC_LEAVE;
      return getInt16_i_ByteDataAccessBaseJc(thiz, ixChild1 - thiz->ixBegin);
    }
  }
  STACKTRC_LEAVE;
}


/**Adds a child for 1 short value without a child instance, returns the value as short.*/
int32 getChildUint16_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getChildUint16_ByteDataAccessBaseJc");
  
  { 
    
    
    int32  ixChild1 = setIdxtoNextCurrentChild_ByteDataAccessBaseJc(thiz, 2, _thCxt);
    if(ixChild1 < 0) { STACKTRC_LEAVE;
      return 0;
    }
    { STACKTRC_LEAVE;
      return getUint16_i_ByteDataAccessBaseJc(thiz, ixChild1 - thiz->ixBegin);
    }
  }
  STACKTRC_LEAVE;
}


/**Adds a child for 1 short value without a child instance, returns the value as short.*/
int16 getChildUint8_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getChildUint8_ByteDataAccessBaseJc");
  
  { 
    
    
    int32  ixChild1 = setIdxtoNextCurrentChild_ByteDataAccessBaseJc(thiz, 1, _thCxt);
    if(ixChild1 < 0) { STACKTRC_LEAVE;
      return 0;
    }
    { STACKTRC_LEAVE;
      return getUint8_i_ByteDataAccessBaseJc(thiz, ixChild1 - thiz->ixBegin);
    }
  }
  STACKTRC_LEAVE;
}


/**adds a child for 1 integer value without a child instance and returns the value as long integer.*/
int64 getChildInteger_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 nrofBytes, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getChildInteger_ByteDataAccessBaseJc");
  
  { /*:NOTE: there is no instance for this child, but it is the current child anyway.*/
    
    
    
    int32  bytes1 = nrofBytes < 0 ? -nrofBytes : nrofBytes;
    
    int32  ixChild1 = setIdxtoNextCurrentChild_ByteDataAccessBaseJc(thiz, bytes1, _thCxt);
    if(ixChild1 < 0) { STACKTRC_LEAVE;
      return 0;
    }/*NOTE: to read from idxInChild = 0, build the difference as shown:*/
    
    
    int64  value = _getLong_ByteDataAccessBaseJc(thiz, ixChild1 - thiz->ixBegin, nrofBytes);
    { STACKTRC_LEAVE;
      return value;
    }
  }
  STACKTRC_LEAVE;
}


/**Adds a child for 1 integer value without a child instance and returns the value as 32-bit-integer.*/
int32 getChildInt_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 nrofBytes, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getChildInt_ByteDataAccessBaseJc");
  
  { /*:NOTE: there is no instance for this child, but it is the current child anyway.*/
    
    
    
    int32  bytes1 = nrofBytes < 0 ? -nrofBytes : nrofBytes;
    
    int32  ixChild1 = setIdxtoNextCurrentChild_ByteDataAccessBaseJc(thiz, bytes1, _thCxt);
    if(ixChild1 < 0) { STACKTRC_LEAVE;
      return 0;
    }/*NOTE: to read from idxInChild = 0, build the difference as shown:*/
    
    
    int32  value = _getInt_ByteDataAccessBaseJc(thiz, ixChild1 - thiz->ixBegin, nrofBytes);
    { STACKTRC_LEAVE;
      return value;
    }
  }
  STACKTRC_LEAVE;
}


/**Adds a child for 1 float value without a child instance, but returns the value as integer.*/
float getChildFloat_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getChildFloat_ByteDataAccessBaseJc");
  
  { /*:NOTE: there is no instance for this child, but it is the current child anyway.*/
    
    
    
    int32  ixChild1 = setIdxtoNextCurrentChild_ByteDataAccessBaseJc(thiz, 4, _thCxt);
    if(ixChild1 < 0) { STACKTRC_LEAVE;
      return 0;
    }/*NOTE: to read from idxInChild = 0, build the difference as shown:*/
    
    
    int32  intRepresentation = (int32 /*J2C_cast*/)_getLong_ByteDataAccessBaseJc(thiz, ixChild1 - thiz->ixBegin, 4);
    { STACKTRC_LEAVE;
      return intBitsToFloat_FloatJc(/*J2C:static method call*/intRepresentation);
    }
  }
  STACKTRC_LEAVE;
}


/**Adds a child for 1 double value without a child instance, but returns the value as integer.*/
double getChildDouble_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getChildDouble_ByteDataAccessBaseJc");
  
  { /*:NOTE: there is no instance for this child, but it is the current child anyway.*/
    
    
    
    int32  ixChild1 = setIdxtoNextCurrentChild_ByteDataAccessBaseJc(thiz, 8, _thCxt);
    if(ixChild1 < 0) { STACKTRC_LEAVE;
      return 0;
    }/*NOTE: to read from idxInChild = 0, build the difference as shown:*/
    
    
    int64  intRepresentation = _getLong_ByteDataAccessBaseJc(thiz, ixChild1 - thiz->ixBegin, 8);
    { STACKTRC_LEAVE;
      return longBitsToDouble_DoubleJc(/*J2C:static method call*/intRepresentation);
    }
  }
  STACKTRC_LEAVE;
}


#if !defined(DEF_ObjectSimple_emC) && !defined(DEF_NO_ObjectJc_emC) && !defined(DEF_NO_StringUSAGE)
/**Adds a child for a String value without a child instance, but returns the value as String.*/
StringJc getChildString_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 nrofBytes, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getChildString_ByteDataAccessBaseJc");
  
  { /*:NOTE: there is no instance for this child, but it is the current child anyway.*/
    
    
    ASSERT(/*J2C:static method call*/nrofBytes >= 0);
    
    int32  ixChild1 = setIdxtoNextCurrentChild_ByteDataAccessBaseJc(thiz, nrofBytes, _thCxt);
    if(ixChild1 < 0) { STACKTRC_LEAVE;
      return null_StringJc /*J2C: mem assignment*/;
    }/*NOTE: to read from idxInChild = 0, build the difference as shown:*/
    
    { STACKTRC_LEAVE;
      return getString_ByteDataAccessBaseJc(thiz, ixChild1 - thiz->ixBegin, nrofBytes, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}
#endif

/**Shorten the evaluated content of the data to the position of the given child. The given child is removed.*/
void removeChild_XX_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, struct ByteDataAccessBaseJc_t* child, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("removeChild_XX_ByteDataAccessBaseJc");
  
  { 
    
    if(REFJc(child->parent)!= thiz) { THROW_s0(IllegalArgumentException, "programming error - child is not parent of this.", 0, 0); };
    thiz->ixNextChild = child->ixBegin;/*set end index to the child's start*/
    
    if(thiz->bExpand) 
    { 
      
      thiz->ixEnd = thiz->ixNextChild;
    }
    if(REFJc(thiz->currChild)!= null) 
    { 
      
      detach_ByteDataAccessBaseJc(REFJc (thiz->currChild), _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Remove all connections. Especially for children. */
void detach_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("detach_ByteDataAccessBaseJc");
  
  { 
    
    if(REFJc(thiz->parent)!= null && REFJc(REFJc    (thiz->parent)->currChild)== thiz) 
    { 
      
      CLEAR_REFJc(REFJc    (thiz->parent)->currChild);/*detach in parent*/
      
    }
    if(REFJc(thiz->currChild) != null) 
    { 
      
      detach_ByteDataAccessBaseJc(REFJc (thiz->currChild), _thCxt);
      CLEAR_REFJc(thiz->currChild);/*necessary if currentChild don't refers this parent because any error before.*/
      
    }
    thiz->data.addr = null; thiz->data.val = 0; /*J2C:arrayPtrVal_null*/;
    CLEAR_REFJc(thiz->parent);
    thiz->ixBegin = thiz->ixEnd = /*? assignment*/0;
    thiz->ixNextChild = 0;
    thiz->bExpand = false;
  }
  STACKTRC_LEAVE;
}


/**Returns the position of the Element data in the assigned buffer.*/
int32 getPositionInBuffer_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getPositionInBuffer_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->ixBegin;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the position of a next child which can be added in the assigned buffer.*/
int32 getPositionNextChildInBuffer_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getPositionNextChildInBuffer_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->ixNextChild;
    }/*//*/
    
  }
  STACKTRC_LEAVE;
}


/**copies the data from another references data into this data.*/
void copyDataFrom_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, struct ByteDataAccessBaseJc_t* src, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("copyDataFrom_ByteDataAccessBaseJc");
  
  { 
    
    
    int32  len = getLength_ByteDataAccessBaseJc(src, _thCxt);
    if(thiz->data.val < len) {
      THROW_s0(IllegalArgumentException, "copy, dst to small %d", len, 0);
    }/*//TODO System.arraycopy(src.data,src.idxBegin,data,idxBegin,len);*/
    
  }
  STACKTRC_LEAVE;
}


#if !defined(DEF_ObjectSimple_emC) && !defined(DEF_NO_ObjectJc_emC)
/**copies some data to a int[], primarily to debug a content. */
void copyData_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32_Y* dst, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("copyData_ByteDataAccessBaseJc");
  
  { 
    
    
    int32  iDst = 0;
    int32  idxMax = thiz->ixEnd - thiz->ixBegin;
    if(idxMax / 4 > dst->head.length) idxMax = 4 * dst->head.length;
    
    { int32 idx; 
      for(idx = 0; idx < idxMax; idx += 4)
        { 
          
          dst->data[iDst++] = (int32 /*J2C_cast*/)_getLong_ByteDataAccessBaseJc(thiz, idx, 4);
        }
    }
  }
  STACKTRC_LEAVE;
}
#endif

#if !defined(DEF_ObjectSimple_emC) && !defined(DEF_NO_ObjectJc_emC) && !defined(DEF_NO_StringUSAGE)
/**Returns a String from the given position inside the actual element .*/
StringJc getString_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx, int32 nrofBytes, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getString_ByteDataAccessBaseJc");
  
  { 
    
    
    int32  idxData = idx + thiz->ixBegin;
    
    int32  idxEnd1 = idxData + nrofBytes;
    ASSERT(/*J2C:static method call*/idxEnd1 <= thiz->ixEnd && idxEnd1 <= thiz->data.val);
    
    while(thiz->data.addr[--idxEnd1] == 0 && idxEnd1 > idxData)
      ;/*skip 0 character on end*/
      
    
    int32  len = idxEnd1 + 1 - idxData;
    
    StringJc value ; value;/*no initvalue*/
    value = new_mBYIIEncoding_StringJc(/*J2C:static method call*/thiz->data, idxData, len, thiz->charset, _thCxt)/*J2C:non-persistent*/;
    { STACKTRC_LEAVE;
      return value;
    }
  }
  STACKTRC_LEAVE;
}
#endif


#ifndef DEF_NO_StringUSAGE
/**Sets a String to the the given position inside the actual element .*/
int32 setString_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx, int32 nmax, StringJc ss, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setString_ByteDataAccessBaseJc");
  
  { 
    
    if(length_StringJc(ss) > nmax) 
    { 
      
      ss = substring_StringJc(ss, 0, nmax, _thCxt)/*J2C:non-persistent*/;
    }/*truncate.*/
    
    
    ByteStringJc  byteRepresentation;/*no initvalue*/
    TRY
    { 
      
      byteRepresentation = getBytesEncoding_StringJc(ss, s0_StringJc("ISO-8859-1"), _thCxt);
    }_TRY
    CATCH(UnsupportedEncodingException, e)
    
      { 
        
        byteRepresentation = null_AddrVal_emC /*J2C: mem assignment*/;
      }
    END_TRY
    
    int32  len = length_ByteStringJc(byteRepresentation);
    if(len > nmax) 
    { 
      
      len = nmax;
    }/*truncate.*/
    
    arraycopy_vm_SystemJc(/*J2C:static method call*/byteRepresentation, 0, thiz->data, thiz->ixBegin + idx, len, _thCxt);
    { STACKTRC_LEAVE;
      return len;
    }
  }
  STACKTRC_LEAVE;
}
#endif //DEF_NO_StringUSAGE



#ifndef DEF_NO_StringUSAGE
/**sets the content inside the actual element with the character bytes from the given String.*/
void _setString_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx, int32 nrofBytes, StringJc value, StringJc sEncoding, bool preventCtrlChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("_setString_ByteDataAccessBaseJc");
  
  { 
    
    
    int32  idxData = idx + thiz->ixBegin;
    
    int32  idxEnd = idxData + nrofBytes;
    
    ByteStringJc  chars;/*no initvalue*/
    if(sEncoding.addr.str== null) 
    { 
      
      sEncoding = z_StringJc("ISO-8859-1")/*J2C:non-persistent*/;
    }
    chars = getBytesEncoding_StringJc(value, sEncoding, _thCxt);
    
    int32  srcLen = length_ByteStringJc(chars);
    if(srcLen > nrofBytes) 
    { 
      
      srcLen = nrofBytes;
    }
    { int32 ii; 
      for(ii = 0; ii < srcLen; ++ii)
        { 
          
          
          int8  cc = ((/*J2C:cast% from ByteStringJc*/int8)(data_ByteStringJc(chars)[ii]));
          if(preventCtrlChars && cc < 0x20) 
          { 
            
            cc = ((/*J2C:cast% from int32*/int8)(0x3f));
          }/*'?' in ASCII*/
          
          thiz->data.addr[idxData++] = cc;
        }/*fill up the rest of the string with 0-chars. */
        
    }
    
    while(idxData < idxEnd)
      { 
        
        thiz->data.addr[idxData++] = 0;
      }
  }
  STACKTRC_LEAVE;
}
#endif //DEF_NO_StringUSAGE

/**Gets a float value from the content of 4 byte. The float value is red*/
float getFloat_i_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx)
{ 
  
  { 
    
    
    int32  intRepresentation = getInt32_i_ByteDataAccessBaseJc(thiz, idx);
    
    float  value = intBitsToFloat_FloatJc(/*J2C:static method call*/intRepresentation);
    
      return value;
  }
}

double getDouble_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx)
{ 
  
  { 
    
    
    int64  intRepresentation = _getLong_ByteDataAccessBaseJc(thiz, idx, 8);
    
      return longBitsToDouble_DoubleJc(/*J2C:static method call*/intRepresentation);
  }
}

int64 getInt64_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx)
{ 
  
  { 
    
    
    int32  nLo;/*no initvalue*/
    
    int32  nHi;/*no initvalue*/
    if(thiz->bBigEndian) 
    { 
      
      nLo = getInt32_i_ByteDataAccessBaseJc(thiz, idx);
      nHi = getInt32_i_ByteDataAccessBaseJc(thiz, idx + 4);
    }
    else 
    { 
      
      nLo = getInt32_i_ByteDataAccessBaseJc(thiz, idx + 4);
      nHi = getInt32_i_ByteDataAccessBaseJc(thiz, idx);
    }
    
    int64  val = ((int64)nHi) << 32;
    val |= nLo & 0xffffffff;
    
      return val;
  }
}


/**Returns the content of 4 bytes inside the actual element as a integer number between -2147483648 and 2147483647,*/
int32 getInt32_i_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx)
{ 
  
  { 
    
    
    int32  val;/*no initvalue*/
    if(thiz->bBigEndian) 
    { 
      
      val = ((thiz->data.addr[thiz->ixBegin + idx]) << 24) | (((thiz->data.addr[thiz->ixBegin + idx + 1]) << 16) & 0xff0000) | (((thiz->data.addr[thiz->ixBegin + idx + 2]) << 8) & 0xff00) | (((thiz->data.addr[thiz->ixBegin + idx + 3])) & 0xff);/*NOTE: the value has only 8 bits for bitwise or.*/
      
    }
    else 
    { 
      
      val = ((thiz->data.addr[thiz->ixBegin + idx + 3]) << 24) | (((thiz->data.addr[thiz->ixBegin + idx + 2]) << 16) & 0xff0000) | (((thiz->data.addr[thiz->ixBegin + idx + 1]) << 8) & 0xff00) | (((thiz->data.addr[thiz->ixBegin + idx])) & 0xff);/*NOTE: the value has only 8 bits for bitwise or.*/
      
    }
    
      return val;
  }
}

int32 getUint32_i_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx)
{ 
  
  { 
    
    
      return getInt32_i_ByteDataAccessBaseJc(thiz, idx);
  }
}


/**Returns the content of 2 bytes as a positive nr between 0..65535, big-endian*/
int32 getUint16_i_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx)
{ 
  
  { 
    
    
    int32  val;/*no initvalue*/
    if(thiz->bBigEndian) 
    { 
      
      val = (((thiz->data.addr[thiz->ixBegin + idx]) << 8) & 0xff00) | (((thiz->data.addr[thiz->ixBegin + idx + 1])) & 0xff);/*NOTE: the value has only 8 bits for bitwise or.*/
      
    }
    else 
    { 
      
      val = (((thiz->data.addr[thiz->ixBegin + idx + 1]) << 8) & 0xff00) | (((thiz->data.addr[thiz->ixBegin + idx])) & 0xff);/*NOTE: the value has only 8 bits for bitwise or.*/
      
    }
    
      return val;
  }
}


/**Returns the content of 2 bytes as a positive nr between 0..65535 inside the actual element.*/
int16 getInt16_i_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx)
{ 
  
  { 
    
    
    int32  val;/*no initvalue*/
    if(thiz->bBigEndian) 
    { 
      
      val = (((thiz->data.addr[thiz->ixBegin + idx]) << 8) & 0xff00) | (((thiz->data.addr[thiz->ixBegin + idx + 1])) & 0xff);/*NOTE: the value has only 8 bits for bitwise or.*/
      
    }
    else 
    { 
      
      val = (((thiz->data.addr[thiz->ixBegin + idx + 1]) << 8) & 0xff00) | (((thiz->data.addr[thiz->ixBegin + idx])) & 0xff);/*NOTE: the value has only 8 bits for bitwise or.*/
      
    }
    
      return (int16 /*J2C_cast*/)val;
  }
}


/**Returns the content of 1 bytes as ASCII*/
char getChar_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx)
{ 
  
  { 
    
    
    char  val;/*no initvalue*/
    val = (char /*J2C_cast*/)thiz->data.addr[thiz->ixBegin + idx];
    
      return val;
  }
}


/**Returns the content of 1 bytes as a positive or negative nr between -128..127*/
int8 getInt8_i_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx)
{ 
  
  { 
    
    
    int8  val;/*no initvalue*/
    val = thiz->data.addr[thiz->ixBegin + idx];
    
      return val;
  }
}


/**Returns the content of 1 bytes as a positive or negative nr between -128..127*/
int16 getUint8_i_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx)
{ 
  
  { 
    
    
    int16  val;/*no initvalue*/
    val = thiz->data.addr[thiz->ixBegin + idx];
    if(val < 0) 
    { 
      
      val += ((/*J2C:cast% from int32*/int16)(0x100));
    }
    
      return val;
  }
}

int32 getUint32_iii_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idxBytes, int32 idxArray, int32 lengthArray, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getUint32_iii_ByteDataAccessBaseJc");
  
  { 
    
    if(idxArray >= lengthArray || idxArray < 0) { 
      THROW_s0(IllegalArgumentException, "faulty ixArray %d", idxArray, 0);
    }
    { STACKTRC_LEAVE;
      return getUint32_i_ByteDataAccessBaseJc(thiz, idxBytes + 4 * idxArray);
    }
  }
  STACKTRC_LEAVE;
}

int32 getInt32_iii_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idxBytes, int32 idxArray, int32 lengthArray, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getInt32_iii_ByteDataAccessBaseJc");
  
  { 
    
    if(idxArray >= lengthArray || idxArray < 0) { 
      THROW_s0(IllegalArgumentException, "faulty ixArray %d", idxArray, 0);
    }
    { STACKTRC_LEAVE;
      return getInt32_i_ByteDataAccessBaseJc(thiz, idxBytes + 4 * idxArray);
    }
  }
  STACKTRC_LEAVE;
}

int32 getInt16_iii_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idxBytes, int32 idxArray, int32 lengthArray, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getInt16_iii_ByteDataAccessBaseJc");
  
  { 
    
    if(idxArray >= lengthArray || idxArray < 0) { 
      THROW_s0(IllegalArgumentException, "faulty ixArray %d", idxArray, 0);
    }
    { STACKTRC_LEAVE;
      return getInt16_i_ByteDataAccessBaseJc(thiz, idxBytes + 2 * idxArray);
    }
  }
  STACKTRC_LEAVE;
}

int32 getInt8_iii_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idxBytes, int32 idxArray, int32 lengthArray, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getInt8_iii_ByteDataAccessBaseJc");
  
  { 
    
    if(idxArray >= lengthArray || idxArray < 0) { 
      THROW_s0(IllegalArgumentException, "faulty ixArray %d", idxArray, 0);
    }
    { STACKTRC_LEAVE;
      return getInt8_i_ByteDataAccessBaseJc(thiz, idxBytes + idxArray);
    }
  }
  STACKTRC_LEAVE;
}

int32 getUint16_iii_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idxBytes, int32 idxArray, int32 lengthArray, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getUint16_iii_ByteDataAccessBaseJc");
  
  { 
    
    if(idxArray >= lengthArray || idxArray < 0) { 
      THROW_s0(IllegalArgumentException, "faulty ixArray %d", idxArray, 0);
    }
    { STACKTRC_LEAVE;
      return getUint16_i_ByteDataAccessBaseJc(thiz, idxBytes + 2 * idxArray);
    }
  }
  STACKTRC_LEAVE;
}

int32 getUint8_iii_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idxBytes, int32 idxArray, int32 lengthArray, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getUint8_iii_ByteDataAccessBaseJc");
  
  { 
    
    if(idxArray >= lengthArray || idxArray < 0) { 
      THROW_s0(IllegalArgumentException, "faulty ixArray %d", idxArray, 0);
    }
    { STACKTRC_LEAVE;
      return getInt8_i_ByteDataAccessBaseJc(thiz, idxBytes + idxArray);
    }
  }
  STACKTRC_LEAVE;
}

float getFloat_iii_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idxBytes, int32 idxArray, int32 lengthArray, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getFloat_iii_ByteDataAccessBaseJc");
  
  { 
    
    if(idxArray >= lengthArray || idxArray < 0) { 
      THROW_s0(IllegalArgumentException, "faulty ixArray %d", idxArray, 0);
    }
    { STACKTRC_LEAVE;
      return getFloat_i_ByteDataAccessBaseJc(thiz, idxBytes + 4 * idxArray);
    }
  }
  STACKTRC_LEAVE;
}


/**Set the content of 4 bytes as a integer number between -2147483648 and 2147483647,*/
void setInt32_ii_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx, int32 value, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setInt32_ii_ByteDataAccessBaseJc");
  
  { 
    
    if(thiz->bBigEndian) 
    { 
      
      thiz->data.addr[thiz->ixBegin + idx] = (int8 /*J2C_cast*/)((value >> 24) & 0xff);
      thiz->data.addr[thiz->ixBegin + idx + 1] = (int8 /*J2C_cast*/)((value >> 16) & 0xff);
      thiz->data.addr[thiz->ixBegin + idx + 2] = (int8 /*J2C_cast*/)((value >> 8) & 0xff);
      thiz->data.addr[thiz->ixBegin + idx + 3] = (int8 /*J2C_cast*/)(value & 0xff);
    }
    else 
    { 
      
      thiz->data.addr[thiz->ixBegin + idx + 3] = (int8 /*J2C_cast*/)((value >> 24) & 0xff);
      thiz->data.addr[thiz->ixBegin + idx + 2] = (int8 /*J2C_cast*/)((value >> 16) & 0xff);
      thiz->data.addr[thiz->ixBegin + idx + 1] = (int8 /*J2C_cast*/)((value >> 8) & 0xff);
      thiz->data.addr[thiz->ixBegin + idx] = (int8 /*J2C_cast*/)(value & 0xff);
    }
  }
  STACKTRC_LEAVE;
}


/**Set the content of 4 bytes as a positive nr between 0..2pow32-1, big- or little-endian.*/
void setUint32_il_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx, int64 value, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setUint32_il_ByteDataAccessBaseJc");
  
  { /*:the same algorithm in source, but other action on machine level,*/
    /*:because value is long!*/
    
    
    if(thiz->bBigEndian) 
    { 
      
      thiz->data.addr[thiz->ixBegin + idx] = (int8 /*J2C_cast*/)((value >> 24) & 0xff);
      thiz->data.addr[thiz->ixBegin + idx + 1] = (int8 /*J2C_cast*/)((value >> 16) & 0xff);
      thiz->data.addr[thiz->ixBegin + idx + 2] = (int8 /*J2C_cast*/)((value >> 8) & 0xff);
      thiz->data.addr[thiz->ixBegin + idx + 3] = (int8 /*J2C_cast*/)(value & 0xff);
    }
    else 
    { 
      
      thiz->data.addr[thiz->ixBegin + idx + 3] = (int8 /*J2C_cast*/)((value >> 24) & 0xff);
      thiz->data.addr[thiz->ixBegin + idx + 2] = (int8 /*J2C_cast*/)((value >> 16) & 0xff);
      thiz->data.addr[thiz->ixBegin + idx + 1] = (int8 /*J2C_cast*/)((value >> 8) & 0xff);
      thiz->data.addr[thiz->ixBegin + idx] = (int8 /*J2C_cast*/)(value & 0xff);
    }
  }
  STACKTRC_LEAVE;
}


/**Set the content of 2 bytes from an integer between -32768..32768,*/
void setInt16_ii_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx, int32 value, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setInt16_ii_ByteDataAccessBaseJc");
  
  { 
    
    if(thiz->bBigEndian) 
    { 
      
      thiz->data.addr[thiz->ixBegin + idx] = (int8 /*J2C_cast*/)((value >> 8) & 0xff);
      thiz->data.addr[thiz->ixBegin + idx + 1] = (int8 /*J2C_cast*/)(value & 0xff);
    }
    else 
    { 
      
      thiz->data.addr[thiz->ixBegin + idx + 1] = (int8 /*J2C_cast*/)((value >> 8) & 0xff);
      thiz->data.addr[thiz->ixBegin + idx] = (int8 /*J2C_cast*/)(value & 0xff);
    }
  }
  STACKTRC_LEAVE;
}

void throwexc_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, StringJc text, int32 idxArray, ThCxt* _thCxt)
{ 
  THROW(IndexOutOfBoundsException, text, idxArray, 0);  
}


/**Prepares a new child for this. It sets the this.{@link #ixNextChild} to the end of the new child given by argument sizeChild.*/
int32 setIdxtoNextCurrentChild_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 sizeChild, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setIdxtoNextCurrentChild_ByteDataAccessBaseJc");
  
  { 
    
    ASSERT(/*J2C:static method call*/sizeChild >= 0);
    ASSERT(/*J2C:static method call*/thiz->ixNextChild >= 0);/*==0 os possible on an empty element without head.*/
    
    
    int32  ixMax = thiz->bExpand ? thiz->data.val : thiz->ixEnd;
    if(thiz->ixNextChild + sizeChild > ixMax) { 
      ASSERT_emC(false, "child on limit of expand", thiz->ixNextChild + sizeChild, ixMax); 
      STACKTRC_RETURN -1;
    }
    
    int32  ixChild1 = thiz->ixNextChild;
    thiz->ixNextChild += sizeChild;
    _expand_ByteDataAccessBaseJc(thiz, thiz->ixNextChild, thiz->ixEnd, _thCxt);/*expand always the ixChildEnd*/
    
    { STACKTRC_LEAVE;
      return ixChild1;
    }
  }
  STACKTRC_LEAVE;
}

int32 ixBegin_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("ixBegin_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->ixBegin;
    }
  }
  STACKTRC_LEAVE;
}

int32 ixNextChild_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("ixNextChild_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->ixNextChild;
    }
  }
  STACKTRC_LEAVE;
}

int32 ixEnd_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("ixEnd_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->ixEnd;
    }
  }
  STACKTRC_LEAVE;
}


void finalize_ByteDataAccessBaseJc_F(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ STACKTRC_TENTRY("finalize_ByteDataAccessBaseJc_F");
  CLEAR_REFJc(thiz->parent);
  CLEAR_REFJc(thiz->currChild);
  STACKTRC_LEAVE;
}


#ifdef DEF_REFLECTION_FULL
extern_C struct ClassJc_t const refl_ByteDataAccessBaseJc_s;
extern_C struct ClassJc_t const refl_ByteDataAccessBaseJc_s;
extern_C struct ClassJc_t const refl_CharsetJc;
extern_C struct ClassJc_t const refl_StringJc;
const struct Reflection_Fields_ByteDataAccessBaseJc_s_t
{ ObjectArrayJc head; FieldJc data[12];
} refl_Fields_ByteDataAccessBaseJc_s =
{ CONST_ObjectArrayJc(FieldJc, 12, OBJTYPE_FieldJc, null, &refl_Fields_ByteDataAccessBaseJc_s)
, {
     { "sizeHead"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((intptr_t)(&((ByteDataAccessBaseJc_s*)(0x1000))->sizeHead) - 0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_ByteDataAccessBaseJc_s
    }
   , { "data"
    , 0 //nrofArrayElements
    , REFLECTION_int8
    , 1 << kBitPrimitiv_Modifier_reflectJc |kObjectArrayJc_Modifier_reflectJc |kPtrVal_Modifier_reflectJc //bitModifiers
    , (int16)((intptr_t)(&((ByteDataAccessBaseJc_s*)(0x1000))->data) - 0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_ByteDataAccessBaseJc_s
    }
   , { "ixBegin"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((intptr_t)(&((ByteDataAccessBaseJc_s*)(0x1000))->ixBegin) - 0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_ByteDataAccessBaseJc_s
    }
   , { "ixNextChild"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((intptr_t)(&((ByteDataAccessBaseJc_s*)(0x1000))->ixNextChild) - 0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_ByteDataAccessBaseJc_s
    }
   , { "ixEnd"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((intptr_t)(&((ByteDataAccessBaseJc_s*)(0x1000))->ixEnd) - 0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_ByteDataAccessBaseJc_s
    }
   , { "bExpand"
    , 0 //nrofArrayElements
    , REFLECTION_bool
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((intptr_t)(&((ByteDataAccessBaseJc_s*)(0x1000))->bExpand) - 0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_ByteDataAccessBaseJc_s
    }
   , { "bBigEndian"
    , 0 //nrofArrayElements
    , REFLECTION_bool
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((intptr_t)(&((ByteDataAccessBaseJc_s*)(0x1000))->bBigEndian) - 0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_ByteDataAccessBaseJc_s
    }
   , { "bExc"
    , 0 //nrofArrayElements
    , REFLECTION_bool
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((intptr_t)(&((ByteDataAccessBaseJc_s*)(0x1000))->bExc) - 0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_ByteDataAccessBaseJc_s
    }
   , { "parent"
    , 0 //nrofArrayElements
    , &refl_ByteDataAccessBaseJc_s
    , kEnhancedReference_Modifier_reflectJc /*@*/ //bitModifiers
    , (int16)((intptr_t)(&((ByteDataAccessBaseJc_s*)(0x1000))->parent) - 0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_ByteDataAccessBaseJc_s
    }
   , { "currChild"
    , 0 //nrofArrayElements
    , &refl_ByteDataAccessBaseJc_s
    , kEnhancedReference_Modifier_reflectJc /*@*/ //bitModifiers
    , (int16)((intptr_t)(&((ByteDataAccessBaseJc_s*)(0x1000))->currChild) - 0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_ByteDataAccessBaseJc_s
    }
   , { "charset"
    , 0 //nrofArrayElements
    , &refl_CharsetJc
    , kReference_Modifier_reflectJc //bitModifiers
    , (int16)((intptr_t)(&((ByteDataAccessBaseJc_s*)(0x1000))->charset) - 0x1000)
    , 0  //offsetToObjectifcBase
    , &refl_ByteDataAccessBaseJc_s
    }
   , { "version"
    , 0 //nrofArrayElements
    , &refl_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&version_ByteDataAccessBaseJc) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((intptr_t)(&version_ByteDataAccessBaseJc)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &refl_ByteDataAccessBaseJc_s
    }
} };
const ClassJc refl_ByteDataAccessBaseJc_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &refl_ObjectJc, &refl_ClassJc) 
, "ByteDataAccessBaseJc_s"
,  0 //position of ObjectJc
, sizeof(ByteDataAccessBaseJc_s)
, (FieldJc_Y const*)&refl_Fields_ByteDataAccessBaseJc_s
, null //method
, null //superclass
, null //interfaces
, 0    //modifiers
};

#endif //DEF_REFLECTION_FULL
